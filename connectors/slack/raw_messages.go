package slack

import (
	"regexp"
	"strings"

	"github.com/slack-go/slack"
)

/* raw_messages has a family of functions for dealing with complex Slack messages - specifically,
messages that may have multiple codeblock sections, as might be generated by the OpenAI API. */

func (s *slackConnector) processRawMessage(prefix, msg string) []string {
	msg = prefix + msg
	msg = normalizeBackticks(msg)

	maxSize := slack.MaxMessageTextLength - 500
	var splitMessages []string
	var currentMessage string
	var inCodeBlock bool

	lines := strings.Split(msg, "\n")
	for _, line := range lines {
		if len(line) > 0 && line[:3] == "```" {
			inCodeBlock = !inCodeBlock
		}
		if !inCodeBlock {
			line = s.replaceMentions(line)
		}
		// If the line is too long, we split it into chunks and treat each as a separate line.
		if len(line) > maxSize {
			chunks := chunkLine(line, maxSize, inCodeBlock)
			for _, chunk := range chunks {
				processLine(chunk, maxSize, &currentMessage, &inCodeBlock, &splitMessages, true)
			}
		} else {
			processLine(line, maxSize, &currentMessage, &inCodeBlock, &splitMessages, false)
		}
	}
	// Append the last message if it's not empty.
	if currentMessage != "" {
		splitMessages = append(splitMessages, currentMessage)
	}
	return splitMessages
}

func processLine(line string, maxSize int, currentMessage *string, inCodeBlock *bool, splitMessages *[]string, isChunk bool) {
	// Add the newline back to line if it's not a chunk and check if it fits into the current message.
	if !isChunk {
		line += "\n"
	}
	if len(*currentMessage)+len(line) <= maxSize {
		*currentMessage += line
	} else {
		// Close the code block if we're in one and this isn't a chunk.
		if *inCodeBlock && !isChunk {
			*currentMessage += "```\n"
		}
		*splitMessages = append(*splitMessages, *currentMessage)

		// Start a new message, opening a code block if necessary.
		*currentMessage = ""
		if *inCodeBlock && !isChunk {
			*currentMessage = "```\n"
		}
		*currentMessage += line
	}
}

func chunkLine(line string, chunkSize int, inCodeBlock bool) []string {
	var chunks []string
	for i := 0; i < len(line); i += chunkSize {
		end := i + chunkSize
		if end > len(line) {
			end = len(line)
		}
		chunk := line[i:end]
		// Add code block delimiters if we're in a code block.
		if inCodeBlock {
			chunk = "```\n" + chunk + "\n```\n"
		}
		chunks = append(chunks, chunk)
	}
	return chunks
}

// normalizeBackticks adds leading and trailing newlines to triple backticks (```)
// If the leading or trailing newline is already present, it doesn't duplicate it
func normalizeBackticks(input string) string {
	// Regular expression that matches a triple backtick with any character (or none) on either side
	re := regexp.MustCompile(".{0,1}```.{0,1}")

	// Replace function adds newlines before and after every triple backtick
	// If the newline is already present, it doesn't duplicate it
	return re.ReplaceAllStringFunc(input, func(s string) string {
		if s == "\n```\n" {
			return s
		}
		if strings.Count(s, "`") != 3 {
			return s
		}
		leading := string(s[0])
		trailing := string(s[len(s)-1])
		if leading == "`" {
			leading = ""
		} else if leading != "\n" {
			leading = leading + "\n"
		}
		if trailing == "`" {
			trailing = ""
		} else if trailing != "\n" {
			trailing = "\n" + trailing
		}
		return leading + "```" + trailing
	})
}

func (s *slackConnector) replaceMentions(input string) string {
	return mentionRe.ReplaceAllStringFunc(input, func(mentioned string) string {
		switch mentioned {
		case "here", "channel", "everyone":
			return "<!" + mentioned + ">"
		}
		replace, ok := s.userID(mentioned[1:], true)
		if ok {
			return "<@" + replace + ">"
		}
		return mentioned
	})
}
