<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gopherbot DevOps Chatbot</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Title.html">Title</a></li><li class="chapter-item expanded affix "><a href="Status.html">Status</a></li><li class="chapter-item expanded affix "><a href="Foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="Introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="Terminology.html">Terminology</a></li><li class="chapter-item expanded affix "><li class="part-title">Part I - Robot Setup, Configuration and Administration</li><li class="chapter-item expanded "><a href="botdev/IDE.html"><strong aria-hidden="true">1.</strong> The Gopherbot IDE</a></li><li class="chapter-item expanded "><a href="Installation.html"><strong aria-hidden="true">2.</strong> Setting Up a Gopherbot Robot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install/LinuxInstall.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install/Requirements.html"><strong aria-hidden="true">2.1.1.</strong> Software Requirements</a></li><li class="chapter-item expanded "><a href="install/ManualInstall.html"><strong aria-hidden="true">2.1.2.</strong> Installing on Linux</a></li></ol></li><li class="chapter-item expanded "><a href="botsetup/credentials.html"><strong aria-hidden="true">2.2.</strong> Team Chat Credentials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="botsetup/slacksock.html"><strong aria-hidden="true">2.2.1.</strong> Slack Socket Mode</a></li></ol></li><li class="chapter-item expanded "><a href="RobotInstall.html"><strong aria-hidden="true">2.3.</strong> Initial Robot Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="botsetup/Requirements.html"><strong aria-hidden="true">2.3.1.</strong> Environment Requirements</a></li><li class="chapter-item expanded "><a href="botsetup/gopherhome.html"><strong aria-hidden="true">2.3.2.</strong> Robot Directory Structure</a></li><li class="chapter-item expanded "><a href="botsetup/Plugin.html"><strong aria-hidden="true">2.3.3.</strong> Quick Start with Autosetup</a></li><li class="chapter-item expanded "><a href="botsetup/ManualSetup.html"><strong aria-hidden="true">2.3.4.</strong> Manual Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="botsetup/bothome.html"><strong aria-hidden="true">2.3.4.1.</strong> Create the GOPHER_HOME directory</a></li><li class="chapter-item expanded "><a href="botsetup/initenv.html"><strong aria-hidden="true">2.3.4.2.</strong> Create the Initial .env File</a></li><li class="chapter-item expanded "><a href="botsetup/initcrypt.html"><strong aria-hidden="true">2.3.4.3.</strong> Initialize Encryption</a></li><li class="chapter-item expanded "><a href="botsetup/copystd.html"><strong aria-hidden="true">2.3.4.4.</strong> Copy the Standard Robot</a></li><li class="chapter-item expanded "><a href="botsetup/sshkeys.html"><strong aria-hidden="true">2.3.4.5.</strong> Generate SSH Keypairs</a></li><li class="chapter-item expanded "><a href="botsetup/finalenv.html"><strong aria-hidden="true">2.3.4.6.</strong> Finish the .env File</a></li><li class="chapter-item expanded "><a href="botsetup/connect.html"><strong aria-hidden="true">2.3.4.7.</strong> Connect Robot to Team</a></li><li class="chapter-item expanded "><a href="botsetup/saverobot.html"><strong aria-hidden="true">2.3.4.8.</strong> Saving Your Robot to Git</a></li><li class="chapter-item expanded "><a href="botsetup/finished.html"><strong aria-hidden="true">2.3.4.9.</strong> Finished</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="RunRobot.html"><strong aria-hidden="true">3.</strong> Deploying and Running Your Robot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploy/Container.html"><strong aria-hidden="true">3.1.</strong> Running in a Container</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploy/DockerDeploy.html"><strong aria-hidden="true">3.1.1.</strong> Docker Example</a></li><li class="chapter-item expanded "><a href="deploy/Kubernetes.html"><strong aria-hidden="true">3.1.2.</strong> Deploying to Kubernetes</a></li></ol></li><li class="chapter-item expanded "><a href="deploy/systemd.html"><strong aria-hidden="true">3.2.</strong> Running with Systemd</a></li></ol></li><li class="chapter-item expanded "><a href="Basics.html"><strong aria-hidden="true">4.</strong> Robot Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/ping.html"><strong aria-hidden="true">4.1.</strong> Addressing your Robot</a></li><li class="chapter-item expanded "><a href="basics/matching.html"><strong aria-hidden="true">4.2.</strong> Command Matching</a></li><li class="chapter-item expanded "><a href="basics/channels.html"><strong aria-hidden="true">4.3.</strong> Availability by Channel</a></li><li class="chapter-item expanded "><a href="basics/help.html"><strong aria-hidden="true">4.4.</strong> The built-in Help System</a></li><li class="chapter-item expanded "><a href="basics/stdplugins.html"><strong aria-hidden="true">4.5.</strong> Standard Commands</a></li><li class="chapter-item expanded "><a href="basics/context.html"><strong aria-hidden="true">4.6.</strong> Context</a></li></ol></li><li class="chapter-item expanded "><a href="Admin.html"><strong aria-hidden="true">5.</strong> Managing Your Robot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/update.html"><strong aria-hidden="true">5.1.</strong> Updating from Git</a></li><li class="chapter-item expanded "><a href="extensiondev/devenv.html"><strong aria-hidden="true">5.2.</strong> Container Dev Environment</a></li><li class="chapter-item expanded "><a href="extensiondev/local.html"><strong aria-hidden="true">5.3.</strong> Local Install Dev Environment</a></li><li class="chapter-item expanded "><a href="extensiondev/CLI.html"><strong aria-hidden="true">5.4.</strong> CLI Operation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extensiondev/secrets.html"><strong aria-hidden="true">5.4.1.</strong> Encrypting Secrets</a></li></ol></li><li class="chapter-item expanded "><a href="extensiondev/terminal.html"><strong aria-hidden="true">5.5.</strong> Using the Terminal Connector</a></li><li class="chapter-item expanded "><a href="usage/admin.html"><strong aria-hidden="true">5.6.</strong> Administrator Commands</a></li><li class="chapter-item expanded "><a href="usage/logging.html"><strong aria-hidden="true">5.7.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Part II - Developing Extensions</li><li class="chapter-item expanded "><a href="customizing.html"><strong aria-hidden="true">6.</strong> Writing Custom Extensions for Your Robot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="customizing/style.html"><strong aria-hidden="true">6.1.</strong> Style Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="customizing/syntax-help.html"><strong aria-hidden="true">6.1.1.</strong> Help for Invalid Command Syntax</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Part III - Reference</li><li class="chapter-item expanded "><a href="Configuration.html"><strong aria-hidden="true">7.</strong> Gopherbot Configuration Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Environment-Variables.html"><strong aria-hidden="true">7.1.</strong> Environment Variables</a></li><li class="chapter-item expanded "><a href="config/file.html"><strong aria-hidden="true">7.2.</strong> Configuration File Loading</a></li><li class="chapter-item expanded "><a href="config/job-plug.html"><strong aria-hidden="true">7.3.</strong> Job and Plugin Configuration</a></li><li class="chapter-item expanded "><a href="config/troubleshooting.html"><strong aria-hidden="true">7.4.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="pipelines/jobspipes.html"><strong aria-hidden="true">8.</strong> Pipelines, Plugins, Jobs and Tasks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pipelines/primary.html"><strong aria-hidden="true">8.1.</strong> The Primary Pipeline</a></li><li class="chapter-item expanded "><a href="pipelines/final.html"><strong aria-hidden="true">8.2.</strong> The Final Pipeline</a></li><li class="chapter-item expanded "><a href="pipelines/fail.html"><strong aria-hidden="true">8.3.</strong> The Fail Pipeline</a></li><li class="chapter-item expanded "><a href="pipelines/TaskEnvironment.html"><strong aria-hidden="true">8.4.</strong> Task Environment Variables</a></li><li class="chapter-item expanded "><a href="pipelines/tasks.html"><strong aria-hidden="true">8.5.</strong> All Included Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="pipelines/integrations.html"><strong aria-hidden="true">9.</strong> Gopherbot Tool Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pipelines/ssh.html"><strong aria-hidden="true">9.1.</strong> Integrating with SSH</a></li></ol></li><li class="chapter-item expanded "><a href="api/API-Introduction.html"><strong aria-hidden="true">10.</strong> Gopherbot Scripting API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/Languages.html"><strong aria-hidden="true">10.1.</strong> Language Templates</a></li><li class="chapter-item expanded "><a href="api/Attribute-Retrieval-API.html"><strong aria-hidden="true">10.2.</strong> Attribute Retrieval</a></li><li class="chapter-item expanded "><a href="api/Brain-API.html"><strong aria-hidden="true">10.3.</strong> Brain Methods</a></li><li class="chapter-item expanded "><a href="api/Message-Sending-API.html"><strong aria-hidden="true">10.4.</strong> Message Sending</a></li><li class="chapter-item expanded "><a href="api/Pipeline-API.html"><strong aria-hidden="true">10.5.</strong> Pipeline Construction</a></li><li class="chapter-item expanded "><a href="api/Response-Request-API.html"><strong aria-hidden="true">10.6.</strong> Requesting Responses</a></li><li class="chapter-item expanded "><a href="api/Utility-API.html"><strong aria-hidden="true">10.7.</strong> Utility</a></li></ol></li><li class="chapter-item expanded "><a href="appendices/Appendix.html"><strong aria-hidden="true">11.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendices/InstallArchive.html"><strong aria-hidden="true">11.1.</strong> A - Gopherbot Install Archive</a></li><li class="chapter-item expanded "><a href="appendices/Protocols.html"><strong aria-hidden="true">11.2.</strong> B - Protocols</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendices/slack.html"><strong aria-hidden="true">11.2.1.</strong> B.1 - Slack</a></li><li class="chapter-item expanded "><a href="appendices/rocket.html"><strong aria-hidden="true">11.2.2.</strong> B.2 - Rocket.Chat</a></li><li class="chapter-item expanded "><a href="appendices/terminal.html"><strong aria-hidden="true">11.2.3.</strong> B.3 - Terminal</a></li><li class="chapter-item expanded "><a href="appendices/testproto.html"><strong aria-hidden="true">11.2.4.</strong> B.4 - Test</a></li><li class="chapter-item expanded "><a href="appendices/nullconn.html"><strong aria-hidden="true">11.2.5.</strong> B.5 - Nullconn</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Contributing to Gopherbot Development</li><li class="chapter-item expanded "><a href="GopherDev.html"><strong aria-hidden="true">12.</strong> Working on Gopherbot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="botdev/DevelRobot.html"><strong aria-hidden="true">12.1.</strong> Development Robot</a></li><li class="chapter-item expanded "><a href="botdev/IntegrationTests.html"><strong aria-hidden="true">12.2.</strong> Integration Tests</a></li><li class="chapter-item expanded "><a href="botdev/StructsInterfaces.html"><strong aria-hidden="true">12.3.</strong> Important Structs and Interfaces</a></li><li class="chapter-item expanded "><a href="botdev/protocols.html"><strong aria-hidden="true">12.4.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="botdev/releases.html"><strong aria-hidden="true">12.5.</strong> Releases</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gopherbot DevOps Chatbot</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gopherbotdevops-chatbot"><a class="header" href="#gopherbotdevops-chatbot">Gopherbot</br>DevOps Chatbot</a></h1>
<p><img src="gopherbot.png" alt="Gophers+bot by Renee French, cropped, cc3.0" /></p>
<p>By David Parsley, <a href="mailto:parsley@linuxjedi.org">parsley@linuxjedi.org</a></p>
<p>Gophers + Robot by Renee French (cropped) licensed under <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons License 3.0</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="status-of-the-gopherbot-software"><a class="header" href="#status-of-the-gopherbot-software">Status of the Gopherbot Software</a></h1>
<p>The project as a whole is going on 7 years old, and the core v1 functionality is fairly robust. On the other hand, some of the original plugins (like duo two factor) have suffered from bit-rot and may not function correctly; good news, though - the &quot;knock knock joke&quot; plugin definitely works.</p>
<p>The new job, task, pipeline and cron functionality for v2 is pretty heavily used and I have a good deal of confidence in it. The CI/CD functionality is unmaintained and not very functional. Similarly, the logging functionality and commands are not 100%.</p>
<p>I'm a little sorry that the only currently supported team chat connector is <strong>Slack</strong>, because that's what my team uses. This is definitely a &quot;scratching my own itch&quot; kind of project, and it's hard to motivate myself to write connectors for protocols I don't use. I'd be happy to work with others on this, however.</p>
<h1 id="status-of-this-manual"><a class="header" href="#status-of-this-manual">Status of this Manual</a></h1>
<p><strong>December '22 / January '23 - The manual is being actively revised for the new Gopherbot IDE.</strong></p>
<p>This manual is a work in progress; currently incomplete and partly outdated. This section will be removed when the manual is considered complete. For now, to help you make the most of the manual, this is the current state of the different sections:</p>
<h2 id="front-matter"><a class="header" href="#front-matter">Front Matter</a></h2>
<p>The foreword, introduction and terminology pages should be up to date.</p>
<h2 id="build-and-installation"><a class="header" href="#build-and-installation">Build and Installation</a></h2>
<p>These sections are frequently updated to track with current development.</p>
<h2 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h2>
<p>The section on environment variables is updated fairly often, as well as the section on configuration file loading. The sections dealing with actual contents of configuration files was woefully outdated and need to be replaced. The best place to look for examples of legal configuration is the defaults in <code>conf/</code>.</p>
<h2 id="extension-development-and-apis"><a class="header" href="#extension-development-and-apis">Extension Development and APIs</a></h2>
<p>These sections fairly out of date and in need of TLC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>My work with ChatOps began with Hubot around 2012 when I was working as an systems engineer for a small hosting provider. The owner had sent me a link to Hubot, asking me to have a look. I took to the concept immediately, and started automating all kinds of tasks that our support team could easily access from our team chat. Soon they were using our robot to troubleshoot email routing and DNS issues, migrate mailboxes, and build new cPanel server instances.</p>
<p>Not being a very talented (or motivated) Javascript/NodeJS programmer, my Hubot commands invariably followed the same pattern: write it in Javascript if it was <em>trivially</em> easy  to do so, otherwise shell out to bash and return the results. This was productive and gave results, but it was ugly and limited in functionality.</p>
<p>When I began teaching myself Go, I needed a good project to learn with. After my experience with Hubot, I decided to write a robot that was more approachable for Systems and DevOps engineers like myself - tasked with providing functionality most easily accessible from e.g. bash or python scripts. Towards that end, Gopherbot's design:</p>
<ul>
<li>Is CGI-like in operation: the compiled server process spawns scripts which can then use a simple API for interacting with the user / chat service</li>
<li>Supports any number of scripting languages by using a simple json-over-http localhost interface</li>
<li>Uses a multi-process design with method calls that block</li>
</ul>
<p>Ultimately, Gopherbot gives me a strong alternative to writing Yet Another Web Application to deliver some kind of reporting, security, or management functionality to managers and technical users. It's a good meet-in-the-middle solution that's nearly as easy to use as a web application, with some added benefits:</p>
<ul>
<li>The chat application gives you a single pane of glass for access to a wide range of functionality</li>
<li>The shared-view nature of channels gives an added measure of security thanks to visibility, and also a simple means of training users to interact with a given application</li>
<li>Like a CGI, applications can focus on functionality, with security and access control being configured in the server process</li>
</ul>
<p>It is my hope that this design will appeal to other engineers like myself, and that somewhere, somebody will exclaim &quot;Wait, what? I can write chat bot plugins <em><strong>in BASH</strong></em>?!?&quot;</p>
<p>David Parsley, March 2017 / September 2019</p>
<pre><code class="language-bash">#!/bin/bash

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z &quot;$GOPHER_INSTALLDIR&quot; ] &amp;&amp; { echo &quot;GOPHER_INSTALLDIR not set&quot; &gt;&amp;2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat &lt;&lt;&quot;EOF&quot;
---
Help:
- Keywords: [ &quot;repeat&quot; ]
  Helptext: [ &quot;(bot), repeat (me) - prompt for and trivially repeat a phrase&quot; ]
CommandMatchers:
- Command: &quot;repeat&quot;
  Regex: '(?i:repeat( me)?)'
EOF
}

case &quot;$command&quot; in
# NOTE: only &quot;configure&quot; should print anything to stdout
	&quot;configure&quot;)
		configure
		;;
	&quot;repeat&quot;)
		REPEAT=$(PromptForReply SimpleString &quot;What do you want me to repeat?&quot;)
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply &quot;Sorry, I had a problem getting your reply: $RETVAL&quot;
		else
			Reply &quot;$REPEAT&quot;
		fi
		;;
esac
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Gopherbot</strong> DevOps Chatbot is a tool for teams of developers, operators, infrastructure engineers and support personnel - primarily for those that are already using Slack or another team chat platform for day-to-day communication. It belongs to and integrates well with a larger family of tools including <em>Ansible</em>, <em>git</em> and <em>ssh</em>, and is able to perform many tasks similar to <em>Jenkins</em> or <em>TravisCI</em>; all of this functionality is made available to your team via the chat platform you're already using.</p>
<p>To help give you an idea of the kinds of tasks you can accomplish, here are a few of the things my teams have done with <strong>Gopherbot</strong> over the years:</p>
<ul>
<li>Generating and destroying <a href="https://aws.amazon.com">AWS</a> instances on demand</li>
<li>Running software build, test and deploy pipelines, triggered by git service integration with team chat</li>
<li>Updating service status on the department website</li>
<li>Allowing support personnel to search and query user attributes</li>
<li>Running scheduled backups to gather artifacts over <code>ssh</code> and publish them to an artifact service</li>
<li>Occasionally - generating silly memes</li>
</ul>
<p>The primary strengths of <strong>Gopherbot</strong> stem from its simplicity and flexibility. It installs and bootstraps readily on a VM or in a container with just a few environment variables, and can be run behind a firewall where it can perform tasks like rebooting server hardware over IPMI. Simple command plugins can be written in <code>bash</code>, <code>python</code> or <code>ruby</code>, with easy to use encrypted secrets for accomplishing privileged tasks. Like any user, the robot can also have its own (encrypted, naturally) ssh key for performing remote work and interfacing with <em>git</em> services.</p>
<p>The philosophy underlying <strong>Gopherbot</strong> is the idea of solving the most problems with the smallest set of general purpose tools, accomplishing a wide variety of tasks reasonably well. The interface is much closer to a CLI then a Web GUI, but it's remarkable what can be accomplished with a shared CLI for your team's infrastructure.</p>
<p>The major design goals for <strong>Gopherbot</strong> are reliability and portability, leaning heavily on &quot;configuration as code&quot;. Ideally, custom add-on plugins and jobs that work for a robot instance in <a href="https://slack.com">Slack</a> should work just as well if your team moves, say, to <a href="https://rocket.chat">Rocket.Chat</a>. This goal ends up being a trade-off with supporting specialized features of a given platform, though the <strong>Gopherbot</strong> API enables platform-specific customizations if desired.</p>
<p>Secondary but important design goals are configurability and security. Individual commands can be constrained to a subset of channels and/or users, require external authorization or elevation plugins, and administrators can customize help and command matching patterns for stock plugins. <strong>Gopherbot</strong> has been built with security considerations in mind from the start; employing strong encryption, privilege separation, and a host of other measures to make your robot a difficult target for potential attackers.</p>
<p>Version 2 for the most part assumes that your robot will employ encryption and get its configuration from a <em>git</em> repository. Other deployments are possible, but not well documented. This manual will focus on working with <strong>Gopherbot</strong> instances whose configuration is stored on <a href="https://github.com">GitHub</a>, but other <em>git</em> services are easy to use, as well.</p>
<p>That's it for the &quot;marketing&quot; portion of this manual - by now you should have an idea whether <strong>Gopherbot</strong> would be a good addition to your DevOps tool set.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p>This section is most important for referring back to as you read the documentation, to disambiguate terms.</p>
<p>(It's also for the author, to help maintain some consistency)</p>
<ul>
<li><strong>Gopherbot</strong> - The installed software archive that comprises the core <strong>Gopherbot DevOps Chatbot</strong> service daemon and included extensions</li>
<li><strong>robot</strong> - you'll see the term <em>robot</em> in several different contexts in the documentation with these several meanings:
<ul>
<li><strong>robot</strong> - Far and away the most common use - a configured instance of a running <strong>Gopherbot</strong> daemon, available in your team chat; normally associated with a <em>git</em> repository that holds all the configuration and extensions for the robot (normally in the context of <em>your robot</em>)</li>
<li><strong>Robot</strong> - The Go object passed to user plugins, jobs and tasks</li>
<li><strong>robot</strong> - the <strong>Go</strong> library for loadable modules, i.e. <code>import github.com/lnxjedi/robot</code></li>
</ul>
</li>
<li><strong>default (or base) robot</strong> - If you run Gopherbot with no custom configuration, you get <em>Floyd</em>, the default robot; this configuration is typically found under /opt/gopherbot, and defines how a robot behaves in the absence of other configuration, and the configuration of your specific robot is merged with the base robot</li>
<li><strong>standard robot</strong> - A standard robot is what you get from using <code>robot.skel</code> or running the <code>autosetup</code> plugin from the <strong>default robot</strong>; more generally, any robot that has the standard <code>robot.skel</code> configuration as its base is still a <strong>standard robot</strong></li>
<li><strong>GOPHER_HOME</strong> - The top-level directory for a given robot's repository; the <strong>Gopherbot</strong> binary (<code>/opt/gopherbot/gopherbot</code>) is run from this directory to start or interact with the robot</li>
<li><strong>bootstrapping</strong> - When you start the <code>gopherbot</code> daemon in a container or host with a few environment variables, or in an empty directory with a suitable <code>.env</code> environment file, the <strong>bootstrap</strong> plugin included with the <strong>default robot</strong> will use a deploy key to clone your robot from a <em>git</em> repository and start it up; this process is called <strong>bootstrapping</strong> your robot, allows deploying your robot to new environments quickly, and supports the devops mantras of disposable environments / infrastructure-as-code</li>
<li><strong>plugin</strong> (or <strong>command plugin</strong>) - A piece of code that provides new interactive commands; plugins may also provide code for authorization and/or elevation, which may also interact with users</li>
<li><strong>authorizer</strong> - special plugin command used to determine whether a given user is authorized for a given command, normally checking some kind of group membership</li>
<li><strong>elevator</strong> - special plugin command providing additional verification of user identity; this can be as simple as a totp token or <a href="https://duo.com">Duo</a> two-factor, or as complex as prompting another user before allowing a command to proceed</li>
<li><strong>job</strong> - jobs are pieces of code that typically use the pipeline API for creating pipelines to perform complex scheduled tasks such as backups and monitoring, or for software builds that may be triggered by detected updates to git repositories; see the chapter on <a href="pipelines/jobspipes.html">jobs and pipelines</a></li>
<li><strong>task</strong> - tasks are small pieces of code that generally form the parts of a pipeline, such as initializing (and tearing down) the <code>ssh-agent</code>, running pipeline scripts, or sending notifications; the task is also the base object for jobs and plugins, so &quot;task&quot; may refer to any entry in <code>ExternalPlugins</code>, <code>ExternalTasks</code>, <code>ExternalJobs</code>, etc.</li>
<li><strong>parameter</strong> - a name/value setting configurable for tasks, plugins, jobs and repositories, presented to external scripts as environment variables</li>
</ul>
<p>In addition, this manual may periodically reference four important robots:</p>
<ul>
<li><strong>Floyd</strong> - Floyd is a production robot in the <code>linuxjedi</code> Slack team, currently running on a <code>t2.nano</code> in AWS. Floyd was formerly responsible for building, testing and publishing the <strong>Gopherbot</strong> artifacts, but is now relegated to looking up recipes and telling jokes. The name is taken from Infocom's <strong>Planetfall</strong>, circa 1983. Also, as above, the <strong>Gopherbot</strong> default robot is named <em>Floyd</em>, but every other mention of <strong>Floyd</strong> refers to my production robot, whose repository can always be found <a href="https://github.com/parsley42/floyd-gopherbot">on Github</a>.</li>
<li><strong>Data</strong> - Data was a production robot in my home Kubernetes cluster (both now retired), responsible for building and publishing <strong>Gopherbot</strong> containers and documentation, and is probably the best publicly-available example of a production robot. You can find his configuration <a href="https://github.com/parsley42/data-gopherbot">on Github</a>. The name is taken from Star Trek TNG.</li>
<li><strong>Clu</strong> - Clu is &quot;the best program that's ever been written ... dogged and relentless&quot;; also, the development robot that changes frequently as I develop <strong>Gopherbot</strong>. Clu runs on workstations, chromebooks, containers, or wherever I happen to be doing development. If you've seen <strong>Tron: Legacy</strong> - it's not <strong>THAT</strong> Clu, but rather the short-lived <strong>Clu</strong> from the original <strong>TRON</strong>, circa 1982. <strong>Clu's</strong> repository is also always available <a href="https://github.com/parsley42/clu-gopherbot">on Github</a>, and generally has a pretty up-to-date README (not so much Floyd).</li>
<li><strong>Bishop</strong> - Bishop is used mainly for writing this documentation, and has his configuration repository wiped periodically when I test the <code>autosetup</code> plugin. You'll see lots of Bishop in the sections on managing your own robot. The repository may or may not be available at any given moment, and even if it is, it won't be very exciting. His name comes from <strong>Aliens</strong>, the <strong>Alien</strong> sequel, circa 1986.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gopherbot-ide"><a class="header" href="#the-gopherbot-ide">The Gopherbot IDE</a></h1>
<p>Starting with version 2.6, the <strong>Gopherbot</strong> CI/CD pipelines are configured to create a pre-built development container with a daily snapshot of the most current code. This container is very large, &gt;2G, but the base is built weekly to pick up the latest security updates, and includes the following bundled software:</p>
<ul>
<li>A Debian base image with Ruby and Python3 (and other requirements)</li>
<li>The most recent release of <a href="https://go.dev/dl">Go</a></li>
<li>The most recent release of <a href="https://github.com/gitpod-io/openvscode-server">OpenVSCode Server</a></li>
<li>Pre-installed OpenVSCode language extensions for python, ruby and Go, including required modules</li>
</ul>
<blockquote>
<p>While using the IDE isn't strictly necessary, all documentation will be written using it, as well as all future releases of <strong>Gopherbot</strong>.</p>
</blockquote>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To work with the <strong>Gopherbot IDE</strong>, you'll need one of:</p>
<ul>
<li>A Linux host with docker installed (note that Podman may work but is untested)</li>
<li>A MacOS host with <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> installled</li>
<li>A Windows host with the Windows Subsystem for Linux (WSL/WSL2) installed, and docker installed there</li>
</ul>
<blockquote>
<p>Note that the common theme here is <code>docker</code> and <code>bash</code> - the primary script for managing the Gopherbot IDE (<code>cbot.sh</code>) is written in <strong>bash</strong>.</p>
</blockquote>
<p>The Gopherbot IDE is created primarily for use with <strong>ssh</strong> git credentials, though it also includes the <code>gh</code>. Within your host environment, you'll also need an ssh keypair configured for pushing to your robot's repository with <strong>git</strong>.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<blockquote>
<p>This section will describe setting up a simple directory called <code>botwork</code> for working with you robot(s); feel free to adjust specific paths and commands according to your preferences and comfort with the command line.</p>
</blockquote>
<ol>
<li>Open a terminal window in one of the required environments, then create a new <code>botwork</code> directory and change to that directory:</li>
</ol>
<pre><code class="language-shell">~$ mkdir botwork
~$ cd botwork/
~/botwork$
</code></pre>
<ol start="2">
<li>Download the latest <code>cbot.sh</code> script, mark it executable, then run it without any arguments for help/usage:</li>
</ol>
<pre><code class="language-shell">$ curl -o cbot.sh https://raw.githubusercontent.com/lnxjedi/gopherbot/main/cbot.sh
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  4787  100  4787    0     0  13599      0 --:--:-- --:--:-- --:--:-- 13560
~/botwork$ chmod +x cbot.sh
~/botwork$ ./cbot.sh
Usage: ./botc.sh profile|dev|start|stop|remove (options...) (arguments...)
...
</code></pre>
<ol start="3">
<li>Generate a new profile for working on your robot; replace <code>dolores</code> in the example with the name you'll give your robot:</li>
</ol>
<pre><code class="language-shell">$ ./cbot.sh profile -k ~/.ssh/id_rsa dolores &quot;David Parsley&quot; parsley@linuxjedi.org | tee dolores.env
## Lines starting with #| are used by the cbot.sh script
GIT_AUTHOR_NAME=&quot;David Parsley&quot;
GIT_AUTHOR_EMAIL=parsley@linuxjedi.org
GIT_COMMITTER_NAME=&quot;David Parsley&quot;
GIT_COMMITTER_EMAIL=parsley@linuxjedi.org
#|CONTAINERNAME=dolores
#|SSH_KEY_PATH=/home/david/.ssh/id_rsa
</code></pre>
<blockquote>
<p>Note that in the example we supplied the path to a standard encrypted private key; this could also be a deployment key, or left out altogether if other authentication means are used. Due to the inherent security of encrypted ssh keys and ssh-agent, this manual will use ssh for all examples.</p>
</blockquote>
<ol start="4">
<li>Start a development container:</li>
</ol>
<pre><code class="language-shell">$ ./cbot.sh dev dolores.env
Starting 'dolores':
dolores
Copying /home/david/.ssh/id_rsa to dolores:/home/bot/.ssh/id_ssh ...
Access your dev environment at: http://localhost:7777/?workspace=/home/bot/gopherbot.code-workspace&amp;tkn=XXXX
</code></pre>
<ol start="5">
<li>Connect to the IDE
Copy the URL provided and paste it in to your browser; note that VSCode server operates best in a separate browser tab running full-screen.</li>
</ol>
<p>That's it! You're ready to start setting up a new robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p>There are three distinct tasks involved in installing and running a <strong>Gopherbot</strong> robot:</p>
<ol>
<li>The first section discusses installing the <strong>Gopherbot</strong> distribution archive, normally in <code>/opt/gopherbot</code>; this provides the <code>gopherbot</code> binary, default configuration, and an assortment of included batteries (libraries, plugins, jobs, tasks, helper scripts and more); if you're using a <a href="https://github.com/orgs/lnxjedi/packages">Gopherbot container</a>, installation is essentially a no-op.</li>
<li>Configuring a runnable instance of a robot for your team; the included <strong>autosetup</strong> plugin should make this an &quot;easy button&quot; - discussed in the chapter on <a href="RobotInstall.html">Initial Configuration</a>.</li>
<li>Deploying and running your robot on a server, VM, or in a container - covered in the chapter on <a href="RunRobot.html">Running your Robot</a>.</li>
</ol>
<h2 id="gopherbot-and-robots"><a class="header" href="#gopherbot-and-robots"><strong>Gopherbot</strong> and <em>Robots</em></a></h2>
<p>It's helpful to understand the relationship between <strong>Gopherbot</strong> and individual robots you run. It's apt to compare Gopherbot with <em>Ansible</em>:</p>
<ul>
<li><em>Gopherbot</em> is similar to <em>Ansible</em> - a common code base with an assortment of included batteries, but with limited functionality on it's own; several <strong>Go</strong> tasks and plugins are part of the compiled binary, but the bulk of the base robot configuration is stored in <strong>yaml</strong> and script files under <code>/opt/gopherbot</code></li>
<li>A <em>Robot</em> is comparable to a collection of playbooks and/or roles - this is your code for accomplishing work in your environment, which uses <em>Gopherbot</em> and it's included extensions to do it's work; in the case of <strong>yaml</strong> configuration files your robot configuration is merged with the base, while jobs and plugins can be overridden by providing replacements in your robot's repository</li>
</ul>
<p>Similar to Ansible playbooks and roles, individual robots may periodically require updates as you upgrade the <strong>Gopherbot</strong> core.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p>If you plan on running your <strong>Gopherbot</strong> robot in a container, you can skip ahead to <a href="install//botsetup/credentials.html">Team Chat Credentials</a>. For reference, it might be useful to peruse the contents of the <a href="install//appendices/InstallArchive.html">Gopherbot install archive</a> describing what gets installed.</p>
<p>Note that Gopherbot is currently Linux-only. Earlier versions ran on MacOS - and even Windows - but these platforms have fallen out of use. Patches are welcome if you'd like to maintain one of these platforms, and I'd be happy to provide advice and assistance. If you have a Mac with Docker installed or Windows with WSL and Docker, you can still use the <code>cbot.sh</code> bash script for setting up and running a container-based robot on your Mac or Windows machine.</p>
<p>The rest of this section assumes you'll be installing <strong>Gopherbot</strong> from a pre-built archive or source on a Linux host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p>Since <strong>Gopherbot</strong> is primarily a <em>Go</em> daemon that utilizes external tools and scripts to perform most of the real work, you'll probably want to have most of the (common) listed dependencies. Note that if you deploy your robot in a container, these are included in the base container, which you can further customize by adding your own tools.</p>
<ul>
<li><code>git</code> - with version 2, <strong>Gopherbot</strong> is tightly integrated with git for updating configuration and keeping state; <strong>Gopherbot</strong> requires fairly recent versions of <em>git</em> supporting <code>git remote get-url ...</code>
<ul>
<li>Note that the version of <em>git</em> in CentOS 7 is not supported, see the <a href="https://ius.io/">Inline with Upstream Stable</a> site for a newer version</li>
</ul>
</li>
<li><code>ssh</code> - robots configured from this manual require <em>ssh</em> for setup and deployment; additionally, most robots should have an encrypted private key / public key pair for performing <em>git</em> operations and running remote jobs</li>
<li><code>bash</code> - the majority of the <em>batteries included</em> scripts included with <strong>Gopherbot</strong> are written in good 'ol <strong>Bash</strong>; this is nearly universal but listed here for those that may wish to build containers from scratch, since many base containers have much less functional <code>/bin/sh</code> shells. (busybox for example)</li>
<li><code>jq</code> - required by the <code>gopherbot/lib/gopherbot_v1.sh</code> <strong>bash</strong> library for parsing the <strong>JSON</strong> responses from the robot
<ul>
<li>Note this is available from the <a href="https://fedoraproject.org/wiki/EPEL">EPEL</a> repositories for CentOS 7</li>
</ul>
</li>
<li><code>python</code> - (version 3) next to <code>bash</code>, the second most common language for extensions is <strong>python</strong> version 3, which includes several management jobs</li>
</ul>
<p><strong>Optional</strong></p>
<ul>
<li><code>ruby</code> - Ruby isn't heavily used with the default extensions, but is a supported language and included in the pre-built containers</li>
<li><code>go</code> - While Gopherbot is written in <em>Go</em>, writing plugins in Go is considered an advanced topic and not well covered in this manual</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-gopherbot-on-linux"><a class="header" href="#installing-gopherbot-on-linux">Installing <strong>Gopherbot</strong> on Linux</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p>If you want to run <strong>Gopherbot</strong> directly on a Linux host / VM, you can <a href="https://github.com/lnxjedi/gopherbot/releases">download a release</a> and skip down to <a href="install/ManualInstall.html#installing-the-archive">installing the archive</a>.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<p><strong>Requirements:</strong></p>
<ul>
<li>A recent (1.18+) version of Go</li>
<li>Standard build utilities; make, tar, gzip</li>
<li>A Linux system to build on that matches your target deployment host</li>
</ul>
<p><strong>Steps:</strong></p>
<ol>
<li>Clone the <strong>Gopherbot</strong> repository: <code>git clone https://github.com/lnxjedi/gopherbot.git</code></li>
<li><code>make dist</code> in the repository root; this will compile the binary and create the <code>gopherbot-linux-amd64.tar.gz</code> archive</li>
</ol>
<h2 id="installing-the-archive"><a class="header" href="#installing-the-archive">Installing the Archive</a></h2>
<ol>
<li>Extract the downloaded or built archive in <code>/opt</code> to create <code>/opt/gopherbot</code>, e.g.:</li>
</ol>
<pre><code class="language-shell">[root]# cd /opt
[opt]# tar xzvf /path/to/gopherbot/gopherbot-linux-amd64.tar.gz
</code></pre>
<ol start="2">
<li>(Optional) Also as root, make the <code>gopherbot</code> binary <strong>setuid nobody</strong> (see <a href="install/ManualInstall.html#privilege-separation">below</a>):</li>
</ol>
<pre><code class="language-shell">[opt]# cd gopherbot
[gopherbot]# ./setuid-nobody.sh
</code></pre>
<h2 id="creating-symlinks-to-executables"><a class="header" href="#creating-symlinks-to-executables">Creating Symlinks to Executables</a></h2>
<p>The trivial <code>gb-install-links</code> script will create a set of symlinks to executables. For instance, if <code>$HOME/bin</code> is in your <code>$PATH</code>, you could:</p>
<pre><code class="language-shell">$ /opt/gopherbot/gb-install-links $HOME/bin
</code></pre>
<blockquote>
<p>See <a href="install//appendices/InstallArchive.html">Appendix A</a> for a description of the contents of the installation archive.</p>
</blockquote>
<h1 id="privilege-separation"><a class="header" href="#privilege-separation">Privilege Separation</a></h1>
<p><strong>Gopherbot</strong> need never run as root; all of it's privileges derive from the collection of encrypted secrets that a given robot collects. However, given that chat bots may use 3rd-party command plugins, <strong>Gopherbot</strong> can be installed <em>setuid nobody</em>. This will cause the robot to run with a <code>umask</code> of <code>0022</code>, and external plugins will run by default as real/effective user <code>nobody</code>. Since <strong>Gopherbot</strong> child processes do not inherit environment from the parent daemon, this effectively prevents any potential access to the <code>GOPHER_ENCRYPTION_KEY</code>, and any ability to modify the robot's running environment.</p>
<blockquote>
<p><strong>NOTE!</strong> Be wary of a false sense of security! The process still retains it's primary GID and supplementary groups, so if e.g. your robot unix user belongs to the <code>wheel</code> group, external scripts running as <code>nobody</code> will still be able to <code>sudo</code>. Privilege separation is just a simple means of providing additional hardening for your robot's execution environment.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="team-chat-credentials"><a class="header" href="#team-chat-credentials">Team Chat Credentials</a></h1>
<p>Step zero for setting up a new robot is obtaining credentials to use with your team chat platform. This sections details the steps in obtaining these credentials for the only currently supported platform - Slack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slack-socket-mode"><a class="header" href="#slack-socket-mode">Slack Socket Mode</a></h1>
<p>Starting with v2.5.0, <strong>Gopherbot</strong> uses the Slack <a href="https://api.slack.com/apis/connections/socket">socket mode</a> <a href="https://api.slack.com/apis/connections/events-api">EventsAPI</a> for bot credentials, which is more fine-grained and complicated.</p>
<h2 id="generating-a-slack-app-manifest"><a class="header" href="#generating-a-slack-app-manifest">Generating a Slack App Manifest</a></h2>
<p>To save a LOT of time, we'll use a Slack <a href="https://api.slack.com/reference/manifests">app manifest</a> to configure the settings for your app. You'll need to customize your own <strong>yaml</strong> file in a text editor. You can start with a copy of <strong>Clu's</strong> template from in the <a href="https://raw.githubusercontent.com/lnxjedi/gopherbot/main/resources/slack/appmanifest.yaml">Gopherbot source</a>, or copy and paste from here:</p>
<pre><code class="language-yaml"># See: https://api.slack.com/reference/manifests
_metadata:
  major_version: 1
  minor_version: 1
display_information:
  name: Clu Gopherbot
  description: Clu tries all the new, dangerous and/or breaking changes to Gopherbot.
features:
  app_home:
    home_tab_enabled: false
    messages_tab_enabled: true
    messages_tab_read_only_enabled: false
  bot_user:
    display_name: Clu Gopherbot
    always_online: false
  slash_commands:
    - command: /clu
      description: Provides an alternate means of messaging Clu
      should_escape: false
oauth_config:
  scopes:
    # See: https://api.slack.com/scopes
    bot:
      - app_mentions:read
      - channels:history
      - channels:join
      - channels:read
      - chat:write
      - chat:write.public
      - commands
      - groups:history
      - groups:read
      - groups:write
      - im:history
      - im:read
      - im:write
      - links:read
      - mpim:history
      - mpim:read
      - mpim:write
      - users.profile:read
      - users:read
      - users:read.email
      - users:write
settings:
  event_subscriptions:
    bot_events:
      - message.channels
      - message.groups
      - message.im
      - message.mpim
  interactivity:
    is_enabled: false
  org_deploy_enabled: false
  socket_mode_enabled: true
  is_hosted: false
</code></pre>
<p>You should change the display information and display name, and decide if you want your robot to respond to &quot;slash commands&quot;. Keep in mind:</p>
<ul>
<li>When a user sends a slash command, it doesn't echo to the channel; since one of the benefits of ChatOps is the ease of learning from other users by observation, you might lose some of this benefit (the robot will still respond to it's name, and also the 1-character <strong>alias</strong> that most users prefer)</li>
<li>Slack slash commands are available in <em>every</em> channel, even if the robot hasn't joined or been invited to the channel; individual plugins will still adhere to channel restrictions, but plugins configured with <code>AllChannels: true</code> (like <strong>ping</strong>) will respond everywhere</li>
</ul>
<h2 id="creating-a-new-slack-app"><a class="header" href="#creating-a-new-slack-app">Creating a New Slack App</a></h2>
<ol>
<li>Once you're logged in, visit the <a href="https://api.slack.com/apps">Slack apps</a> page, and click <strong>Create New App</strong></li>
<li>Select <strong>From an app manifest</strong>, choose your workspace, and click <strong>Next</strong></li>
<li>Paste in the full contents of the app manifest you created and click <strong>Next</strong></li>
<li>Review the settings, then click <strong>Create</strong> to create the Slack app for your robot</li>
<li>Note that the <strong>OAuth</strong> credentials shown aren't the credentials needed for <strong>Gopherbot</strong></li>
<li>Click <strong>Install to Workspace</strong> and select the workspace where you want to deploy your robot</li>
</ol>
<h2 id="obtaining-the-app-token-and-bot-token-for-your-app"><a class="header" href="#obtaining-the-app-token-and-bot-token-for-your-app">Obtaining the App Token and Bot Token for your App</a></h2>
<p>Now that you've created a Slack app for your robot, you'll need to generate and/or locate the credentials you'll need for configuration.</p>
<ol>
<li>From the app configuration view <strong>Basic Information</strong> page, scroll down to <strong>App-Level Tokens</strong> and click the <strong>Generate Token and Scopes</strong> button</li>
<li>Give the token a name, then add both the <strong>connections:write</strong> and <strong>authorizations:read</strong> scopes</li>
<li>Click <strong>Generate</strong>, then copy and save your app token (<code>xapp-*</code>) in a safe place for later</li>
<li>Select the <strong>Install App</strong> or <strong>OAuth &amp; Permissions</strong> section on the left, then copy and save your Bot User OAuth token (<code>xoxb-*</code>) in a safe place for later</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-a-new-robot"><a class="header" href="#configuring-a-new-robot">Configuring a New Robot</a></h1>
<p>This chapter discusses the process of setting up a new <strong>Gopherbot</strong> robot to connect to your team chat. Even if you use the <code>autosetup</code> plugin to create your new robot, you may want to read the section on manual installation for the technical detail it provides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-requirements"><a class="header" href="#environment-requirements">Environment Requirements</a></h1>
<blockquote>
<p>Up-to-date with v2.6; Nov. '21</p>
</blockquote>
<p>To set up your robot you'll need:</p>
<ul>
<li>Access to a Linux host with the <strong>Gopherbot</strong> software installed, or an environment where you can run and interact with the <a href="https://github.com/lnxjedi/gopherbot/pkgs/container/gopherbot-dev">official Gopherbot container image</a></li>
<li>The name of a channel where your robot will run jobs by default, e.g. <code>clu-jobs</code> or <code>data-jobs</code></li>
<li>A completely empty (no README, LICENSE, etc.) public or private <em>git</em> repository, to store your robot; a common naming convention is <em>botname</em>-gopherbot. For example, you can find <strong>Clu</strong> at <a href="https://github.com/parsley42/clu-gopherbot">https://github.com/parsley42/clu-gopherbot</a></li>
<li>If you're using a container and/or the <strong>autosetup plugin</strong>, you'll need to be able to configure read/write and read-only deploy keys for the robot's repository - this is widely supported with almost all of the major <em>git</em> hosting services and applications, check your repository settings or consult the documentation for your particular service (the Github documentation can be found <a href="https://docs.github.com/en/free-pro-team@latest/developers/overview/managing-deploy-keys#deploy-keys">here</a>)</li>
</ul>
<blockquote>
<p>Note on Deploy Keys: If you are unfamiliar with ssh deploy keys, you should take a few minutes to read your git provider's documentation. A standard <em>Gopherbot</em> robot uses two deploy keys which are dedicated for use with the robot's repository.</p>
</blockquote>
<p>The other requirements listed here are mainly items for consideration before setting up your <strong>Gopherbot</strong> robot.</p>
<h2 id="git-access"><a class="header" href="#git-access">Git Access</a></h2>
<p><strong>Gopherbot</strong> version 2 integrates heavily with <em>git</em>, using <em>ssh</em> keys for the authentication mechanism. This guide and the setup plugin require a <em>git</em> repository that your robot can push to it with it's encrypted management ssh key (<code>manage_key</code>), which will be set up as an encrypted read-write deployment key. In addition to saving it's initial configuration to this repository, the standard robot configured with this guide will back up it's long-term memories to a separate <code>robot-state</code> branch.</p>
<blockquote>
<p>Note: The standard robot configured with this guide will have THREE DIFFERENT SSH KEYPAIRS, with the following uses:</p>
<ul>
<li>A dedicated <strong>encrypted</strong> <code>manage_key</code>, configured as a read-write deploy key for the robot's git repository; the robot will use this for saving it's initial configuration and backing up it's long-term memories from the <code>state/</code> directory; it can also be used in the development lifecycle</li>
<li>An unencrypted, read-only <code>deploy_key</code> that can be used for deploying your robot to e.g. a container or new VM</li>
<li>A default encrypted <code>robot_key</code> which the robot will use for all other CI/CD and remote ssh jobs; this is the key that should be associated with a git user, or machine user</li>
</ul>
</blockquote>
<p>Additionally, you may want to take advantage of <strong>Gopherbot</strong>'s CI/CD funcationality or ability to run git-driven jobs, which can be scheduled and/or on-demand. It's worth considering how you'll set up your robot to access <em>git</em> repositories, whether to create a new machine/robot user, or to simply add your personal robot's key to your own ssh keys.</p>
<h3 id="machine-users"><a class="header" href="#machine-users">Machine Users</a></h3>
<p>If your robot will be doing a lot of <strong>git</strong> pushing and pulling, it's a good idea to create a machine account for your robot with the <em>git</em> service of your choice. Both <a href="https://github.com/floyd42">Floyd</a> and <a href="https://github.com/clu49">Clu</a> have machine accounts and belong to the <a href="https://github.com/lnxjedi">lnxjedi</a> organization on <a href="https://github.com">Github</a>, though <a href="https://github.com/parsley42/data-gopherbot">Data's</a> was just added to Floyd (since he took over his job, hah). Having an organization and adding robots to teams makes it easy to provide flexible read/write access to repositories without having to jump through repository collaborator hoops.</p>
<h3 id="deploy-keys"><a class="header" href="#deploy-keys">Deploy Keys</a></h3>
<p><em>Github</em>, at least, allows you to associate unique ssh deploy keys with a single repository, and even grant read-write access. The limitation of one repository per key pair increases administration overhead, and makes your robot's life more difficult. Though not fully documented here, it's possible to do this with <strong>Gopherbot</strong> by carefully managing the <code>KEYNAME</code> and <code>BOT_SSH_PHRASE</code> parameters (environment variables). See the section on <a href="botsetup/../pipelines/TaskEnvironment.html">task environment variables</a> for more information on parameter precedence.</p>
<p>The standard setup uses a read-write deploy key because it is the easiest means of configuring your robot initially, compatible with private repositories.</p>
<h3 id="user-ssh-keys"><a class="header" href="#user-ssh-keys">User SSH Keys</a></h3>
<p>Git services also allow you to add multiple ssh keys to an individual user. It's possible to add your robot's <code>robot_key.pub</code>, allowing your robot read-write access to all the repositories you have access to. This is the least recommended means of providing <em>git</em> repository write access for your robot, but may be the most expedient, and even fairly acceptable for private robots that only run on your workstation.</p>
<h2 id="brain-storage"><a class="header" href="#brain-storage">Brain Storage</a></h2>
<p><strong>Gopherbot</strong> supports the notion of long-term memories, which are technically just key-blob stores. The included <code>lists</code> and <code>links</code> plugins both use long-term memory storage.</p>
<h3 id="file-backed-brains"><a class="header" href="#file-backed-brains">File backed brains</a></h3>
<p>The standard configuration for a new robot uses the file-backed brain that's backed up to a <code>robot-state</code> branch in the robot's <em>git</em> repository, with memories stored in <code>$GOPHER_HOME/state/brain</code>. This brain works reasonably well for most robots.</p>
<blockquote>
<p>NOTE: If you write an extension that updates memories frequently, consider using memories with a <code>_</code> (<em>ephemeral memory</em>) prefix - this will automatically exclude the memory from being backed up to <em>git</em> (and thus spamming the robot's repository). If your robot has frequently updated memories that require permanent storage, the default git-backed brain probably shouldn't be used.</p>
</blockquote>
<h3 id="dynamodb-brains"><a class="header" href="#dynamodb-brains">DynamoDB brains</a></h3>
<p>If you need frequently-changing memories that are backed up, you should switch to the <strong>dynamo brain</strong>. As of this writing, the <a href="https://aws.amazon.com/">AWS</a> free tier provides a very generous 25GB of DynamoDB storage - far more than any reasonable robot should use. See the section on <a href="botsetup/TODO">configuring the DynamoDB brain</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-directory-structure"><a class="header" href="#robot-directory-structure">Robot Directory Structure</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p><strong>Gopherbot</strong> robots run in the context of a standard directory structure. The root of this directory structure is the <code>$HOME</code> for a given robot, and your robot starts by running the <em>gopherbot</em> binary in this directory. There are no requirements on this directory except that it needs to be owned and writable by the UID running the <em>gopherbot</em> binary; it should not be located under <code>/opt/gopherbot</code>, to avoid complicating upgrades. The <a href="https://github.com/orgs/lnxjedi/packages">stock containers</a> create a <code>bot</code> user and home directory in <code>/home/bot</code>, but the software was written to e.g. pass <code>-c &lt;filename&gt;</code> to <code>ssh</code> to allow multiple robots to run on a single system without <em>real</em> system users and home directories. In this kind of setup, the standard location is <code>/var/lib/robots/&lt;robotname&gt;</code>. You can always give your robot the <code>info</code> command to report on where it's running, and in what directory (<code>$GOPHER_HOME</code>):</p>
<pre><code>parsley - 10:02 AM:
*info

Mr. Data - 10:02 AM:
Here's some information about me and my running environment:
The hostname for the server I'm running on is: data-gopherbot-7878979b4-v7fsh
...
The gopherbot install directory is: /opt/gopherbot
My home directory ($GOPHER_HOME) is: /home/robot
My git repository is: git@github.com:parsley42/data-gopherbot.git
My software version is: Gopherbot v2, commit: 1a60a8e2
The administrators for this robot are: parsley
The administrative contact for this robot is: David Parsley, &lt;parsley@linuxjedi.org&gt;
</code></pre>
<p>Note that in the standard directory structure, much of the content is automatically generated when a robot first starts. Thanks to the <strong>bootstrap</strong> plugin in the default robot, a fully configured robot can be started with just a <code>.env</code> file in an empty directory. In the case of container-based robots, environment variables are provided by the container engine, and all content is generated during bootstrapping.</p>
<p>We'll use <a href="https://github.com/parsley42/clu-gopherbot">Clu</a> as example:</p>
<ul>
<li><code>clu/</code> - Top-level directory, <code>$GOPHER_HOME</code>; mostly empty of files and not containing a git repository (<code>.git/</code>)
<ul>
<li><code>.env</code> (optional, user provided) - file containing environment variables for the robot, including it's encryption key and git clone url; on start-up the permissions will be forced to <code>0600</code>, or start-up will fail - note that this file may be absent in containers, where the initial environment variables are provided by the container engine</li>
<li><code>gopherbot</code> (optional/generated) - convenience symlink to <code>/opt/gopherbot/gopherbot</code></li>
<li><code>known_hosts</code> (generated) - used by the robot to record the hosts it connects to over <em>ssh</em></li>
<li><code>robot.log</code> (generated) - log file created when the robot is run in <strong>terminal mode</strong></li>
<li><code>custom/</code> (bootstrapped) - git repository for your robot, containing custom configuration, plugins, jobs and tasks; this is populated during initial robot setup, or cloned during bootstrapping - for <em>Clu</em>, this is <a href="https://github.com/parsley42/clu-gopherbot">https://github.com/parsley42/clu-gopherbot</a></li>
<li><code>state/</code> (bootstrapped) - for the standard file-backed brain, <strong>state/</strong> contains the robot's encrypted memories in a <strong>state/brain/</strong> directory; this directory is normally linked to the <code>robot-state</code> branch of the robot's configuration repository - for <em>Clu</em> this is <a href="https://github.com/parsley42/clu-gopherbot/tree/robot-state">https://github.com/parsley42/clu-gopherbot/tree/robot-state</a></li>
<li><code>history/</code> (generated) - the standard robot keeps job / plugin logs here</li>
<li><code>workspace/</code> (generated) - default location for the robot's workspace, where repositories are cloned, etc.</li>
</ul>
</li>
</ul>
<p>Where:</p>
<ul>
<li><code>generated</code> items are created by the <strong>gopherbot</strong> binary when a robot first starts</li>
<li><code>bootstrapped</code> items are cloned from git during initial bootstrapping of a robot</li>
</ul>
<h2 id="the-custom-directory"><a class="header" href="#the-custom-directory">The <code>custom/</code> directory</a></h2>
<p>The <code>custom/</code> directory is essentially <em>your robot</em>, and corresponds to your robot's git repository. There's a good deal of flexibility in how the robot's custom directory is layed out, but there a few standardized locations:</p>
<ul>
<li><code>custom/</code> - Top-level directory for your robot's git repository
<ul>
<li><code>conf</code> (mandatory) - location of robot's <strong>yaml</strong> configuration files
<ul>
<li><code>robot.yaml</code> (mandatory) - primary configuration for your robot, defines all tasks, jobs, plugins, namespaces, parameter sets, and other bits</li>
<li><code>slack.yaml</code> - configuration for the slack connector, including encrypted credentials and user mapping</li>
<li><code>terminal.yaml</code> - configuration for the terminal connector; normally included users and channel definitions to mirror the contents of <code>slack.yaml</code> for use in developing extensions</li>
<li><code>jobs/</code> (mandatory) - directory of <code>&lt;job name&gt;.yaml</code> files with extended configuration for jobs defined in <code>robot.yaml</code></li>
<li><code>plugins/</code> (mandatory) - directory of <code>&lt;plugin name&gt;.yaml</code> files with extended configuration for plugins defined in <code>robot.yaml</code></li>
</ul>
</li>
<li><code>git/</code> (mandatory)
<ul>
<li><code>config</code> (mandatory) - contents of your robot's git config defining the name and email used for git operations</li>
</ul>
</li>
<li><code>jobs/</code> (conventional) - common location for job scripts, actual path specified in <code>robot.yaml</code></li>
<li><code>lib/</code> (standard) - location of script libraries; jobs and plugins run with standard environment variables for Ruby and Python so that <code>import</code> and <code>require</code> automatically look here</li>
<li><code>plugins/</code> (conventional) - common location for plugin scripts, actual path specified in <code>robot.yaml</code></li>
<li><code>ssh/</code> (mandatory) - location of robot's ssh configuration files
<ul>
<li><code>config</code> (optional) - any robot-specific ssh configuration, e.g. host-ip mappings</li>
<li><code>deploy_key.pub</code> (optional) - copy of the public key used for bootstrapping</li>
<li><code>manage_key</code> (optional) - encrypted private key used by the robot to save it's configuration; can be removed after initial configuration</li>
<li><code>manage_key.pub</code> (optional) - public key used as a read-write deploy key, allowing the private key to store the robot's initial configuration in git; can be removed</li>
<li><code>robot_key</code> (optional, default) - the robot's &quot;personal&quot; encrypted ssh key for other ssh / git operations</li>
<li><code>robot_key.pub</code> (optional, default) - the robot's public key corresponding to <code>robot_key</code>; the robot will respond to <code>show pubkey</code> (or just <code>pubkey</code>) with the contents of this file</li>
</ul>
</li>
<li><code>tasks/</code> (conventional) - common location for simple task scripts, actual path specified in <code>robot.yaml</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>Note that many of these directories are also under <code>/opt/gopherbot</code>, and make up the configuration of the default (or base) robot.</p>
</blockquote>
<h3 id="during-development"><a class="header" href="#during-development">During Development</a></h3>
<p>When developing jobs, tasks and plugins for your robot, you'll mostly use the terminal connector and treat <code>state/</code> as disposable. A fairly standard workflow goes like this:</p>
<ol>
<li>Run your robot with the <code>./cbot.sh dev &lt;path/to/profile&gt;</code> script, which uses the <a href="https://github.com/lnxjedi/gopherbot/pkgs/container/gopherbot-dev">gopherbot-dev</a> container, providing the path to a profile used for that robot</li>
<li>Use the <strong>terminal</strong> connector, configured to mirror your team chat environment, for developing extensions for your robot</li>
<li>In the <code>custom/</code> directory, create commits as desired, creating and pushing commits as normal</li>
<li>Send an administrator <code>update</code> command to your production robot to pull down the latest changes and reload</li>
</ol>
<p>For more information on developing, see the chapter on <a href="botsetup/../botprogramming.html">Developing Extensions</a>.</p>
<h3 id="deployment-to-production"><a class="header" href="#deployment-to-production">Deployment to Production</a></h3>
<p>Production robots normally clone <code>custom/</code> the first time they start on a new VM or container, and are updated by an administrator <code>update</code> command.</p>
<blockquote>
<p>Production robots can also be configured to automatically update whenever the master branch updates. <strong>Floyd</strong>, for example, does this. See the <code>Triggers:</code> section in Floyd's <a href="https://github.com/parsley42/floyd-gopherbot/blob/master/conf/jobs/updatecfg.yaml">updatecfg.yaml file</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-autosetup"><a class="header" href="#quick-start-with-autosetup">Quick Start with Autosetup</a></h1>
<h2 id="setting-up-a-new-robot-on-linux"><a class="header" href="#setting-up-a-new-robot-on-linux">Setting up a New Robot on Linux</a></h2>
<p>If you have easy access to a Linux system, the simplest way to set up a new robot is to <a href="botsetup/../install/ManualInstall.html">install the gopherbot archive</a>, create an empty working directory, create a symlink there to the <code>/opt/gopherbot/gopherbot</code> executable, then use the autosetup plugin as described in the docker instructions below (with appropriate and obvious modifications, e.g. running <code>./gopherbot init slack</code>).</p>
<h2 id="setting-up-a-new-robot-with-docker"><a class="header" href="#setting-up-a-new-robot-with-docker">Setting up a New Robot with Docker</a></h2>
<p>If you're running a Windows or MacOS system, the best way to set up a new robot is using the <a href="https://github.com/lnxjedi/gopherbot/pkgs/container/gopherbot-dev">gopherbot-dev</a> container image running in <a href="https://www.docker.com/">Docker</a> on your workstation. Using <strong>Clu</strong> as an example:</p>
<p><strong>1.</strong> Start a new, empty <code>gopherbot-dev</code> container:</p>
<pre><code>$ docker run -p 127.0.0.1:3000:3000 --name clu quay.io/lnxjedi/gopherbot-dev:latest
root INFO Configuration directory URI: 'file:///home/robot/.theia'
...
root INFO Deploy plugins list took: 441.6 ms
</code></pre>
<p><strong>2.</strong> Open your browser and browse to <code>http://127.0.0.1:3000</code> to view the <a href="https://github.com/eclipse-theia/theia">Theia</a> interface.</p>
<p><strong>3.</strong> Open a terminal from the <code>Terminal</code> menu, and run <code>gopherbot init slack</code> to get a slack <code>answerfile.txt</code>:</p>
<pre><code>$ gopherbot init slack
Edit 'answerfile.txt' and re-run gopherbot with no arguments to generate your robot.
</code></pre>
<p><strong>4.</strong> Click the file icon or use the <code>File ... Open...</code> menu to open the newly-created <code>answerfile.txt</code>, then follow the directions to fill in the blanks. Note that the answerfile template also contains documentation regarding the requirements for setting up your robot, including information on obtaining credentials for your robot to use with team chat.</p>
<blockquote>
<p>If you're not already familiar with <strong>ssh deploy keys</strong>, you should read up on the documentation for your <em>git</em> provider; see for example the <a href="https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys">Github deploy keys</a> documentation, which also has useful information about <a href="https://developer.github.com/v3/guides/managing-deploy-keys/#machine-users">machine users</a>.</p>
</blockquote>
<p><strong>5.</strong> When you've finished editing and saving <code>answerfile.txt</code>, re-run <code>gopherbot</code>; your robot will process the answerfile to generate your robot's initial configuration:</p>
<pre><code>$ gopherbot 
2020/03/22 10:40:57 Info: Logging to robot.log
null connector: Initializing encryption and restarting...
2020/03/22 10:40:59 Info: Logging to robot.log
null connector: Continuing automatic setup...
null connector: Generating ssh keys...
...
null connector: ********************************************************


null connector: Initial configuration of your robot is complete. To finish
setting up your robot, and to add yourself as an administrator:
1) Open a second terminal window in the same directory as answerfile.txt; you'll
need this for completing setup.
...
(NOTE: Scroll back to the line of *** above and follow the directions to finish
setup)
</code></pre>
<p><strong>6.</strong> Follow the instructions to get your robot connected to your team chat, add yourself as a robot administrator, and save your robot to it's <em>git</em> repository.</p>
<blockquote>
<p>NOTE: the quickest way to open a second terminal is to click the &quot;Split Terminal&quot; box in the upper-right corner of your initial terminal.</p>
</blockquote>
<p>That's it - your robot is ready to be deployed and start doing some work. Once you've saved the robot's <code>.env</code> file to a safe location, you can delete the container. The rest of this manual details deploying and managing your robot.</p>
<p><strong>7.</strong> To clean up:</p>
<pre><code>$ docker stop clu
$ docker rm clu
</code></pre>
<blockquote>
<p>Note: After setting up your robot, you may get an e-mail from GitHub about having uploaded an ssh private key. Don't panic! If you download the keys and try to use them with <code>ssh-add</code>, you'll find they're encrypted - false alarm. You'll need your robot's <code>GOPHER_ENCRYPTION_KEY</code> to decrypt the passphrase.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-setup"><a class="header" href="#manual-setup">Manual Setup</a></h1>
<p>This section documents manual setup of a new robot custom configuration repository, using a Linux system or VM with the <strong>Gopherbot</strong> software <a href="botsetup/../install/ManualInstall.html">already installed</a>. Note that the documentation will often refer to a robot's <em>configuration repository</em>, even though using a <em>git</em> repository isn't strictly required.</p>
<blockquote>
<p>Note: This manual in general, and this section in particular, is not written as a complete step-by-step guide. Rather more of an outline, it skips a lot of e.g. <code>mkdir</code>, <code>sudo</code>, etc. If you're somewhat new to Linux systems administration, but have some experience with containers (e.g. <a href="https://www.docker.com/">Docker</a>), you'll have a much better experience with <a href="botsetup/Plugin.html">autosetup</a>. Nevertheless, you may find some useful content that makes this section worth reading.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-the-gopher_home-directory"><a class="header" href="#create-the-gopher_home-directory">Create the GOPHER_HOME directory</a></h1>
<p>Similar to an <a href="https://www.ansible.com/">Ansible</a> playbook, a <strong>Gopherbot</strong> robot is heavily oriented around a standard directory structure for a given robot. To begin with, create an empty directory for your robot; <code>/var/lib/robots</code> or <code>/home/robots</code> are good places for this. I normally name the directory after the robot; in this example setup, we'll use <code>clu</code>:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots$ mkdir clu
davidparsley@penguin:/home/robots$ cd clu/
davidparsley@penguin:/home/robots/clu$ ln -s /opt/gopherbot/gopherbot .
</code></pre>
<blockquote>
<p>Note that we've created a symlink to the <strong>Gopherbot</strong> binary for convenience, and this is required for the rest of this chapter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-the-initial-env-file"><a class="header" href="#create-the-initial-env-file">Create the Initial .env File</a></h1>
<p>Though it's possible to run <strong>Gopherbot</strong> with neither encryption nor a <em>git</em> repository, this example documents the more common scenario. To begin with, create a <code>.env</code> file in your new directory with contents similar to the following:</p>
<pre><code class="language-shell">GOPHER_ENCRYPTION_KEY=SomeLongStringAtLeast32CharsOrItWillFail
</code></pre>
<p>Note that the robot will only use the first 32 chars of the encryption key, so no need to go crazy here. Keep your <code>GOPHER_ENCRYPTION_KEY</code> in a safe place, outside of any git repository. Your robot will need it, along with <code>$GOPHER_HOME/custom/binary-encrypted-key</code> (kept in the robot's repository), to decrypt it's secrets - such as a Slack token.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialize-encryption"><a class="header" href="#initialize-encryption">Initialize Encryption</a></h1>
<p>Now that you've set the robot's encryption key, you can initialize encryption and create the binary key (<code>binary-encrypted-key</code>) encrypted with your <code>GOPHER_ENCRYPTION_KEY</code>. Start the default robot using the terminal connector, and the binary encryption key will be automatically created in <code>custom/binary-encrypted-key</code>; use <code>ctrl-d</code> to exit:</p>
<pre><code>davidparsley@penguin:/home/robots/clu$ ./gopherbot 
2020/03/09 18:29:43 Logging to robot.log; warnings and errors duplicated to stdout
Terminal connector running; Type '|c?' to list channels, '|u?' to list users
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration was detected, you're
connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try 'gopherbot --help';
otherwise feel free to play around with the default robot - you can start by typing 'help'.
c:general/u:alice -&gt; exit
general: @alice Hasta la vista!
Terminal connector finished
davidparsley@penguin:/home/robots/clu$ ls custom/
binary-encrypted-key
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-modify-the-standard-robot"><a class="header" href="#copy-and-modify-the-standard-robot">Copy and Modify the Standard Robot</a></h1>
<p>Now copy the contents of <code>robot.skel</code> from the distribution archive to the new <code>custom/</code> directory:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ cp -a /opt/gopherbot/robot.skel/* custom/
</code></pre>
<blockquote>
<p>Note the <code>.??*</code> wildcard picks up any hidden files</p>
</blockquote>
<h3 id="41-encrypting-your-slack-token-and-other-secrets"><a class="header" href="#41-encrypting-your-slack-token-and-other-secrets">4.1 Encrypting your Slack Token (and other secrets)</a></h3>
<p>With encryption initialized, you can use the <code>gopherbot encrypt</code> command to generate base64 encoded ciphertext. This ciphertext can then be placed in your configuration <code>yaml</code> files by using e.g. <code>{{ decrypt &quot;jfhPe8akfivTRnfeCxyIetdUl+Jb7hIWnjeVFiwLJarFHuW4TuSD7GQ3F0s2puuZ3JUotw==&quot; }}</code>. The default configuration assumes you'll only encrypt the portion of your slack token (from https://&lt;your-team&gt;.slack.com/apps/A0F7XDU93-hubot) following the common <code>xoxb-</code> prefix. So, for a slack token of <code>xoxb-123-abc-XXXXX</code>, you would generate the ciphertext with:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ ./gopherbot encrypt 123-abc-XXXXX
FverBqdWHzHfEPDy/cQ8U9AJ3z4v8KdGSubDMALPfHIupwDLctDWQ1c=
</code></pre>
<p>Now edit your <code>conf/slack.yaml</code> file and replace <code>&lt;slackencrypted&gt;</code> with the ciphertext, e.g.:</p>
<pre><code class="language-yaml">  SlackToken: xoxb-{{ decrypt &quot;FverBqdWHzHfEPDy/cQ8U9AJ3z4v8KdGSubDMALPfHIupwDLctDWQ1c=&quot; }}
</code></pre>
<h3 id="42-editing-standard-configuration"><a class="header" href="#42-editing-standard-configuration">4.2 Editing Standard Configuration</a></h3>
<p>Now you need to edit the configuration files under <code>custom/</code>, replacing most of the <code>&lt;replacevalue&gt;</code> instances with values for your robot.</p>
<p>In <code>custom/conf/robot.yaml</code>:</p>
<ul>
<li>Replace <code>&lt;botname&gt;</code> with the name of your robot, e.g. <code>clu</code></li>
<li>Replace <code>&lt;botemail&gt;</code> with an email address for your robot; will be used for &quot;from:&quot;</li>
<li>Replace <code>&lt;botfullname&gt;</code> with a full name, informational only; e.g. &quot;Clu Gopherbot&quot;</li>
<li>Replace <code>&lt;botalias&gt;</code> with a single-character alias for addressing your robot from the list <code>'&amp;!;:-%#@~&lt;&gt;/*+^\$?\[]{}'</code> (&quot;;&quot; is good for this)</li>
<li>Replace <code>&lt;sshencrypted&gt;</code> encrypted ciphertext for a 16+ char ssh passphrase for your robot, generated with <code>./gopherbot encrypt</code> as above</li>
</ul>
<p>In <code>custom/conf/slack.yaml</code>:</p>
<ul>
<li>Leave alone for now; you'll replace <code>&lt;adminusername&gt;</code> and <code>&lt;adminuserid&gt;</code> later, after your robot has successfully connected</li>
</ul>
<p>In <code>custom/conf/terminal.yaml</code>:</p>
<ul>
<li>Replace <code>&lt;botalias&gt;</code> with your robot's single-character alias</li>
</ul>
<p>In <code>custom/git/config</code>, replace the values for <code>&lt;botfullname&gt;</code> and <code>&lt;botemail&gt;</code>; these will be used when your robot performs a <code>git commit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generate-ssh-keypairs"><a class="header" href="#generate-ssh-keypairs">Generate SSH Keypairs</a></h1>
<p>Now generate the ssh keypairs for your robot - use the passphrase you encrypted previously for generating both <code>manage_key</code> and <code>robot_key</code>; finally create an unencrypted <code>deploy_key</code> and move it out of the repo:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ mkdir custom/ssh
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;VeryLovelyNicePassword&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/manage_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/manage_key.
Your public key has been saved in custom/ssh/manage_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;VeryLovelyNicePassword&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/robot_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/robot_key.
Your public key has been saved in custom/ssh/robot_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/deploy_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/deploy_key.
Your public key has been saved in custom/ssh/deploy_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ mv custom/ssh/deploy_key .
</code></pre>
<blockquote>
<p>Note that deploy_key is unencrypted, and not kept in the robot's repository which is rooted in the <code>custom</code> directory.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finish-the-env-file"><a class="header" href="#finish-the-env-file">Finish the <code>.env</code> File</a></h1>
<p>First, use <code>tr</code> to dump a flattened version of the <code>deploy_key</code> private key to the <code>.env</code> file:</p>
<pre><code>$ cat custom/ssh/deploy_key | tr ' \n' '_:' &gt;&gt; .env
</code></pre>
<p>Now edit the <code>.env</code> file and stick <code>GOPHER_DEPLOY_KEY=</code> in front of that mess, and add values for <code>GOPHER_PROTOCOL</code> and <code>GOPHER_CUSTOM_REPOSITORY</code>. Using <strong>Clu</strong> as an example, the end result should look something like this:</p>
<pre><code>GOPHER_ENCRYPTION_KEY=&lt;redacted&gt;
GOPHER_PROTOCOL=slack
GOPHER_CUSTOM_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
GOPHER_DEPLOY_KEY=-----BEGIN_OPENSSH_PRIVATE_KEY-----:lksjflsjdf&lt;muchjunkremoved&gt;ljsdflsjdf:-----END_OPENSSH_PRIVATE_KEY-----:
</code></pre>
<blockquote>
<p>Note that <code>GOPHER_DEPLOY_KEY</code> is a very long line, a bit over 2k. The format with spaces and newlines replaced was chosen as most compatible with the shell, docker, and <code>.env</code>-reading libraries.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect-robot-to-team"><a class="header" href="#connect-robot-to-team">Connect Robot to Team</a></h1>
<p>Now your robot should be able to connect to team chat, and respond to your messages:</p>
<pre><code class="language-shell">davidparsley@penguin:~/git/clu$ GOPHER_PROTOCOL=slack ./gopherbot 
2020/02/19 15:50:00 Initialized logging ...
2020/02/19 15:50:00 Loaded initial private environment from '.env'
...
2020/02/19 15:50:20 Info: Robot is initialized and running
</code></pre>
<p>Now you can <code>/invite</code> your robot to the <code>#general</code> channel, and get the information you need from Slack to configure yourself as the robot's administrator:</p>
<pre><code>#general me-&gt; clu, whoami
#general clu-&gt; You are 'Slack' user 'parsley/U0JLW8EMS', speaking in channel 'general/C0JLW8EP6', email address: parsley@linuxjedi.org
</code></pre>
<p>Given this reply, you would replace <code>&lt;adminusername&gt;</code> with <code>parsley</code> and <code>&lt;adminuserid&gt;</code> with <code>U0JLW8EMS</code> in <code>custom/conf/slack.yaml</code>. Now you can stop the robot with <code>ctrl-c</code> and restart with access to administrative commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-your-robot-to-git"><a class="header" href="#saving-your-robot-to-git">Saving Your Robot to Git</a></h1>
<p>At this point the contents of <code>custom/</code> should be committed to a git repository, and your robot should be run with <code>GOPHER_CUSTOM_REPOSITORY=&lt;clone-url&gt;</code>, where the <code>clone-url</code> is for use with ssh credentials. You can perform this step manually, or set up your robot's deploy keys and let the robot save it's own configuration.</p>
<h2 id="configuring-deploy-keys"><a class="header" href="#configuring-deploy-keys">Configuring Deploy Keys</a></h2>
<p>As noted in <a href="botsetup/Requirements.html#git-access">requirements</a>, the standard robot has three ssh keypairs by default, two of which are configured as deploy keys for the repository.</p>
<p>Find the <strong>deploy keys</strong> section for the robot's git repository, then:</p>
<ul>
<li>Configure a <strong>read-write</strong> deploy key with the contents of <code>custom/ssh/manage_key.pub</code>; this corresponds to the encrypted <code>manage_key</code> the robot can use to save it's own configuration, or back up it's state / brain</li>
<li>Configure a <strong>read-only</strong> deploy key with the contents of <code>custom/ssh/deploy_key.pub</code>; this corresponds to the unencrypted <code>GOPHER_DEPLOY_KEY</code> in the <code>.env</code> file, and the gopherbot <strong>bootstrap</strong> plugin can use this to deploy your robot to e.g. a generic container or new VM</li>
</ul>
<p>Once you've set up the deploy keys, open a private chat with your robot and tell it to <code>save</code>; if all has gone well, your robot will push the contents of <code>custom/</code> to it's git repository, and should be ready to go.</p>
<p>This setup allows for a common workflow where the robot is running in a container, VM, or server in your infrastructure, and updates to robot configuration are made by updating the robot's configuration repository, followed by an administrator <code>update</code> command, (e.g. <code>clu, update</code>). The <code>update</code> command will cause the robot to <code>git pull</code> it's custom configuration, then perform a reload and report any errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finished"><a class="header" href="#finished">Finished</a></h1>
<p>That's it! You've created the initial configuration for your <strong>Gopherbot</strong> robot, which you can now customize and deploy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-and-running-your-robot"><a class="header" href="#deploying-and-running-your-robot">Deploying and Running Your Robot</a></h1>
<p><strong>Gopherbot</strong> is very flexible about being able to bootstrap and run in a variety of environments, and is designed to be remotely updated via git integration. This chapter discusses the two primary ways you'll run your robot:</p>
<ul>
<li>Using <a href="https://podman.io">Podman</a>, <a href="https://docker.com">Docker</a>, <a href="https://kubernetes.io">Kubernetes</a>, or any number of other container-centric environments, you can bootstrap and run your robot <a href="deploy/Container.html">in a Container</a></li>
<li>The <code>resources/</code> directory contains a template <code>robot.service</code> that can be used to run your robot on a Linux host <a href="deploy/systemd.html">using Systemd</a></li>
</ul>
<h2 id="the-env-file"><a class="header" href="#the-env-file">The <code>.env</code> file</a></h2>
<p>Regardless of your running environment, you'll need a copy of your robot's <code>.env</code> file generated when you configured your robot. If <code>GOPHER_PROTOCOL</code> is set, you might want it commented out so you can run your robot with the <strong>terminal</strong> connector, instead of having it connect to your team chat. For <strong>Clu</strong>, the <code>.env</code> looks like this:</p>
<pre><code>GOPHER_ENCRYPTION_KEY=&lt;redacted&gt;
#GOPHER_PROTOCOL=slack
GOPHER_CUSTOM_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
GOPHER_DEPLOY_KEY=-----BEGIN_OPENSSH_PRIVATE_KEY-----:&lt;much junk removed&gt;:-----END_OPENSSH_PRIVATE_KEY-----:
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-in-a-container"><a class="header" href="#running-in-a-container">Running in a Container</a></h1>
<p>A major goal for <strong>Gopherbot</strong> v2 was container-native operation, and the ability to run your robot with all it's functionality and state/context, without requiring a persistent volume mount or a custom image with your robot baked-in. You can launch your robot using any of the <a href="https://github.com/orgs/lnxjedi/packages">stock images</a>; you should only need to create a custom image if your robot requires specific extra tools or libraries to do it's work, such as e.g. an ldap client or specific python module.</p>
<p>This section gives an example of running your robot with docker/podman, but otherwise doesn't delve in to the specifics of running your robot in any particular container environment. Whether your robot runs as a persistent container on a Docker host, or as a managed container in a Kubernetes or Openshift cluster - or elsewhere - the same principles apply. If you're planning on deploying in a container, it is presumed that you're already running other containerized workloads, and can provide the requirements by common means for your container environment.</p>
<p>The contents of your robot's <code>.env</code> file are all that's needed - the built-in <strong>bootstrap</strong> plugin will use your robot's <code>deploy_key</code> key to clone it's configuration from <code>GOPHER_CUSTOM_REPOSITORY</code>, then use the <code>GOPHER_ENCRYPTION_KEY</code> to decrypt the <code>manage_key</code> ssh private key to restore file-backed memories if you use the default <code>file</code> brain for the standard robot.</p>
<h2 id="container-considerations"><a class="header" href="#container-considerations">Container Considerations</a></h2>
<h3 id="backing-up-state-and-memories"><a class="header" href="#backing-up-state-and-memories">Backing up State and Memories</a></h3>
<p>The standard robot includes a <code>backup</code> job in the stock <code>robot.yaml</code>. You can modify this to set the frequency of backups. The underlying job uses <code>git status --porcelain</code> to determine if a backup is needed, so there's little overhead in the case where memories don't change frequently. Since new memories tend to come in batches - for instance, adding bookmarks with the links plugin - an hourly schedule probably strikes a good balance between keeping the <code>robot-state</code> branch updated while not creating too many small commits.</p>
<p>The <strong>bootstrap</strong> plugin will trigger a restore during start-up, so launching your robot into a new, empty container should restore it's state and memories automatically. Take care that you don't run multiple production instances of your robot; not only would this run the risk of corrupting state, but this can produce strange behavior in your team chat.</p>
<h3 id="providing-environment-variables"><a class="header" href="#providing-environment-variables">Providing Environment Variables</a></h3>
<p>When launching your robot in a container, you'll need to provide the environment variables defined in the robot's <code>.env</code> file. There are two primary ways of accomplishing this:</p>
<ul>
<li>Both <code>docker</code> and <code>podman</code> allow you to set environment variables with a <code>--env-file .env</code> argument</li>
<li>Container orchestration environments or e.g. <code>docker-compose</code> provide other means of providing these values; take care that the value for <code>GOPHER_ENCRYPTION_KEY</code> doesn't get committed to a repository</li>
</ul>
<h3 id="setting-the-gopher_protocol-environment-variable"><a class="header" href="#setting-the-gopher_protocol-environment-variable">Setting the <code>GOPHER_PROTOCOL</code> Environment Variable</a></h3>
<p>When starting <code>gopherbot</code> at the CLI, or using systemd, the value for <code>GOPHER_PROTOCOL</code> should be commented out in the <code>.env</code>; however this value is required for launching in a container so that your robot will start and connect to your team chat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-example"><a class="header" href="#docker-example">Docker Example</a></h1>
<p>For certain environments, running your robot in a standard docker container on your server or workstation is perfectly reasonable. You can use this example to help get your robot running.</p>
<h2 id="production-container"><a class="header" href="#production-container">Production Container</a></h2>
<p>For the example, you'll need to create an empty directory named after your robot, copy the robot's <code>.env</code> file to <code>&lt;botname&gt;/environment</code>, and run your robot from that directory.</p>
<p>A command similar to this is suitable for a Linux host OS using <code>journald</code> for logging. Using <code>Clu</code>:</p>
<pre><code>$ docker container run --name &quot;clu&quot; --restart unless-stopped -d \
	  --log-driver journald --log-opt tag=&quot;clu&quot; \
	  --env-file environment -e HOSTNAME=&quot;my.host.name&quot; \
	  quay.io/lnxjedi/gopherbot:latest
</code></pre>
<p>Then, to verify your robot is running:</p>
<pre><code>$ docker logs clu
Info: PID == 1, spawning child
Info: Starting pid 1 signal handler
Initialized logging ...
...
Info: Initializing plugin: citools
Info: Initializing plugin: ssh-admin
Info: Robot is initialized and running
</code></pre>
<blockquote>
<p>Note: when running on Linux, you could use <code>podman</code> in place of <code>docker</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-to-kubernetes"><a class="header" href="#deploying-to-kubernetes">Deploying to Kubernetes</a></h1>
<p>Eventually, as Kubernetes eats the world, this will be <strong>THE</strong> way to run your <strong>Gopherbot</strong> robot. It's the platform of choice for my own production robot, <code>Data</code>, who runs my CI/CD pipelines and other jobs. For now, this is somewhat experimental. If you have a k8s cluster, and <a href="https://helm.sh/">helm 3</a>, see the <code>README.md</code> in <code>resources/helm-gopherbot</code> of the <strong>Gopherbot</strong> archive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-with-systemd"><a class="header" href="#running-with-systemd">Running with Systemd</a></h1>
<p>One way of running your robot is to use a <strong>systemd</strong> unit file on a systemd-managed Linux host:</p>
<ul>
<li>Copy <code>resources/robot.service</code> to <code>/etc/systemd/system/&lt;botname&gt;.service</code> and edit with values for your system; you'll need to create a local user, and a directory for your robot that the user can write to</li>
<li>Reload <code>systemd</code> with <code>systemctl daemon-reload</code></li>
<li>Enable the service with <code>systemctl enable &lt;botname&gt;</code></li>
<li>Place your robot's <code>.env</code> in the robot's home directory, mode <code>0400</code>, owned by the robot user; you can leave <code>GOPHER_PROTOCOL</code> commented out, since the value should be set in the <code>&lt;botname&gt;.service</code> file</li>
<li>Start the service: <code>systemctl start &lt;botname&gt;</code></li>
</ul>
<p>That's it! Your robot should start and connect to your team chat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-basics"><a class="header" href="#robot-basics">Robot Basics</a></h1>
<p>Central to the design of Gopherbot is the idea that once your robot connects to your team chat and joins one or more channels, the robot &quot;hears&quot; every message in those channels, just as a user would. Every time the robot hears a message<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<ul>
<li>It checks to see if the message was directed to it by name</li>
<li>It checks for &quot;ambient&quot; message matches</li>
<li>It checks for matching job triggers</li>
</ul>
<p>This chapter focuses on the first case - sending commands directly to your robot.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Depending on the configured values for <code>IgnoreUnlistedUsers</code> and <code>IgnoreUsers</code>, messages may be dropped entirely without any processing. This would show up in the logs at log level <strong>Debug</strong>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addressing-your-robot-and-using-ping"><a class="header" href="#addressing-your-robot-and-using-ping">Addressing your Robot and using Ping</a></h1>
<p>Most chat platforms provide some kind of capability for &quot;mentioning&quot; your robot using an <code>@...</code> syntax; normally, prefixing a message with your robot's mention name will cause it to process the message as a command. For maximum compatibility when switching chat platforms, <strong>Gopherbot</strong> robots all have a regular 'name' like 'Floyd' which they recognize, as well as a single-character 'alias'. To verify your robot &quot;hears&quot; messages, you would normally use the single &quot;ping&quot; command, which defaults to being available in all the channels where the robot is present. Here are some examples of using &quot;ping&quot; with <strong>Floyd</strong>, whose alias is <code>;</code>:</p>
<pre><code>c:general/u:alice -&gt; floyd, ping
general: @alice PONG
c:general/u:alice -&gt; ;ping
general: @alice PONG
c:general/u:alice -&gt; floyd ping
general: @alice PONG
c:general/u:alice -&gt; floyd: ping
general: @alice PONG
c:general/u:alice -&gt; ping, floyd
general: @alice PONG
c:general/u:alice -&gt; ping
c:general/u:alice -&gt; floyd
general: @alice PONG
c:general/u:alice -&gt; ping
c:general/u:alice -&gt; ;
general: @alice PONG
c:general/u:alice -&gt; ping floyd
c:general/u:alice -&gt;
</code></pre>
<p>The last three examples are instructive: 1) if you type a command for your robot but forget to address the robot, typing the robot's name or alias alone as your next message will cause it to process your previous message as a command if done within a short period of time. 2) While &quot;&lt;command&gt;, &lt;botname&gt;&quot; is considered a command, &quot;&lt;command&gt; &lt;botname&gt;&quot; (without a comma) is not; this allows the robot to be discussed (e.g. &quot;try using floyd&quot;) without the robot parsing it as a command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-matching-and-command-not-found"><a class="header" href="#command-matching-and-command-not-found">Command Matching and &quot;command not found&quot;</a></h1>
<p>Like the UNIX command-line, your robot is sensitive to typos; more accurately, every robot command is checked against a set of regular expressions to see if a plugin is matched. It's not rocket science, and it's not AI - it's just good 'ol regexes. When you address your robot directly, but the message doesn't match a command regex, the robot's reply is a little more verbose than &quot;command not found&quot;:</p>
<pre><code>general: @alice Sorry, that didn't match any commands I know,
or may refer to a command that's not available in this channel;
try 'floyd, help &lt;keyword&gt;'
</code></pre>
<p>If you're sure you've typed the command correctly, your plugin may not be available in the current channel; the help system is useful for that:</p>
<pre><code>c:chat/u:alice -&gt; tell me a joke, clu
chat: @alice Sorry, that didn't match any commands I know,
or may refer to a command that's not available in this channel;
try 'Clu, help &lt;keyword&gt;'
c:chat/u:alice -&gt; clu, help joke
chat: Command(s) matching keyword: joke
Clu, tell me a (knock-knock) joke (channels: general, random, botdev, clu-jobs)
c:chat/u:alice -&gt; |cgeneral
Changed current channel to: general
c:general/u:alice -&gt; tell me a joke, clu
general: Hang on while I Google that for you (just kidding ;-)
general: @alice Knock knock
c:general/u:alice -&gt; Who's there?
general: @alice Weevil
c:general/u:alice -&gt; Weevil who?
general: Weevil weevil rock you
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="availability-by-channel"><a class="header" href="#availability-by-channel">Availability by Channel</a></h1>
<p>Individual <strong>Gopherbot</strong> robots normally limit commands to certain channels, contextually; for instance, the &quot;build&quot; command may be limited to a job channel, where developers can all &quot;see&quot; each other starting builds. Generally speaking, limiting commands to select channels is fairly common for a <strong>Gopherbot</strong> robot. By adding <code>Channels: [ &quot;foo&quot;, &quot;bar&quot; ]</code> to a plugin's <code>*.yaml</code> configuration file, an administrator can easily override the default channels for a given plugin.</p>
<h2 id="default-channels"><a class="header" href="#default-channels">Default Channels</a></h2>
<p>Many of the robot's plugins aren't context-sensitive, and can be available anywhere. Practically, however, you might want to limit these to a small number of channels to prevent common channels from getting junked up with robot noise. The slack protocol configuration for the standard robot has:</p>
<pre><code>DefaultChannels: [ &quot;general&quot;, &quot;random&quot; ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-built-in-help-system"><a class="header" href="#the-built-in-help-system">The Built-in Help System</a></h1>
<p>For a quick intro to the robot, the ambient<sup class="footnote-reference"><a href="#1">1</a></sup> command &quot;help&quot;, by itself, will provide you with a quick overview of using the help system:</p>
<pre><code>c:chat/u:alice -&gt; help
chat: @alice I've sent you a private message introducing myself
(dm:alice): Hi, I'm Clu, a staff robot. I see you've asked for help.
...
</code></pre>
<p>Note that if you address the robot with it's name or alias, you instead get help for all the commands in the current channel:</p>
<pre><code>c:chat/u:alice -&gt; clu, help
chat: @alice (the help output was pretty long, so I sent you a private message)
(dm:alice): Command(s) available in channel: chat
Clu, help with robot - give general help on the help system and using the robot

Clu, help &lt;keyword&gt; - find help for commands matching &lt;keyword&gt;
...
</code></pre>
<p><strong>Gopherbot</strong> ships with a simple keyword-based help system. Each plugin specifies a set of help texts linked to keywords, and these can easily be added to by providing custom <code>AppendHelp: ...</code> for a given plugin. Since <strong>Gopherbot</strong> commands are commonly linked to channels, keyword help will list the channels where a command is available if it's not in the current channel.</p>
<p>Additionally, some plugins may define custom &quot;help with &lt;foo&gt;&quot; commands that give extended help information about the plugin.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>&quot;ambient&quot; commands are matched against the entire message, every time. Once example of this is the &quot;Chuck Norris&quot; plugin; any time The Great One is mentioned, the robot will pipe up with an anecdote.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-plugins-and-commands"><a class="header" href="#standard-plugins-and-commands">Standard Plugins and Commands</a></h1>
<p>In addition to &quot;ping&quot;, and &quot;help&quot;, which we've already introduced, there are a few other standard commands normally available to all users:</p>
<ul>
<li><code>info</code> - provides basic information about the robot's software version and where it's running:</li>
</ul>
<pre><code>c:chat/u:alice -&gt; !info
chat: Here's some information about me and my running environment:
The hostname for the server I'm running on is: 
My name is 'Clu', alias '!', and my Terminal internal ID is '(unknown)'
This is channel 'chat', Terminal internal ID: #chat
The gopherbot install directory is: /home/davidparsley/git/gopherbot
My home directory ($GOPHER_HOME) is: /home/davidparsley/git/clu
My git repository is: git@github.com:parsley42/clu-gopherbot.git
My software version is: Gopherbot v2.0.0-beta3-snapshot, commit: dec5573
The administrators for this robot are: alice
The administrative contact for this robot is: David Parsley, &lt;parsley@linuxjedi.org&gt;
</code></pre>
<ul>
<li><code>whoami</code> - gives information about how the robot &quot;sees&quot; you, with information useful for the <code>UserRoster</code>:</li>
</ul>
<pre><code>c:chat/u:alice -&gt; !whoami
chat: You are 'Terminal' user 'alice/u0001', speaking in channel 'chat/#chat',
email address: alice@example.com
</code></pre>
<h2 id="the-links-plugin"><a class="header" href="#the-links-plugin">The &quot;links&quot; Plugin</a></h2>
<p>To simplify sharing common bookmarks with the rest of your team, you can use the &quot;links&quot; plugin:</p>
<pre><code>c:general/u:alice -&gt; !link employee manual to https://example.com/hr.html
general: Link added
c:general/u:alice -&gt; !look up manual
general: Here's what I have for &quot;manual&quot;:
https://example.com/hr.html: employee manual
c:general/u:alice -&gt; !help with links
general: The links plugin stores URLs and associates them with a text key that can
be words or phrases. The 'link' command stores a link and key in one command, and the
'save' command will prompt the user to enter the key. The lookup command
will return all links whose key contains the provided word or phrase,
case insensitive. Links can be deleted with the 'remove' command.
</code></pre>
<h2 id="the-lists-plugin"><a class="header" href="#the-lists-plugin">The &quot;lists&quot; Plugin</a></h2>
<p>Slightly less useful, the &quot;lists&quot; plugin can be used for keeping simple lists of items:</p>
<pre><code>c:general/u:alice -&gt; !add beans to the grocery list
general: Ok, I added beans to the grocery list
c:general/u:alice -&gt; !add milk to the list
general: Ok, I added milk to the grocery list
c:general/u:alice -&gt; !show the list
general: Here's what I have on the grocery list:
bacon
tomatoes
bananas
wine
beer
mint cookies
salad
beans
milk
</code></pre>
<blockquote>
<p>Note that the last few commands simply referred to &quot;the list&quot;, instead of fully specifying &quot;the grocery list&quot;. Again, it's not AI; see the next section on &quot;context&quot;.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>Commands can be configured to store certain matched fields as labeled context items, e.g. &quot;item&quot; or &quot;list&quot;. This feature is somewhat experimental, but could occasionally be useful. A somewhat contrived example uses the &quot;list&quot; and &quot;item&quot; contexts with the aforementioned links and lists plugins:</p>
<pre><code>c:general/u:alice -&gt; !link broiled salmon to https://cooking.com/salmon.html
general: Link added
c:general/u:alice -&gt; !add it to the dinner meals list
general: @alice I don't have a 'dinner meals' list, do you want to create it?
c:general/u:alice -&gt; yes
general: Ok, I created a new dinner meals list and added broiled salmon to it
c:general/u:alice -&gt; !link tuna casserole to https://cooking.com/tuna.html
general: Link added
c:general/u:alice -&gt; !add it to the list
general: Ok, I added tuna casserole to the dinner meals list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-your-robot-and-adding-extensions"><a class="header" href="#managing-your-robot-and-adding-extensions">Managing Your Robot and Adding Extensions</a></h1>
<p><strong>Gopherbot</strong> robots are designed to be remotely administered and updated, for common cases where a robot runs behind network firewalls, in virtual cloud networks, or in a container environment. Many of the frequently desired updates - such as changing the schedule of an automated job - can be safely and easily updated by pushing a commit to your robot's repository and instructing it to update. More significant updates can be tested by modelling with the <strong>terminal</strong> connector before committing and saving, then updating your production robot.</p>
<p>This chapter covers:</p>
<ul>
<li>How to update your robot with <strong>git</strong></li>
<li>The two primary ways to set up a dev environment</li>
<li><strong>Gopherbot</strong> CLI commands</li>
</ul>
<p>You should have a robot deployed &quot;in production&quot; (connected to your team chat) to work the examples in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-from-git"><a class="header" href="#updating-from-git">Updating from Git</a></h1>
<p>The most trivial changes can be made by pushing updates directly to your robot's repository, and instructing your robot to update. For this exercise, we'll add your robot's job channel to the list of default channels, making many more plugins available there.</p>
<blockquote>
<p>Note: In the example dialogs, Bishop's alias, <code>-</code>, precedes most commands - you'll need to substitute your own robot's alias.</p>
</blockquote>
<p><strong>1.</strong> You can use the normal <code>git</code> CLI to clone the repository, or you can use your git provider's web interface to make changes. We're going to modify <code>conf/slack.yaml</code>; find the <code>DefaultChannels</code> line:</p>
<pre><code class="language-yaml">DefaultChannels: [ &quot;general&quot;, &quot;random&quot; ]
</code></pre>
<p>... then update the list, and add your robot's job channel; using <strong>bishop</strong> as an example:</p>
<pre><code class="language-yaml">DefaultChannels: [ &quot;general&quot;, &quot;random&quot;, &quot;bishop-jobs&quot; ]
</code></pre>
<p><strong>2.</strong> Commit and push your changes</p>
<p><strong>3.</strong> In your robot's job channel, verify that the <em>lists</em> plugin isn't available:</p>
<pre><code>parsley:
-list lists

Bishop Gopherbot:
@parsley: Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'bishop, help &lt;keyword&gt;'
</code></pre>
<p><strong>4.</strong> Now instruct your robot to update it's configuration, triggering a git pull and a reload:</p>
<pre><code>parsley:
-update

Bishop Gopherbot:
Ok, I'll trigger the 'updatecfg' job to issue a git pull and reload configuration...
Custom configuration repository successfully updated
@parsley: Configuration reloaded successfully
... done
</code></pre>
<p><strong>5.</strong> Check and verify that the <em>lists</em> plugin is now available:</p>
<pre><code>parsley:
-list lists

Bishop Gopherbot:
I don't have any lists
</code></pre>
<p>Simple as that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-dev-environment"><a class="header" href="#container-dev-environment">Container Dev Environment</a></h1>
<p>The most straight-forward and widely available way to set up a development environment for your robot is to take advantage of the <a href="https://quay.io/repository/lnxjedi/gopherbot-dev?tab=info">gopherbot-dev</a> container used in <a href="extensiondev/../botsetup/Plugin.html">Quick Setup</a>:</p>
<p><strong>1.</strong> Create a new <code>&lt;botname&gt;-dev</code> directory and copy the robot's <code>.env</code> file to <code>&lt;botname&gt;-dev/environment</code></p>
<blockquote>
<p>I think I've repeated this at least a dozen times, but be sure <code>GOPHER_PROTOCOL</code> is commented out (or missing altogether) in the environment file. Not only does this prevent connecting a second robot with the same name and credentials to your team chat, but if you examine the default distributed configuration <code>yaml</code> files, you'll see that it disables certain scheduled jobs and modifies the robot's behavior in other ways more suitable for a dev environment.</p>
</blockquote>
<p><strong>2.</strong> From this directory, run the <code>gopherbot-dev</code> container, this time supplying the robot's environment. Using &quot;clu&quot; as an example:</p>
<pre><code>$ docker run -p 127.0.0.1:3000:3000 --name clu-dev --rm --env-file environment quay.io/lnxjedi/gopherbot-dev:latest
</code></pre>
<blockquote>
<p>Note that you can also find a generic <code>run-robot.sh</code> script to use for this in <a href="https://github.com/lnxjedi/gopherbot/blob/main/resources/containers/dev/run-robot.sh">github.com/lnxjedi/gopherbot/resources/containers/dev</a>.</p>
</blockquote>
<p><strong>3.</strong> Now open your browser and connect to <a href="http://127.0.0.1:3000">http://127.0.0.1:3000</a>, where you'll be presented with the <a href="https://github.com/eclipse-theia/theia">Theia</a> interface.</p>
<p>I find a three-pane layout most convenient; the top pane where code and configuration can be edited, and two terminal windows - one for running the robot in terminal mode, and one for running <code>gopherbot</code> CLI commands.</p>
<p><strong>4.</strong> In a terminal window, run <code>gopherbot</code>. The bootstrap plugin will clone your robot's configuration repository, and start the robot in terminal mode:</p>
<pre><code>$ gopherbot
2020/12/01 17:38:01 Initialized logging ...
...
general: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 625 killed;
c:general/u:alice -&gt;
</code></pre>
<p>When you're finished with your robot, you can press <code>&lt;ctrl-c&gt;</code> to stop and remove the dev container, or from another window: <code>$ docker stop clu-dev</code>. Later sections will discuss how to push changes in this environment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-install-dev-environment"><a class="header" href="#local-install-dev-environment">Local Install Dev Environment</a></h1>
<p>If you've <a href="extensiondev/../install/ManualInstall.html">installed Gopherbot</a> on a Linux host or VM, you can just create an empty directory under your home directory, add your <code>.env</code> file (without <code>GOPHER_PROTOCOL</code>), and start <strong>gopherbot</strong> in terminal mode - letting the <strong>bootstrap</strong> plugin retrieve the rest of your robot:</p>
<pre><code>[parse@hakuin ~]$ mkdir clu-dev
[parse@hakuin ~]$ cd clu-dev/
[parse@hakuin clu-dev]$ vim .env # paste, save
[parse@hakuin clu-dev]$ ln -s /opt/gopherbot/gopherbot .
[parse@hakuin clu-dev]$ ./gopherbot 
2020/12/02 14:28:46 Initialized logging ...
2020/12/02 14:28:46 Loaded initial private environment from '.env'
...
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 11337 killed;
c:general/u:alice -&gt;
</code></pre>
<p>Once you're robot has bootstrapped to the directory and created the <code>custom/</code> subdirectory, you can press <code>&lt;ctrl-d&gt;</code> to exit the robot, or open another terminal window in the same directory to use <strong>Gopherbot's</strong> CLI commands, discussed in the next section. When you're finished, it's good practice to remove all but the <code>.env</code> file and <code>gopherbot</code> symlink, to avoid working with a stale repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-operation"><a class="header" href="#cli-operation">CLI Operation</a></h1>
<p>The <code>gopherbot</code> binary can run as both a daemon and a command-line interface, mainly used for generating encrypted secrets. This section discusses running <strong>Gopherbot's</strong> CLI utility commands.</p>
<h2 id="setting-up-for-cli-operation"><a class="header" href="#setting-up-for-cli-operation">Setting up For CLI Operation</a></h2>
<p>You'll need to create a dev environment, using either a <a href="extensiondev/devenv.html">container</a> or <a href="extensiondev/local.html">local install</a>, then run <code>gopherbot</code> at least once to run the bootstrap plugin and populate the <code>custom/</code> subdirectory. Once bootstrapping finishes, you can press <code>&lt;ctrl-d&gt;</code> to exit from the robot, or open a separate terminal window in the same directory.</p>
<blockquote>
<p>Note that the following examples assume <code>gopherbot</code> in the current directory is a symlink to <code>/opt/gopherbot/gopherbot</code>, and commands start with <code>./gopherbot ...</code>. If you're using the container web dev environment, you can just use <code>gopherbot</code>, since it'll be in your <code>$PATH</code>.</p>
</blockquote>
<h2 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h2>
<h3 id="help"><a class="header" href="#help">Help</a></h3>
<pre><code class="language-shell">$ ./gopherbot --help
Usage: gopherbot [options] [command [command options] [command args]]
  &quot;command&quot; can be one of:
	decrypt - decrypt a string or file
	encrypt - encrypt a string or file
...
</code></pre>
<h3 id="encrypting-and-decrypting-strings"><a class="header" href="#encrypting-and-decrypting-strings">Encrypting and Decrypting Strings</a></h3>
<p>You'll use this later in the exercise on adding plugins:</p>
<pre><code class="language-shell">$ ./gopherbot encrypt MyLousyPassword
+LrXWBPZrbO0aJVI/lCKHR81mcD9v0LvrHojvU/qDia2lpjFNN/t+D0e5g==
$ ./gopherbot decrypt +LrXWBPZrbO0aJVI/lCKHR81mcD9v0LvrHojvU/qDia2lpjFNN/t+D0e5g==
MyLousyPassword
</code></pre>
<h3 id="encrypting-and-decrypting-files"><a class="header" href="#encrypting-and-decrypting-files">Encrypting and Decrypting Files</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encrypting-secrets"><a class="header" href="#encrypting-secrets">Encrypting Secrets</a></h1>
<p>Once you've set up CLI access, you can use the <code>gopherbot</code> binary to encrypt various secrets:</p>
<pre><code class="language-shell">$ gopherbot encrypt foobarbaz
UK+T6/HocaR9AAD8Ty2giHdNR3r03pbffpah/rk+MZumPK4Y3A==
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-terminal-connector"><a class="header" href="#using-the-terminal-connector">Using the Terminal Connector</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="administrator-commands"><a class="header" href="#administrator-commands">Administrator Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-custom-extensions-for-your-robot"><a class="header" href="#writing-custom-extensions-for-your-robot">Writing Custom Extensions for Your Robot</a></h1>
<p>This chapter documents writing custom script extensions for your robot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<p>This section provides guidance and suggestions for making your extensions more usable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help-for-invalid-command-syntax"><a class="header" href="#help-for-invalid-command-syntax">Help for Invalid Command Syntax</a></h1>
<p>One pattern for robot commands (especially for robots managing infrastructure) is to use a CLI-like <code>&lt;verb&gt; (... args)</code> or <code>&lt;verb-noun&gt; (... args)</code> structure - e.g. <code>build-app</code>. These kinds of commands can have arbitrarily complex syntax, however; <code>build-app (branch) (--skip-checks)</code>, or multiple forms of the command. To mimic a CLI environment, you can take advantage of the first-match behavior in the list of <code>CommandMatchers</code> for a given plugin:</p>
<pre><code class="language-yaml">CommandMatchers:
- Regex: '(?i:build-?app(?: (\w[\w-]*))?(?: (--skip-checks))?)'
  Command: build
- Regex: '(?i:build-?app\b.*)'
  Command: buildhelp
</code></pre>
<p>Then, add code to your plugin to handle the <code>buildhelp</code> command (ruby example):</p>
<pre><code class="language-ruby">when &quot;buildhelp&quot;
    bot_alias = bot.GetBotAttribute(&quot;alias&quot;)
    bot.Say(&quot;Usage for build-app:&quot;)
    bot.Say(&quot;#{bot_alias}build-app (branch) (--skip-checks)&quot;, &quot;fixed&quot;)
</code></pre>
<p>The more complex forms of <code>build-app</code> should come first, if none of them match, it will fall-through to <code>buildhelp</code> command.</p>
<p>NOTE:</p>
<ul>
<li>If a user command matches multiple plugins, the robot will complain and do nothing; the first-match behavior only applies within a single list of <code>CommandMatchers</code></li>
<li>The help message should probably match the configured keyword help</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-gopherbot"><a class="header" href="#configuring-gopherbot">Configuring Gopherbot</a></h1>
<blockquote>
<p>NOTE: This chapter has not been updated for <strong>Gopherbot</strong> version 2, but has reference material that may be of use when examining default and standard configuration.</p>
</blockquote>
<p><strong>Gopherbot</strong> has very powerful and flexible configuration capabilities based on <em>yaml</em> templates. The core concept is simple; <strong>Gopherbot</strong> ships with default configuration in the <code>conf/</code> directory of the installation archive, and individual robots can modify and override the default configuration with environment variables and custom configuration files. This chapter examines the configuration system in detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gopherbot-environment-variables"><a class="header" href="#gopherbot-environment-variables">Gopherbot Environment Variables</a></h1>
<p><strong>Gopherbot</strong> makes extensive use of environment variables, both for configuring the robot and plugins, and for providing parameters to external scripts. This article describes the various environment variables and their use; for the environment applicable to a given running task, see <a href="pipelines/TaskEnvironment.html">per-task environment</a>.</p>
<h2 id="robot-execution-environment"><a class="header" href="#robot-execution-environment">Robot Execution Environment</a></h2>
<p>Certain environment variables can be supplied to the running <strong>Gopherbot</strong> process to configure and/or bootstrap your robot. These environment variables can be set by:</p>
<ul>
<li><code>systemd</code> - Not recommended; while systemd can provide environment variables to your robot, it's very insecure and will allow local users on the system to view the values</li>
<li><code>docker</code>, <code>docker-compose</code> or <a href="https://kubernetes.io">Kubernetes</a> - these and other container environments provide more secure means of providing environment variables to containers</li>
<li><code>$GOPHER_HOME/.env</code> - the most secure means of providing environment variables to your robot is creating a <code>.env</code> file in <code>$GOPHER_HOME</code>, outside of any git repository, mode <code>0600</code></li>
</ul>
<p>The last two options are recommended for production deployments of a <strong>Gopherbot</strong> robot.</p>
<h3 id="start-up-environment"><a class="header" href="#start-up-environment">Start-up Environment</a></h3>
<p>The following values can be provided to your robot on start-up:</p>
<ul>
<li><code>GOPHER_ENCRYPTION_KEY</code> - 32+ character encryption key used for decrypting the <code>binary-encrypted-key</code></li>
<li><code>GOPHER_CUSTOM_REPOSITORY</code> - clone URL for the robot's custom configuration, used in bootstrapping</li>
<li><code>GOPHER_CUSTOM_BRANCH</code> - branch to use if other than <code>master</code></li>
<li><code>GOPHER_LOGFILE</code> - where to write out a log file</li>
<li><code>GOPHER_CONFIGDIR</code> - absolute or relative path to configuration directory</li>
<li><code>GOPHER_DEPLOY_KEY</code> - ssh deploy key for cloning the custom repository</li>
</ul>
<p>For the optional <code>state</code> and <code>private</code> repositories, the included jobs will use the <code>GOPHER_CUSTOM_REPOSITORY</code> value with <code>s/gopherbot/state/</code> and <code>s/gopherbot/private/</code> (same branch). If desired, the values can also be supplied:</p>
<ul>
<li><code>GOPHER_STATE_REPOSITORY</code> - repository holding state, normally just a file-backed brain, defaults to <code>$GOPHER_CUSTOM_REPOSITORY</code> and <code>robot-state</code> branch</li>
<li><code>GOPHER_STATE_BRANCH</code> - if <code>GOPHER_STATE_REPOSITORY</code> is set, this defaults to <code>master</code>, otherwise <code>robot-state</code></li>
<li><code>GOPHER_PRIVATE_REPOSITORY</code> - non-public repository with <code>environment</code>, for dev only</li>
<li><code>GOPHER_PRIVATE_BRANCH</code> - branch to use if other than <code>master</code></li>
</ul>
<h3 id="configuration-environment-variables"><a class="header" href="#configuration-environment-variables">Configuration Environment Variables</a></h3>
<p><strong>Gopherbot</strong> normally takes almost all of it's configuration from the collection of <code>*.yaml</code> files in the custom configuration directory, but for easy flexibility, a collection of environment variables are referenced in the default configuration. These are some of the values that are expanded; the actual configuration files are the definitive reference.</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - used to select a non-default protocol (e.g. &quot;terminal&quot;)</li>
<li><code>GOPHER_LOGLEVEL</code> - error, warn, info, debug, trace</li>
<li><code>GOPHER_BOTNAME</code> - the name the robot will answer to, e.g. &quot;floyd&quot;</li>
<li><code>GOPHER_ALIAS</code> - the one-character alias for the robot, e.g. &quot;;&quot;</li>
<li><code>GOPHER_BOTMAIL</code> - the robot's email address</li>
<li><code>GOPHER_BOTFULLNAME</code> - the robot's full name</li>
<li><code>GOPHER_HISTORYDIR</code> - directory for storing file-based historical job logs</li>
<li><code>GOPHER_WORKSPACE</code> - workspace directory where e.g. build jobs clone and run</li>
<li><code>GOPHER_BRAIN</code> - non-default brain provider to use</li>
<li><code>GOPHER_STATEDIR</code> - default dir for storing state, normally just the brain</li>
<li><code>GOPHER_BRAIN_DIRECTORY</code> - directory where file-based memories are stored, overrides above</li>
<li><code>GOPHER_JOBCHANNEL</code> - where jobs run by default if not otherwise specified</li>
<li><code>GOPHER_TIMEZONE</code> - UNIX tz, e.g. &quot;America/New_York&quot; (default)</li>
</ul>
<h2 id="external-script-environment"><a class="header" href="#external-script-environment">External Script Environment</a></h2>
<p><strong>Gopherbot</strong> always scrubs the environment when executing tasks, so environment variables set on execution are not automatically passed to child processes. The only environment variables that are passed through from original execution are:</p>
<ul>
<li><code>HOME</code> - this should rarely be used; for portable robots, use <code>GOPHER_HOME</code>, instead</li>
<li><code>HOSTNAME</code></li>
<li><code>LANG</code></li>
<li><code>PATH</code> - this should be used with care since it can make your robot less portable</li>
<li><code>USER</code></li>
</ul>
<p>In addition to the above passed-through environment vars, <strong>Gopherbot</strong> supplies the following environment variables to external scripts:</p>
<ul>
<li><code>GOPHER_INSTALLDIR</code> - absolute path to the gopherbot install, normally <code>/opt/gopherbot</code></li>
<li><code>RUBYLIB</code> - path for Ruby <code>require 'gopherbot_v1'</code>, normally <code>/opt/gopherbot/lib</code></li>
<li><code>PYTHONPATH</code> - path for Python <code>import</code>, normally <code>/opt/gopherbot/lib</code></li>
</ul>
<h2 id="automatic-environment-variables"><a class="header" href="#automatic-environment-variables">Automatic Environment Variables</a></h2>
<p>During startup, <strong>Gopherbot</strong> will examine it's environment and potentially set values for a few environment variables to support the bootstrap and setup plugins, and simplify common operations.</p>
<p>First, <strong>Gopherbot</strong> will check for custom configuration or the presence of a <code>GOPHER_CUSTOM_REPOSITORY</code> environment variable. In the absence of either, the following will be automatically set:</p>
<ul>
<li><code>GOPHER_UNCONFIGURED</code> - set true</li>
<li><code>GOPHER_LOGFILE</code> - set to &quot;robot.log&quot; if not already set</li>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;terminal&quot; so the default robot will start</li>
</ul>
<p>If no custom configuration is present but <code>GOPHER_CUSTOM_REPOSITORY</code> is set:</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;nullconn&quot;, the null connector, to allow the bootstrap plugin to bootstrap your robot</li>
</ul>
<p>If the robot is configured but <code>GOPHER_PROTOCOL</code> isn't set:</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;terminal&quot; for local operations</li>
<li><code>GOPHER_LOGFILE</code> - set to &quot;robot.log&quot; if not already set</li>
</ul>
<p>Finally, if encryption is initialized on start-up, <code>GOPHER_ENCRYPTION_INITIALIZED</code> will be set to <code>true</code>, regardless of whether the robot is configured.</p>
<h2 id="pipeline-environment-variables"><a class="header" href="#pipeline-environment-variables">Pipeline Environment Variables</a></h2>
<p>The following environment variable are set for all pipelines, whether started by a plugin or a job:</p>
<ul>
<li><code>GOPHER_CHANNEL</code> - the channel where the plugin/job is providing output</li>
<li><code>GOPHER_USER</code> - the user whose message created the pipeline (if any)</li>
<li><code>GOPHER_PROTOCOL</code> - the name of the protocol in use, e.g. &quot;slack&quot;</li>
<li><code>GOPHER_PIPE_NAME</code> - the name of the plugin or job that started the pipeline</li>
<li><code>GOPHER_TASK_NAME</code> - the name of the running task</li>
<li><code>GOPHER_PIPELINE_TYPE</code> - the event type that started the current pipeline, one of:
<ul>
<li><code>plugCommand</code> - direct robot command, not <code>run job ...</code></li>
<li><code>plugMessage</code> - ambient message matched</li>
<li><code>catchAll</code> - catchall plugin ran</li>
<li><code>jobTrigger</code> - triggered by a JobTrigger</li>
<li><code>scheduled</code> - started by a ScheduledTask</li>
<li><code>jobCommand</code> - started from <code>run job ...</code> command</li>
</ul>
</li>
</ul>
<p>The following are also supplied whenever a job is run:</p>
<ul>
<li><code>GOPHER_JOB_NAME</code> - the name of the running job</li>
<li><code>GOPHER_START_CHANNEL</code> - the channel where the job was started</li>
<li><code>GOPHER_REPOSITORY</code> - the extended namespace from <code>repositories.yaml</code>, if any</li>
<li><code>GOPHER_LOG_LINK</code> - link to job log, if non-ephemeral</li>
<li><code>GOPHER_LOG_REF</code> - log reference used for email log and tail log commands</li>
</ul>
<p>The following are set at the end of the main pipeline, and can be referenced in final and fail tasks:</p>
<ul>
<li><code>GOPHER_FINAL_TASK</code> - name of final task that ran in the pipeline</li>
<li><code>GOPHER_FINAL_TYPE</code> - type of last task to run, one of &quot;task&quot;, &quot;plugin&quot;, &quot;job&quot;</li>
<li><code>GOPHER_FINAL_COMMAND</code> - if type == &quot;plugin&quot;, set to the plugin command</li>
<li><code>GOPHER_FINAL_ARGS</code> - space-separated list of arguments to final task</li>
<li><code>GOPHER_FINAL_DESC</code> - <code>Description:</code> of final task</li>
<li><code>GOPHER_FAIL_CODE</code> - numeric return value if final task failed</li>
<li><code>GOPHER_FAIL_STRING</code> - string value of robot.TaskRetVal returned</li>
</ul>
<p>Pipelines and tasks that have <code>Homed: true</code> and/or <code>Privileged: true</code> may also get:</p>
<ul>
<li><code>GOPHER_HOME</code> - absolute path to the startup directory for the robot, relative paths are relative to this directory; unset if <code>cwd</code> can't be determined</li>
<li><code>GOPHER_WORKSPACE</code> - the workspace directory (normally relative to <code>GOPHER_HOME</code>)</li>
<li><code>GOPHER_CONFIGDIR</code> - absolute path to custom configuration directory, normally <code>$GOPHER_HOME/custom</code></li>
</ul>
<h3 id="gopherci-environment-variables"><a class="header" href="#gopherci-environment-variables">GopherCI Environment Variables</a></h3>
<p>In addition to the environment variables set by the <strong>Gopherbot</strong> engine, the <code>localbuild</code> GopherCI builder sets the following environment variables that can be used to modify pipelines:</p>
<ul>
<li><code>GOPHERCI_BRANCH</code> - the branch being built (<code>GOPHER_REPOSITORY</code> is set by <code>ExtendNamespace</code>)</li>
<li><code>GOPHERCI_DEPBUILD</code> - set to &quot;true&quot; if the build was triggered by a dependency</li>
<li><code>GOPHERCI_DEPREPO</code> - the updated repository that triggered this build</li>
<li><code>GOPHERCI_DEPBRANCH</code> - the updated branch</li>
<li><code>GOPHERCI_CUSTOM_PIPELINE</code> - pipeline being run if other than &quot;pipeline&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-file-loading"><a class="header" href="#configuration-file-loading">Configuration File Loading</a></h1>
<p><strong>Gopherbot</strong> uses <strong>YAML</strong> for it's configuration files, and Go text templates for expanding the files it reads. Any time <strong>Gopherbot</strong> loads a configuration file, say <code>conf/robot.yaml</code>, it first looks for the file in the installation directory, and loads and expands that file if found. Next it looks for the same file in the custom configuration directory; if found, it loads and expands that file, then recursively merges the two data structures:</p>
<ul>
<li>Map values merge and override</li>
<li>Array values are replaced or appended</li>
</ul>
<p>To illustrate with an example, take the following two hypothetical excerpts from <code>terminal.yaml</code>:</p>
<p>Default from the install archive:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: general
  Channels:
  - random
  - general
  StartUser: alice
UserRoster:
- UserName: &quot;alice&quot;
  UserID: &quot;u0001&quot;
</code></pre>
<p>Custom local configuration:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
AppendUserRoster:
- UserName: &quot;bob&quot;
  UserID: &quot;u0002&quot;
</code></pre>
<p>The resulting configuration would be:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
  StartUser: alice
UserRoster:
- UserName: &quot;alice&quot;
  UserID: &quot;u0001&quot;
- UserName: &quot;bob&quot;
  UserID: &quot;u0002&quot;
</code></pre>
<h2 id="template-expansion"><a class="header" href="#template-expansion">Template Expansion</a></h2>
<p><strong>Gopherbot</strong> uses standard <a href="https://golang.org/pkg/text/template">Go text templates</a> for expanding the configuration files it reads. In addition to the stock syntactic elements, the following functions and methods are available:</p>
<h3 id="the-env-function"><a class="header" href="#the-env-function">The <code>env</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; }}
</code></pre>
<p>This would expand to the value of the <code>GOPHER_ALIAS</code> environment variable.</p>
<h3 id="the-default-function"><a class="header" href="#the-default-function">The <code>default</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; | default &quot;;&quot; }}
</code></pre>
<p>The <code>default</code> function takes two arguments, and returns the first argument if it's length is &gt; 0, the second argument otherwise. The example would expand to the value of the <code>GOPHER_ALIAS</code> environment variable if set, or <code>;</code> otherwise.</p>
<h2 id="the-decrypt-function"><a class="header" href="#the-decrypt-function">The <code>decrypt</code> function</a></h2>
<pre><code>ProtocolConfig:
  SlackToken: xoxb-18000000000-470000000000-{{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<p>To make it safe to store secret values in configuration, administrators can send a direct message to the robot requesting encryption, e.g.:</p>
<pre><code>c:(direct)/u:alice -&gt; encrypt MyLousyPassword
(dm:alice): RPzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx+9rf==
</code></pre>
<p>The encrypted value can then be pasted in to the <code>decrypt</code> function. See the section on <em>encryption</em> for more information.</p>
<p><strong>NOTE:</strong> In the example, the common, low-entropy portion of a <em>slack</em> token is left as-is, and only the high-entropy portion of the token is encrypted, to prevent attacks where a portion of the encrypted value is known.</p>
<h2 id="the-include-method"><a class="header" href="#the-include-method">The <code>.Include</code> method</a></h2>
<pre><code>{{ .Include &quot;terminal.yaml&quot; }}
</code></pre>
<p><code>.Include</code> is a <em>method</em> on the configuration file object, which is either an install file or a custom file. If the above example is present in the installed <code>conf/robot.yaml</code>, it will include <em>only</em> the installed <code>conf/terminal.yaml</code>, if present, and ignore that file if it's also present in the custom directory.</p>
<p>Note that <code>.Include</code>'d files are also expanded as templates in the same manner.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="job-and-plugin-configuration"><a class="header" href="#job-and-plugin-configuration">Job and Plugin Configuration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>TODO: docs on using CLI commands to dump yaml.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gopherbot-pipelines"><a class="header" href="#gopherbot-pipelines">Gopherbot Pipelines</a></h1>
<p>Whenever a chat message matches a command plugin, or your robot runs a job, a new pipeline is created; or, more accurately, <em>three</em> pipelines are created:</p>
<ul>
<li>The <strong>primary</strong> pipeline does all the real work of the job or plugin, and stops on any failed task.</li>
<li>The <strong>final</strong> pipeline is responsible for cleanup work, and all tasks in this pipeline always run, in reverse of the order added; see the section on <a href="pipelines/final.html">the final pipeline</a> for more information.</li>
<li>The <strong>fail</strong> pipeline runs only after a failure in the primary pipeline.</li>
</ul>
<blockquote>
<p>NOTE: Jobs, plugins and simple tasks are all instances of a 'task'; the main differences are that 'simple' tasks are meant to be the &quot;worker bees&quot; for job and plugin tasks, which create new pipeline sets. A simple task never creates a new pipeline (though it may add tasks to the current set), it only serves as an element for pipelines created by jobs or plugins.</p>
</blockquote>
<h2 id="job-plugin-and-task-configuration"><a class="header" href="#job-plugin-and-task-configuration">Job, Plugin and Task Configuration</a></h2>
<p>Every job, plugin and task needs to be listed in <code>robot.yaml</code> (or an included file). See the chapter on <a href="pipelines/../Configuration.html">robot configuration</a> for more about this topic.</p>
<h2 id="pipeline-state"><a class="header" href="#pipeline-state">Pipeline State</a></h2>
<p>The main state items that connect one element in a pipeline to the next are:</p>
<ul>
<li>The <strong>robot</strong> object, generated at the start of the pipeline - this includes a channel where the pipeline is being run, and if started interactively, the user that issued the command.</li>
<li>The pipeline <strong>environment</strong> - these are environment variables provided to external scripts, or retrievable with <code>GetParameter(...)</code> in the <strong>Go</strong> API. Any task in the pipeline can also use the <code>SetParameter(...)</code> API call to set/update the environment for tasks that follow in the pipeline; for instance, the <code>ssh-init</code> task will set <code>$SSH_OPTIONS</code> that should be used with ssh commands later in the pipeline. See the section on <a href="pipelines/../Environment-Variables.html">environment variables</a>.</li>
<li>The pipeline <strong>working directory</strong> and it's contents - normally used for software builds, this is generally set early in the pipeline with <code>SetWorkingDirectory</code>, with a path relative to <code>$GOPHER_WORKSPACE</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-primary-pipeline"><a class="header" href="#the-primary-pipeline">The Primary Pipeline</a></h1>
<p>For those with previous experience with CI/CD and pipelines, the <strong>primary</strong> pipeline is analogous to the pipelines you've worked with before. Each task in the pipeline runs until a task fails or the pipeline completes successfully.</p>
<p>Unlike statically configured pipelines, once a job or plugin starts a pipeline, the <code>AddTask</code> and <code>AddCommand</code> API calls are used to add tasks to this pipeline, and can vary, for instance, based on environment variables such as <code>$GOPHERCI_BRANCH</code> in a software build.</p>
<p>In the case of most plugins, there is only a single task in the primary pipeline, the plugin itself. In the case of most jobs, the job task normally adds tasks to each of the pipelines and then exits successfully, at which point the next task in the pipeline runs.</p>
<h2 id="initializing-the-environment"><a class="header" href="#initializing-the-environment">Initializing the Environment</a></h2>
<p>There are a few differences between job and plugin pipelines, one of which is the initial environment. For jobs, any parameters set for the job are propagated to the environment for the entire pipeline; plugins must use the <code>SetParameter(...)</code> API call to propagate values. Environment variables are more thoroughly explained in the section on <a href="pipelines/TaskEnvironment.html">task environment variables</a>.</p>
<h2 id="populating-the-pipeline-set"><a class="header" href="#populating-the-pipeline-set">Populating the Pipeline Set</a></h2>
<p>During the execution of the primary pipeline, the <code>Add*</code>, <code>Final*</code> and <code>Fail*</code> family of API calls can be used to populate the pipeline set; these calls will fail if used in the final and fail pipelines:</p>
<ul>
<li><code>AddTask</code>, <code>FinalTask</code> and <code>FailTask</code> add simple tasks to the pipeline set.</li>
<li><code>AddJob</code> adds another job to the pipeline, optionally with arguments; note, however, that this creates an entirely new child pipeline, with a new environment not inherited from the parent. If the child job pipeline fails, the parent pipeline also fails.</li>
<li><code>AddCommand</code>, <code>FinalCommand</code> and <code>FailCommand</code> are mostly special-purpose and generally little used, they add plugin commands to the respective pipelines in the set. One use is in wrapping existing plugins with shortcut commands in another plugin - for instance, when I say to my robot &quot;dinner?&quot;, it calls <code>AddCommand &quot;lists&quot; &quot;pick a random item from the dinner meals list&quot;</code>; see <a href="https://github.com/parsley42/floyd-gopherbot/blob/master/plugins/util.sh">Floyd's util plugin</a>. Adding plugins to the pipeline does <em>not</em> create a new child pipeline.</li>
</ul>
<h2 id="order-of-task-execution"><a class="header" href="#order-of-task-execution">Order of Task Execution</a></h2>
<p>The normal case is having an initial job or plugin task that fully populates the primary, final and fail pipelines. There are some tasks, however, that add one or more additional tasks to the pipeline set. The final and fail pipelines just grow in length, but the behavior of the primary pipeline is special:</p>
<ul>
<li>If tasks are added in the last task of the pipeline, the added tasks are just appended and the pipeline runs them as normal.</li>
<li>If the tasks are added BEFORE the final task in the pipeline, <strong>all</strong> of the added tasks run before the next task in the original pipeline run. As an example:</li>
</ul>
<p><strong>Job A</strong>:</p>
<pre><code>AddTask A
AddTask B
AddTask C
AddTask D
</code></pre>
<p><strong>Task C</strong>:</p>
<pre><code>AddTask E
AddTask F
</code></pre>
<p>Assuming none of the other tasks add additional tasks, they will run in the order: A, B, C, E, F, D. This allows for slightly more complicated tasks that may, for instance, have several sub-steps in setting up the working directory, and need to all complete before the next task in the job proceeds.</p>
<p>In the case of <strong>GopherCI</strong>, the <code>localbuild</code> job adds (among others) the following tasks:</p>
<ul>
<li>&quot;startbuild&quot; - a task to provide information about the build that is starting</li>
<li>&quot;run-pipeline&quot; - a task that runs a pipeline specified in the repository</li>
<li>&quot;finishbuild&quot; - a task to report on how the build ended</li>
</ul>
<p>The contents of <code>&lt;repository&gt;/.gopherci/pipeline.sh</code> correspond most closely to the contents of e.g. <code>&lt;repository&gt;/.travis.yml</code> - they define the build, test and deploy tasks for the repository-specific pipeline. The task execution order for the primary pipeline insures that all the tasks in the repository pipeline are run before any other tasks added by the build job.</p>
<blockquote>
<p>NOTE: &quot;finishbuild&quot; is actually added to the final pipeline so it always runs, however the example still holds.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-final-pipeline"><a class="header" href="#the-final-pipeline">The Final Pipeline</a></h1>
<p>The final pipeline always runs after the primary pipeline, regardless of whether it failed, and every task in the pipeline runs, regardless of failures. Unlike the primary and fail pipelines, the tasks in the final pipeline run in <strong>FILO</strong> order - first in, last out. This creates a kind of &quot;bracketing&quot; behavior; the &quot;ssh-init&quot; task, for instance, adds a final task to kill the <code>ssh-agent</code> at the end of the pipeline. If the &quot;ssh-init&quot; task runs first, the &quot;kill&quot; task will run last; if a following task performs some kind of initialization / setup on a remote host, and adds a final task to clean up, this insures that the remote cleanup occurs before the ssh-agent is killed.</p>
<p>Note that there are several <a href="pipelines/../Environment-Variables.html">environment variables</a> that are set at the end of the primary pipeline that can be examined and used for reporting in the final pipeline. For an example of this, see the <a href="https://github.com/lnxjedi/gopherbot/blob/master/tasks/finishbuild.sh">finishbuild</a> task that runs in the final pipeline of a <strong>GopherCI</strong> build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fail-pipeline"><a class="header" href="#the-fail-pipeline">The Fail Pipeline</a></h1>
<p>The fail pipeline is a straight-forward pipeline of actions to take in the event of a failure in the primary pipeline. There are a host of <a href="pipelines/../Environment-Variables.html">environment variables</a> that are set in the event of a primary pipeline failure, and fail tasks can use these for reporting the nature of the failure. Every task in the fail pipeline runs, regardless of individual task failures, in the order they were added.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Note on Parameters and Environment Variables: The <strong>Gopherbot</strong> documentation uses <em>environment variable</em> and <em>parameter</em> somewhat interchangeably; this is due to configured and set parameters being made available to external scripts as environment variables.</p>
</blockquote>
<h1 id="task-environment-variables"><a class="header" href="#task-environment-variables">Task Environment Variables</a></h1>
<p>Each time a task is run, a custom environment is generated for that task. For external tasks such as <code>ssh-init</code>, these values are actually set as environment variables for the process. <em>Go</em> tasks access these values with the <code>GetParameter()</code> API call.</p>
<p>The precedence of environment variables seen by a given task is determined by the algorithm in <code>bot/run_pipelines.go:getEnvironment()</code>. The various environment sources are listed here, in order from lowest to highest priority.</p>
<h2 id="namespace-parameters"><a class="header" href="#namespace-parameters">NameSpace Parameters</a></h2>
<p>Various tasks, plugins and jobs can be configured to share parameters by defining <code>NameSpaces</code> in <code>conf/robot.yaml</code>, and setting the <code>NameSpace</code> parameter for a given task to the shared namespace. For instance, the <code>ssh-init</code> task and <code>ssh-admin</code> plugin both get access to the <code>BOT_SSH_PHRASE</code> environment variable via the <code>ssh</code> namespace.</p>
<h2 id="task-parameters"><a class="header" href="#task-parameters">Task Parameters</a></h2>
<p>Individual tasks, plugins and jobs can also have <code>Parameters</code> defined. If present, these override any parameters set for a shared namespace.</p>
<h2 id="pipeline-parameters"><a class="header" href="#pipeline-parameters">Pipeline Parameters</a></h2>
<p>Any time a job is run, the parameters for that job (including those inherited from it's namespace, if any) initialize the environment variables for the pipeline as a whole, and are available to all tasks in the pipeline. Parameters set in the pipeline override task and namespace parameters for any tasks run in the pipeline, allowing specific job parameters to override defaults for the task.</p>
<h3 id="plugins-and-pipelines"><a class="header" href="#plugins-and-pipelines">Plugins and Pipelines</a></h3>
<p>Plugins can also start a new pipeline, but plugin parameters are not automatically added to the pipeline. Plugins can, however, explicity publish parameters to the pipeline with the <code>SetParameter()</code> API call.</p>
<p>Plugin tasks can also be added to a pipeline with the <code>AddCommand()</code>, <code>FinalCommand()</code> and <code>FailCommand()</code> API calls. Unlike tasks, plugins only inherit parameters from the pipeline when they are configured with <code>Privileged: true</code> in <code>robot.yaml</code>.</p>
<h2 id="repository-parameters"><a class="header" href="#repository-parameters">Repository Parameters</a></h2>
<p>If a given Job calls the <code>ExtendNamespace()</code> API to start a build, the parameters for that repository set in <code>conf/repositories.yaml</code> overwrite any values in the current pipeline, which then behave as <strong>Pipeline Parameters</strong> as above.</p>
<h2 id="setparameter"><a class="header" href="#setparameter">SetParameter()</a></h2>
<p>Parameters set with the <code>SetParameter()</code> API call overwrite the current value for a pipeline. Parameters set with <code>SetParameter()</code> have the highest priority, and will always apply to later tasks in the pipeline.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="included-tasks"><a class="header" href="#included-tasks">Included Tasks</a></h1>
<blockquote>
<p>NOTE: This section is incomplete!</p>
</blockquote>
<p><strong>Gopherbot</strong> ships with a selection of available pipeline tasks, listed here alphabetically. Note that the given examples use <strong>bash</strong> syntax for simplicity; for <strong>ruby</strong> and <strong>python</strong> see the chapter on the <a href="pipelines/../api/API-Introduction.html">Gopherbot API</a>.</p>
<hr />
<p><strong>email-log</strong> - <em>privileged</em></p>
<p>Usage:</p>
<ul>
<li><code>FinalTask email-log joe@example.com emily@example.com frank bob</code></li>
<li><code>FinalTask email-log</code></li>
</ul>
<p>Normally used in the <strong>fail</strong> and <strong>final</strong> pipelines, emails a copy of the pipeline log. Can also be used with <code>AddTask</code> in the main pipeline, but content will be incomplete.</p>
<p><em>Notes on the current implementation:</em><br />
The email function call takes a byte slice for the email body, rather than an <code>io.Reader</code>, meaning the entire body of the message is read in to memory. To limit memory use, <strong>Gopherbot</strong> allocates a 10MB line-based circular buffer, with maximum 16KB-long lines (terminated by <code>\n</code>), and reads the log to that buffer for emailing. Logs that are longer than 10MB will only send the last 10MB of the log, and lines longer than 16KB will be truncated.</p>
<hr />
<p><strong>pause-brain</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask pause-brain</code></p>
<p>Pause brain operations for backups and restores. After half a minute, the brain automatically resumes; best practice is to add <code>resume-brain</code> after the backup/restore task.</p>
<hr />
<p><strong>pause-brain</strong></p>
<p>Usage: <code>AddTask pause &lt;seconds&gt;</code></p>
<p>Causes the pipeline to pause for a number of seconds before proceeding to the next task. Useful when triggering an external process that there's no easy way to poll for completion.</p>
<hr />
<p><strong>restart-robot</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask restart-robot</code></p>
<p>Allow a privileged pipeline to queue a restart of the robot after the pipeline completes. Heavily used by bootstrap and setup plugins. <strong>NOTE:</strong> This behavior means that tasks added after <strong>restart-robot</strong> are actually completed <em>before</em> the restart. In practice, the current pipeline will change the state of the robot, and after restarting a plugin <strong>init</strong> function will check for the state change (e.g. presence of <code>.restore</code> file) and start a new pipeline.</p>
<hr />
<p><strong>resume-brain</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask resume-brain</code></p>
<p>Resume brain functions after backup/restore.</p>
<hr />
<p><strong>robot-quit</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask robot-quit</code></p>
<p>Special purpose task; once called, the robot will exit as soon as all pipelines have completed, and not allow new pipelines to start.</p>
<hr />
<p><strong>rotate-log</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask rotate-log &lt;extension&gt;</code></p>
<p>Useful for e.g. nightly log rotation jobs, when the robot has been started with e.g.: <code>gopherbot -d -l robot.log</code>. For example:</p>
<pre><code>AddTask rotate-log &quot;log.$(date +%a)&quot;
</code></pre>
<p>This would keep daily logs of the form <code>robot.log.Mon</code>, etc.</p>
<hr />
<p><strong>send-message</strong></p>
<p>Usage: <code>AddTask send-message &lt;str&gt; (...)</code></p>
<p>Have the robot send a message in the channel, normally to report status of a build. Can be a single long string, or multiple strings; in the case of multiple strings they will be joined with a space separator.</p>
<hr />
<p><strong>tail-log</strong></p>
<p>Usage: <code>AddTask tail-log</code> or <code>FailTask tail-log</code></p>
<p>Dump the last 2k chars (in even line increments) to the channel. Normally this is used as a <code>FailTask</code> to show the source of the failure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tool-integrations"><a class="header" href="#tool-integrations">Tool Integrations</a></h1>
<p>To simplify using tools like <code>ssh</code> and <code>ansible</code> in your pipeline, <strong>Gopherbot</strong> ships with some predefined pipeline elements detailed in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-ssh"><a class="header" href="#integrating-with-ssh">Integrating with SSH</a></h1>
<p>The <strong>GopherCI</strong> job(s) use <em>ssh</em> tasks for cloning repositories with public keys, and you can also use these tasks in your own pipelines for executing remote tasks.</p>
<h2 id="configuring-ssh"><a class="header" href="#configuring-ssh">Configuring SSH</a></h2>
<p>You start by choosing a passphrase for your robot's ssh keypair - make it something quite long; you shouldn't need to type it more than once. Use the <code>encrypt</code> command (normally with the terminal connector) to produce the encrypted value, and put it in a stanza like the following in your <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">ExternalTasks:
  &quot;ssh-init&quot;:
    Parameters:
    - Name: BOT_SSH_PHRASE
      Value: {{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<h2 id="initializing"><a class="header" href="#initializing">Initializing</a></h2>
<p>Once the robot knows it's passphrase, you can use the <code>generate keypair</code> administrator command to generate a new keypair, which will be stored in <code>$GOPHER_CONFIGDIR/ssh/</code>. The private key is encrypted with the robot's (also encrypted) passphrase, so this can be committed to the repository. The <code>pubkey</code> administrator command will display the robot's public key.</p>
<h2 id="using-in-pipelines"><a class="header" href="#using-in-pipelines">Using in Pipelines</a></h2>
<p>A pipeline using <em>ssh</em> might look something like this:</p>
<pre><code class="language-bash">AddTask ssh-init

AddTask ssh-scan my.remote.host

AddTask exec ssh $SSH_OPTIONS user@my.remote.host &quot;whoami&quot;
</code></pre>
<ul>
<li>The <code>ssh-init</code> task will:
<ul>
<li>Start an <code>ssh-agent</code> and add the robot's key</li>
<li>Use <code>SetParameter</code> to store <code>SSH_AUTH_SOCK</code> and <code>SSH_AGENT_PID</code> in the pipeline</li>
<li>Set <code>SSH_OPTIONS</code> to e.g. <code>-F $GOPHER_CONFIGDIR/ssh/config</code> if the robot has a custom ssh config file</li>
<li>Add a <strong>FinalTask</strong> to kill the <code>ssh-agent</code> when the pipeline finishes</li>
</ul>
</li>
<li><code>ssh-scan</code> insures a host is listed in <code>known_hosts</code>, if desired (this may be unneeded depending on the contents of <code>ssh/config</code>)</li>
<li>The <code>exec</code> task calls ssh as normal, using <code>$SSH_OPTIONS</code> to pick up custom configuration if it exists</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="api-for-plugins-jobs-and-tasks"><a class="header" href="#api-for-plugins-jobs-and-tasks">API for Plugins, Jobs and Tasks</a></h2>
<blockquote>
<p>NOTE: This chapter is badly outdated, mainly because it's missing a lot of information. The documenation for individual API calls, however, should be mostly accurate.</p>
</blockquote>
<p><strong>Gopherbot</strong> provides an object-oriented API for writing your own command plugins, jobs and tasks. With the exception of the <code>bash</code> library, API calls are accessed from methods on a <strong>robot</strong> object. The following sections detail the usage of the various methods.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Gopherbot's functionality can be easily extended by writing plugins in one of several different languages. A single plugin can provide:</p>
<ul>
<li>One or more new commands the robot will understand</li>
<li>Elevation logic for providing extra assurance of user identity</li>
<li>Authorization logic for determining a user's rights to issue various commands</li>
</ul>
<p>This article deals mainly with writing plugins in one of the scripting languages supported by Gopherbot, the most popular means for writing new command plugins. For writing native compiled-in plugins in Go, see <code>gopherbot/main.go</code> and the sample plugins in <code>goplugins/</code>. API documentation for Robot methods is available at:</p>
<p>https://godoc.org/github.com/lnxjedi/gopherbot/bot#Robot</p>
<p>Note that the script plugin API is implemented on top of the native Go API, so that document may also be of use for scripting plugin authors. The file <code>bot/http.go</code>, and the scripting libraries in <code>lib/</code> will illuminate the mapping from the script APIs to the native Go API.</p>
<h1 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="api/Languages.html#plugin-loading-and-precedence">Plugin Loading and Precedence</a></li>
<li><a href="api/Languages.html#default-configuration">Default Configuration</a></li>
<li><a href="api/Languages.html#calling-convention">Calling Convention</a>
<ul>
<li><a href="api/Languages.html#environment-variables">Environment Variables</a></li>
<li><a href="api/Languages.html#reserved-commands">Reserved Commands</a></li>
</ul>
</li>
<li><a href="api/Languages.html#plugin-types-and-calling-events">Plugin Types and Calling Events</a>
<ul>
<li><a href="api/Languages.html#command-plugins">Command Plugins</a></li>
<li><a href="api/Languages.html#authorization-plugins">Authorization Plugins</a></li>
<li><a href="api/Languages.html#elevation-plugins">Elevation Plugins</a></li>
</ul>
</li>
<li><a href="api/Languages.html#using-the-terminal-connector">Using the Terminal Connector</a></li>
<li><a href="api/Languages.html#plugin-debugging">Plugin Debugging</a>
<ul>
<li><a href="api/Languages.html#debug-plugin-command">Debug Plugin Command</a></li>
<li><a href="api/Languages.html#dump-plugin-command">Dump Plugin Command</a></li>
</ul>
</li>
<li><a href="api/Languages.html#getting-started">Getting Started</a>
<ul>
<li><a href="api/Languages.html#starting-from-a-sample-plugin">Starting from a Sample Plugin</a></li>
<li><a href="api/Languages.html#using-boilerplate-code">Using Boilerplate Code</a>
<ul>
<li><a href="api/Languages.html#bash-boilerplate">Bash Boilerplate</a></li>
<li><a href="api/Languages.html#python-boilerplate">Python Boilerplate</a></li>
<li><a href="api/Languages.html#ruby-boilerplate">Ruby Boilerplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="api/Languages.html#the-plugin-api">The Plugin API</a></li>
</ul>
<h1 id="plugin-loading-and-precedence"><a class="header" href="#plugin-loading-and-precedence">Plugin Loading and Precedence</a></h1>
<p>Gopherbot ships with a number of external script plugins in the <code>install</code> directory. These can be overridden by placing a plugin with the same filename in the optional configuration directory.</p>
<h1 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h1>
<p>Plugin configuration is fully documented in the <a href="api/Configuration.html">configuration</a> article; you should be familiar with that document before beginning to write your own plugins.</p>
<p>On start-up and during a reload, the robot will run each external script plugin with an argument of <code>configure</code>. The plugin should respond by writing the plugin default configuration to standard out and exiting with exit code 0. When responding to <code>configure</code>, the plugin shouldn't initialize a robot object or make any API calls, as <code>configure</code> is called without setting robot environment variables.</p>
<h1 id="calling-convention"><a class="header" href="#calling-convention">Calling Convention</a></h1>
<p>The robot calls external plugins by creating a goroutine and exec'ing the external script with a set of environment variables. The external script uses the appropriate library for the scripting language to create a robot object from the environment. The script then examines it's command-line arguments to determine the type of action to take (normally a command followed by arguments to the command), and uses the library to make JSON-over-http calls for executing and returning results from methods. Depending on how the plugin is used, different kinds of events can cause external plugins to be called with a variety of commands and arguments. The most common means of calling an external plugin is for one of it's commands to be matched, or by matching a pattern in an ambient message (one not specifically directed to the robot).</p>
<p>There are two sources of information for an external plugin being called:</p>
<ul>
<li>Environment Variables - these should generally only be referenced by the scripting library</li>
<li>Command Line Arguments - these should be used by the plugin to determine what to do</li>
</ul>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Gopherbot sets two primary environment variables of use to the plugin developer:</p>
<ul>
<li>GOPHER_CONFIGDIR - the directory where Gopherbot looks for it's configuration</li>
<li>GOPHER_INSTALLDIR - the directory where the Gopherbot executable resides</li>
</ul>
<p>In addition, the following two environment variables are set for every script plugin:</p>
<ul>
<li>GOPHER_USER - the username of the user who spoke to the robot</li>
<li>GOPHER_CHANNEL - the channel the user spoke in (empty string indicates a direct message)</li>
</ul>
<h2 id="reserved-commands"><a class="header" href="#reserved-commands">Reserved Commands</a></h2>
<p>The first argument to a plugin script is the <strong>command</strong>. In addition to the <code>configure</code> command, which instructs a plugin to dump it's default configuration to standard out, the following commands are reserved:</p>
<ul>
<li><code>init</code> - After starting the connector and on reload, the robot will call external plugins with a command argument of <code>init</code>. Since all environment variables for the robot are set at that point, it would be possible to e.g. save a robot data structure that could be loaded and used in a cron job.</li>
<li><code>authorize</code> - The plugin should check authorization for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>elevate</code> - The plugin should perform additional authentication for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>event</code> - This command is reserved for future use with e.g. user presence change &amp; channel join/leave events</li>
<li><code>catchall</code> - Plugins with <code>CatchAll: true</code> will be called for commands directed at the robot that don't match a command plugin. Normally these are handled by the compiled-in <code>help</code> plugin, but administrators could override that setting and provide their own plugin with <code>CatchAll: true</code>. Note that having multiple such plugins is probably a bad idea.</li>
</ul>
<h1 id="plugin-types-and-calling-events"><a class="header" href="#plugin-types-and-calling-events">Plugin Types and Calling Events</a></h1>
<p>There are (currently) three different kinds of external plugin:</p>
<ul>
<li>Command / Message Plugins - these are called by the robot in respond to messages the user sends</li>
<li>Authorization Plugins - these plugins encapsulate the logic for authorizing specific users to use specific commands, and are called by the robot during authorization processing</li>
<li>Elevation Plugins - these plugins perform some variety of multi-factor authentication for higher assurance of user identity, and are called by the robot during elevation processing</li>
</ul>
<h2 id="command-plugins"><a class="header" href="#command-plugins">Command Plugins</a></h2>
<p>A command plugin's configuration specifies <code>CommandMatchers</code> and <code>MessageMatchers</code> that associate regular expressions with plugin commands:</p>
<pre><code class="language-yaml">MessageMatchers:
- Command: help
  Regex: '^(?i:help)$'
CommandMatchers:
- Regex: (?i:remember ([-\w .,!?:\/]+))
  Command: remember
  Contexts: [ &quot;item&quot; ]
</code></pre>
<p>Whenever a <code>CommandMatcher</code> regex matches a command given to the robot, or a <code>MessageMatcher</code> matches an ambient message, the robot calls the plugin script with the first argument being the matched <code>Command</code>, and subsequent arguments corresponding to the regex capture groups (which may in some cases be an empty string). Command plugins should normally exit with status 0 (bot.Normal), or non-zero for unusual error conditions that may require an administrator to investigate. The robot will notify the user whenever a command plugin exits non-zero, or when it emits output to STDERR.</p>
<h2 id="authorization-plugins"><a class="header" href="#authorization-plugins">Authorization Plugins</a></h2>
<p>To separate command logic from user authorization logic, Gopherbot supports the concept of an <strong>authorization plugin</strong>. The main <code>robot.yaml</code> can define a specific plugin as the <code>DefaultAuthorizer</code>, and individual plugins can be configured to override this value by specifying their own <code>Authorizer</code> plugin. If a plugin lists any commands in it's <code>AuthorizedCommands</code> config item, or specifies <code>AuthorizeAllCommands: true</code>, then the robot will call the authorizer plugin with a command of <code>authorize</code>, followed by the following arguments:</p>
<ul>
<li>The name of the plugin for which authorization is being requested</li>
<li>The optional value of <code>AuthRequire</code>, which may be interpreted as a group or role</li>
<li>The plugin command being called followed by any arguments passed to the command</li>
</ul>
<p>Based on these values and the <code>User</code> and <code>Channel</code> values from the robot, the authorization plugin should evaluate whether a user/plugin is authorized for the given command and exit with one of:</p>
<ul>
<li>bot.Succeed (1) - authorized</li>
<li>bot.Fail (2) - not authorized</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from determining authorization</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other values will result in an error and failed authentication.</p>
<p>Additionally, authorization plugins may provide extra feedback to the user on <code>Fail</code> or <code>MechanismFail</code> so they can have the issue addressed, e.g. &quot;Authorization failed: user not a member of group 'foo'&quot;. In some cases, however, authorization plugins may not have a full Gopherbot API library; they could be written in C, and thus not be able to interact with the user.</p>
<h2 id="elevation-plugins"><a class="header" href="#elevation-plugins">Elevation Plugins</a></h2>
<p>Elevation plugins provide the means to request additional authentication from the user for commands where higher assurance of identity is desired. The main <code>robot.yaml</code> can specify an elevation plugin as the <code>DefaultElevator</code>, which can be overridden by a given plugin specifying an <code>Elevator</code>. When the plugin lists commands as <code>ElevatedCommands</code> or <code>ElevateImmediateCommands</code>, the robot will call the appropriate elevator plugin with a command of <code>elevate</code> and a first argument of <code>true</code> or <code>false</code> for <code>immediate</code>. The elevator plugin should interpret <code>immediate == true</code> to mean MFA is required every time; when <code>immediate != true</code>, successful elevation may persist for a configured timeout period.</p>
<p>Based on the result of the elevation determination, the plugin should have an exit status one of:</p>
<ul>
<li>bot.Succeed (1) - elevation succeeded</li>
<li>bot.Fail (2) - elevation failed</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from processing the elevation request</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other value will result in an error being logged and elevation failing.</p>
<p>Additionally, the elevation plugin may provide extra feedback to the user when elevation isn't successful to indicate the nature of the failure.</p>
<h1 id="using-the-terminal-connector-1"><a class="header" href="#using-the-terminal-connector-1">Using the Terminal Connector</a></h1>
<p>Interacting with your bot in a chat app might not always be convenient or fast; to simplify
testing and plugin development, <strong>Gopherbot</strong> includes a terminal connector that emulates
a chat service with multiple users and channels, with a sample
configuration in the <code>cfg/term/</code> directory. You'll probably want to copy the directory and modify
it for your own use (mainly configuring the plugins you're developing), but it can be used
by using the <code>-c &lt;configpath&gt;</code> option:</p>
<pre><code>[gopherbot]$ ./gopherbot -c cfg/term/
2018/04/13 18:07:52 Initialized logging ...
2018/04/13 18:07:52 Starting up with config dir: cfg/term/, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/13 18:07:52 Debug: Loaded installed conf/robot.yaml
2018/04/13 18:07:52 Debug: Loaded configured conf/robot.yaml
Terminal connector running; Type '|c?' to list channels, '|u?' to list users
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; ;ping
general: @bob PONG
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;quit
random: @alice Adios
[gopherbot]$
</code></pre>
<h1 id="plugin-debugging"><a class="header" href="#plugin-debugging">Plugin Debugging</a></h1>
<p>The most common problem for plugin authors is the robot does nothing after sending it a message,
or the robot just says <code>Sorry, that didn't match any commands I know, ...</code>.</p>
<p>This can be due to a number of issues:</p>
<ul>
<li>The plugin didn't load because of various configuration problems</li>
<li>The robot isn't in the channel, and doesn't hear the message</li>
<li>The plugin isn't visible because of channel, user, or other restrictions</li>
<li>The user message doesn't match a regex for the plugin</li>
<li>The plugin runs, but does nothing</li>
</ul>
<p>To track down these issues easily, <strong>Gopherbot</strong> has the builtin administrator commands <code>debug plugin</code> and <code>dump plugin</code>. Make sure your username / handle is listed in the
<code>AdminUsers</code> list in <code>robot.yaml</code> for your development environment.</p>
<h2 id="debug-plugin-command"><a class="header" href="#debug-plugin-command">Debug Plugin Command</a></h2>
<p><strong>Gopherbot</strong> has a builtin command for plugin debugging that can help quickly pinpoint
most problems. Turning on plugin debugging will initiate a reload, then send debugging
information about a plugin in direct messages. If <code>verbose</code> is enabled, you will get debugging
information for every message you send, or every command sent to the robot by another user.
You can see an example of plugin debugging here with the terminal connector:</p>
<pre><code>[gopherbot]$ ./gopherbot
2018/04/18 15:43:01 Initialized logging ...
2018/04/18 15:43:01 Starting up with config dir: /home/user/.gopherbot, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/18 15:43:01 Debug: Loaded installed conf/robot.yaml
2018/04/18 15:43:01 Debug: Loaded configured conf/robot.yaml
Terminal connector running; Type '|c?' to list channels, '|u?' to list users
c:general/u:alice -&gt; ;ruby me!
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; ;help debug
general: Command(s) matching keyword: debug
floyd, debug plugin &lt;pluginname&gt; (verbose) - turn on debugging for the named plugin, optionally verbose

floyd, stop debugging - turn off debugging
c:general/u:alice -&gt; ;debug plugin rubydemo
general: Debugging enabled for rubydemo (verbose: false)
c:general/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:15 DEBUG rubydemo: plugin is NOT visible to user alice in channel general; channel 'general' is not on the list of allowed channels: random
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;ruby me to the max!
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me to the max!&quot;
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:ruby( me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:listen( to me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:remember(?: (slowly))? ([-\w .,!?:\/]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:recall ?([\d]+)?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:forget ([\d]{1,2}))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:check me)
random: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:random/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me!&quot;
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Matched command regex '(?i:ruby( me)?!?)', command: ruby
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Running plugin with command 'ruby' and arguments: [ me]
random: Sure, Alice!
random: I'll ruby you, but not right now - I'll wait 'til you're least expecting it...
(dm:alice): 2018/04/18 03:43:51 DEBUG rubydemo: Plugin finished with return value: Normal
</code></pre>
<p><strong>NOTE:</strong> If your plugin is disabled with a mysterious <code>File not found</code> error, be sure you've got the
appropriate scripting language installed. If the first line in your plugin is e.g.:</p>
<pre><code>#!/usr/bin/ruby
</code></pre>
<p>... you'll get <code>File not found</code> if <code>/usr/bin/ruby</code> isn't present on the system.</p>
<h2 id="dump-plugin-command"><a class="header" href="#dump-plugin-command">Dump Plugin Command</a></h2>
<p>To view a plugin's default or final configuration, you can use the <code>dump plugin</code> command:</p>
<pre><code>c:general/u:alice -&gt; ;help dump
general: Command(s) matching keyword: dump
floyd, dump plugin (default) &lt;plugname&gt; - dump the current or default configuration for the plugin (direct message only)

floyd, dump robot - dump the current configuration for the robot (direct message only)
c:general/u:alice -&gt; |c
Changed current channel to: direct message
c:(direct)/u:alice -&gt; dump plugin rubydemo
(dm:alice): AdminCommands: null
AllChannels: false
AllowDirect: true
AuthRequire: &quot;&quot;
AuthorizeAllCommands: false
AuthorizedCommands: null
Authorizer: &quot;&quot;
CatchAll: false
... (MUCH more)
</code></pre>
<h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<h2 id="starting-from-a-sample-plugin"><a class="header" href="#starting-from-a-sample-plugin">Starting from a Sample Plugin</a></h2>
<p>The simplest way for a new plugin author to get started is to:</p>
<ul>
<li>Disable the demo plugin for your chosen scripting language (if enabled) in <code>&lt;config dir&gt;/conf/robot.yaml</code></li>
<li>Copy the demo plugin to <code>&lt;config dir&gt;/plugins/&lt;newname&gt;(.extension)</code></li>
<li>Enable your new plugin in <code>robot.yaml</code> and give it a descriptive <code>Name</code></li>
</ul>
<h2 id="using-boilerplate-code"><a class="header" href="#using-boilerplate-code">Using Boilerplate Code</a></h2>
<p>Each supported scripting language has a certain amount of &quot;boilerplate&quot; code required in every command plugin; generally, the boilerplate code is responsible for:</p>
<ul>
<li>Loading the appropriate version of the Gopherbot library from <code>$GOPHER_INSTALLDIR/lib</code></li>
<li>Defining and providing the default config</li>
<li>Instantiating a Robot object with a library call
Normally this is followed by some form of case / switch statement that performs different functions based on the contents of the first argument, a.k.a. the &quot;command&quot;.</li>
</ul>
<h3 id="bash-boilerplate"><a class="header" href="#bash-boilerplate">Bash Boilerplate</a></h3>
<pre><code class="language-bash">#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat &lt;&lt;&quot;EOF&quot;
&lt;yaml config document&gt;
EOF
}

case &quot;$COMMAND&quot; in
	&quot;configure&quot;)
		configure
		;;
...
esac
</code></pre>
<p><strong>NOTE:</strong> Bash doesn't have an object-oriented API</p>
<h3 id="python-boilerplate"><a class="header" href="#python-boilerplate">Python Boilerplate</a></h3>
<pre><code class="language-python">#!/usr/bin/python3

import os
import sys
from gopherbot_v2 import Robot # use _v1 for python2

bot = Robot()

default_config = '''
&lt;yaml config document&gt;
'''

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == &quot;configure&quot;:
    print default_config
...
</code></pre>
<h3 id="ruby-boilerplate"><a class="header" href="#ruby-boilerplate">Ruby Boilerplate</a></h3>
<pre><code class="language-ruby">#!/usr/bin/ruby

# boilerplate
require 'gopherbot_v1'

bot = Robot.new()

defaultConfig = &lt;&lt;'DEFCONFIG'
&lt;yaml config document&gt;
DEFCONFIG

command = ARGV.shift()

case command
when &quot;configure&quot;
	puts defaultConfig
	exit
...
end
</code></pre>
<h1 id="the-plugin-api"><a class="header" href="#the-plugin-api">The Plugin API</a></h1>
<p>Gopherbot has a rich set of methods (functions) for interacting with the robot / user. Here we break down the API into sets of related functions:</p>
<ul>
<li><a href="api/Attribute-Retrieval-API.html">Attribute Lookup Methods</a> - for retrieving names, email addresses, etc.</li>
<li><a href="api/Message-Sending-API.html">Sending Messages and Replies</a> - for sending messages to the users</li>
<li><a href="api/Response-Request-API.html">Prompting for Input</a> - for getting replies from the user</li>
<li><a href="api/Brain-API.html">Brain Methods and Memories</a> - for storing and retrieving long- and short-term memories</li>
<li><a href="api/Utility-API.html">Utility Methods</a> - a collection of miscellaneous useful functions, like Pause() and Log()</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-information-about-users-and-the-robot"><a class="header" href="#getting-information-about-users-and-the-robot">Getting Information About Users and the Robot</a></h1>
<p>The <code>Get*Attribute(...)</code> family of methods can be used to get basic chat service directory information like first and last name, email address, etc. <code>GetSenderAttribute</code> and <code>GetBotAttribute</code> take a single argument, the name of the attribute to retrieve. The lesser-used <code>GetUserAttribute</code> takes two arguments, the user and the attribute. The return value is an object with <code>Attribute</code> and <code>RetVal</code> members. <code>RetVal</code> will be one of <code>Ok</code>, <code>UserNotFound</code> or <code>AttributeNotFound</code>.</p>
<h2 id="user-attributes"><a class="header" href="#user-attributes">User Attributes</a></h2>
<p>The available attributes for a user / sender:</p>
<ul>
<li>name (handle)</li>
<li>fullName</li>
<li>email</li>
<li>firstName</li>
<li>lastName</li>
<li>phone</li>
<li>internalID (protocol internal representatation)</li>
</ul>
<h2 id="bot-attributes"><a class="header" href="#bot-attributes">Bot Attributes</a></h2>
<p>The available attributes for the bot:</p>
<ul>
<li>name</li>
<li>alias</li>
<li>fullName / realName</li>
<li>contact / admin / adminContact</li>
<li>email</li>
<li>protocol (e.g. &quot;slack&quot;)</li>
</ul>
<p>Note: the values for most of these are configured in <code>conf/robot.yaml</code></p>
<h1 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h1>
<h2 id="bash"><a class="header" href="#bash">Bash</a></h2>
<pre><code class="language-bash">USEREMAIL=$(GetSenderAttribute email)
if [ $? -ne $GBRET_Ok ]
then
  Say &quot;I was unable to look up your email address&quot;
else
  Say &quot;Your email address is $USEREMAIL&quot;
fi
</code></pre>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<pre><code class="language-python"># In some cases you might forego error checking
bot.Say(&quot;You can send email to %s&quot; % bot.GetBotAttribte(&quot;email&quot;))
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot.Ok:
  bot.Say(&quot;My full name is %s&quot; % botNameAttr)
else:
  bot.Say(&quot;I don't even know what my name is!&quot;)
</code></pre>
<h2 id="ruby"><a class="header" href="#ruby">Ruby</a></h2>
<pre><code class="language-ruby"># In some cases you might forego error checking
bot.Say(&quot;You can send email to #{bot.GetBotAttribute(&quot;email&quot;)}&quot;)
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot::Ok
  bot.Say(&quot;My full name is #{botNameAttr}&quot;)
else
  bot.Say(&quot;I don't even know what my name is!&quot;)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Gopherbot</strong> comes with brain methods allowing plugin authors to store information long-term information like a <code>TODO</code> list, or short-term contextual
information, such as a particular list item under discussion. An important supplement to this guide can be found in the example scripting
plugins in the <code>plugins/</code> directory, and the <code>links</code> and <code>lists</code> <em>Go</em> plugins in the <code>goplugins</code> directory (from the source,
not included in the distributed <code>.zip</code> files).</p>
<h1 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h1>
<ul>
<li><a href="api/Brain-API.html#memory-scoping">Memory Scoping</a></li>
<li><a href="api/Brain-API.html#long-term-memories">Long-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#long-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#long-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
<li><a href="api/Brain-API.html#short-term-memories">Short-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#method-summary">Method Summary</a></li>
<li><a href="api/Brain-API.html#short-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#short-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
</ul>
<h1 id="memory-scoping"><a class="header" href="#memory-scoping">Memory Scoping</a></h1>
<p>Long-term memories are scoped per-plugin by key, and so the data is not shareable between plugins. Short-term memories are stored
for each user/channel combination, and can be freely shared between plugins.</p>
<h2 id="sharing-memories"><a class="header" href="#sharing-memories">Sharing Memories</a></h2>
<p>For multiple jobs and/or plugins to share the same memory namespace, create an entry in the robot's <code>NameSpaces:</code>, and set the <code>NameSpace:</code> for each job or plugin.</p>
<h2 id="simple-task-memory-namespace"><a class="header" href="#simple-task-memory-namespace">Simple Task Memory NameSpace</a></h2>
<p>By default, simple tasks in a job or plugin pipeline inherit the NameSpace from the pipeline, allowing memory-using tasks to be re-used. If a particular task needs to use the same memories for different plugins and jobs, create a unique entry for the task in the robot's <code>NameSpaces:</code>, and set that task's <code>NameSpace:</code> accordingly.</p>
<h1 id="long-term-memories"><a class="header" href="#long-term-memories">Long-Term Memories</a></h1>
<p>The following methods are available for manipulating long-term memories:</p>
<ul>
<li><code>CheckoutDatum(key, RWflag)</code> - returns a complex data item (memory) with a short-term exclusive lock on the datum if RW is <code>true</code></li>
<li><code>CheckinDatum(memory)</code> - signals the robot to release the lock without updating</li>
<li><code>UpdateDatum(memory)</code> - updates the memory and releases the lock</li>
</ul>
<p>When checking out a memory read-write, the engine grants a short-term lock on the memory lasting 1-2 seconds. For tasks where the time between checkout and update could be longer than one second, you should check the return value on <code>UpdateDatum</code> - <code>DatumLockExpired</code> indicates another waiting task took the lock. It's worth noting that for low-contention memories, a given task can keep the memory checked out indefinitely and still update successfully; the 1-2 seconds is guaranteed, but the lock isn't actually lost unless another task checks out the memory read-write. This also means that a read-only checkout may get an outdated memory.</p>
<h2 id="long-term-memory-code-examples"><a class="header" href="#long-term-memory-code-examples">Long-Term Memory Code Examples</a></h2>
<p>The memory stored can be an arbitrarily complex data item; a hash, array, or combination - anything that can be serialized to/from
JSON. The example plugins for <strong>Python</strong> and <strong>Ruby</strong> implement a <em>remember</em> function that remembers a list (array)
of items. For the code examples, we'll start with a memory whose key is <code>memory</code>, and has two items defined by this snippet of JSON:</p>
<pre><code class="language-json">[&quot;the Alamo&quot;, &quot;Ferris Bueller&quot;]
</code></pre>
<p>The examples will check if the memory exists, add &quot;the answer is 42&quot;, and then update the memory.</p>
<p>Note that long-term memory commands aren't current implemented for <code>bash</code>.</p>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<pre><code class="language-python">memory = bot.CheckoutDatum(&quot;memory&quot;, True)
if memory.exists:
    memory.datum.append(&quot;the answer is 42&quot;)
else:
    memory.datum = [ thing ]
ret = bot.UpdateDatum(memory)
if ret != Robot.Ok:
    bot.Say(&quot;Uh-oh, I must be gettin' old - having memory problems!&quot;)
</code></pre>
<h3 id="ruby-1"><a class="header" href="#ruby-1">Ruby</a></h3>
<p>Note: the Ruby example is a little more complicated; adapted from plugins/rubydemo.rb.</p>
<pre><code class="language-ruby">memory = bot.CheckoutDatum(&quot;memory&quot;, true)
remembered = false
if memory.exists
  if memory.datum.include?(thing)
    bot.Say(&quot;That's already one of my fondest memories&quot;)
    bot.CheckinDatum(memory)
  else
    remembered = true
    memory.datum.push(&quot;the answer is 42&quot;)
  end
else
  remembered = true
  memory.datum = [ &quot;the answer is 42&quot; ]
end
if remembered
  ret = bot.UpdateDatum(memory)
  if ret != Robot::Ok
    bot.Say(&quot;Dang it, having problems with my memory&quot;)
  end
end
</code></pre>
<h2 id="long-term-memory-sample-transcript"><a class="header" href="#long-term-memory-sample-transcript">Long-Term Memory Sample Transcript</a></h2>
<p>Using the <code>terminal</code> connector, you can see the <code>remember</code> function in action:</p>
<pre><code>c:general/u:alice -&gt; floyd, remember the answer is 42
general: Ok, I'll remember &quot;the answer is 42&quot;
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, recall
general: Here's everything I can remember:
#1: the Alamo
#2: Ferris Bueller
#3: the answer is 42
</code></pre>
<p>From the transcript you can see that <code>alice</code> added the item to the list, which
was then visible to <code>bob</code>. The <code>links</code> and <code>lists</code> plugins are more useful, and
allow easy sharing of bookmark items or <code>TODO</code> lists, for example.</p>
<h1 id="short-term-memories"><a class="header" href="#short-term-memories">Short-Term Memories</a></h1>
<p>Short term memories are simple key -&gt; string values stored for each user / channel combination, and expiring
after a time. The best example of this uses the built-in <code>links</code> and <code>lists</code> plugins, shown in this example
using the <code>terminal</code> plugin:</p>
<pre><code>c:general/u:alice -&gt; link tuna casserole to https://www.allrecipes.com/recipe/17219/best-tuna-casserole/, floyd
general: Link added
c:general/u:alice -&gt; add it to the dinner meals list
c:general/u:alice -&gt; floyd
general: Ok, I added tuna casserole to the dinner meals list
c:general/u:alice -&gt; floyd
general: Yes?
c:general/u:bob -&gt; floyd, pick a random item from the dinner meals list
general: Here you go: tuna casserole
c:general/u:bob -&gt; look it up, floyd
general: Here's what I have for &quot;tuna casserole&quot;:
https://www.allrecipes.com/recipe/17219/best-tuna-casserole/: tuna casserole
</code></pre>
<p>Here, the robot is using short-term memories several times. When I forgot to address my command to the robot, the command
<code>add it to the dinner meals list</code> was stored in short-term memory for user <code>alice</code> in the <code>general</code> channel; then, when
I typed the robot's name, it checked short-term memory for the last thing <code>alice</code> said (stored automatically). Then,
the <code>links</code> plugin stored <code>tuna casserole</code> in the <code>item</code> short-term contextual memory; when I used <code>it</code> in the lists command,
the lists plugin checked the <code>item</code> short-term memory (see <code>contexts</code> in the plugin config for <code>lists</code>) and
substituted the value from the short-term memory.</p>
<h2 id="method-summary"><a class="header" href="#method-summary">Method Summary</a></h2>
<p>These methods are available for short-term memories:</p>
<ul>
<li><code>Remember(key, value)</code> - associate the string <code>value</code> to <code>key</code>, always returns <code>Ok</code></li>
<li><code>RememberContext(context, value)</code> - store a short-term contextual memory for use with other plugins</li>
<li><code>Recall(key)</code> - return the short-term memory associated with <code>key</code>, or the empty string when the memory doesn't exist</li>
</ul>
<p>Note that the short-term memory API doesn't have complicated return values. They are always stored in the robot's working
memory and never persisted, and expire after several minutes - so plugins should always be prepared to get blank return
values.</p>
<h2 id="short-term-memory-code-examples"><a class="header" href="#short-term-memory-code-examples">Short-Term Memory Code Examples</a></h2>
<p>Note that the short-term memory API is super trivial, so I didn't go to great lengths to provide
detailed examples. The <code>bash</code> example comes from the <code>bashdemo.sh</code> plugin.</p>
<h3 id="bash-1"><a class="header" href="#bash-1">Bash</a></h3>
<pre><code class="language-bash">Remember &quot;$1&quot; &quot;$2&quot;
Say &quot;I'll remember \&quot;$1\&quot; is \&quot;$2\&quot; - but eventually I'll forget!&quot;
</code></pre>
<pre><code class="language-bash">MEMORY=$(Recall &quot;$1&quot;)
if [ -z &quot;$MEMORY&quot; ]
then
	Reply &quot;Gosh, I have no idea - I'm so forgetful!&quot;
else
	Say &quot;$1 is $MEMORY&quot;
fi
</code></pre>
<h3 id="python-2"><a class="header" href="#python-2">Python</a></h3>
<pre><code class="language-python">bot.Remember(key, value)
</code></pre>
<pre><code class="language-python">mem = bot.Recall(key)
</code></pre>
<h3 id="ruby-2"><a class="header" href="#ruby-2">Ruby</a></h3>
<pre><code class="language-ruby">bot.Remember(key, value)
</code></pre>
<pre><code class="language-ruby">mem = bot.Recall(key)
</code></pre>
<h2 id="short-term-memory-sample-transcript"><a class="header" href="#short-term-memory-sample-transcript">Short-Term Memory Sample Transcript</a></h2>
<p>Here you can see the robot's short term memories of Ferris Bueller in action (using
the <code>bashdemo.sh</code> plugin):</p>
<pre><code>c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: @bob Gosh, I have no idea - I'm so forgetful!
c:general/u:bob -&gt; floyd, store Ferris Bueller is a Righteous Dude
general: I'll remember &quot;Ferris Bueller&quot; is &quot;a Righteous Dude&quot; - but eventually I'll forget!
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; floyd, what is Ferris Bueller
general: @alice Gosh, I have no idea - I'm so forgetful!
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h1>
<ul>
<li><a href="api/Message-Sending-API.html#message-formatting">Message Formatting</a></li>
<li><a href="api/Message-Sending-API.html#say-and-reply">Say and Reply</a></li>
<li><a href="api/Message-Sending-API.html#sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></li>
<li><a href="api/Message-Sending-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Message-Sending-API.html#bash">Bash</a></li>
<li><a href="api/Message-Sending-API.html#python">Python</a></li>
<li><a href="api/Message-Sending-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h1 id="messageformat-method-and-message-formatting"><a class="header" href="#messageformat-method-and-message-formatting">MessageFormat method and Message Formatting</a></h1>
<p><strong>Gopherbot</strong> is designed to provide ChatOps functionality for a variety of team
chat platforms, with Slack being the first. Due to the technical nature of ChatOps,
characters like <code>_</code>, <code>*</code> and ` may need to be rendered in replies to the user;
at times omitting these characters (because they cause formatting changes) could
remove important information. To provide the plugin author with the most flexibility,
<strong>Gopherbot</strong> supports the notion of three message formats:</p>
<ul>
<li><code>Raw</code> - text sent by a plugin with <code>Raw</code> format is passed straight to the chat platform as-is; this is the default if no other default is specified</li>
<li><code>Variable</code> - for the <code>Variable</code> format, the protocol connector should attempt to process the message so that special characters are escaped or otherwise modified to render for the user in a standard variable-width font; for Slack, special characters are surrounded by nulls</li>
<li><code>Fixed</code> - the protocol connector should render <code>Fixed</code> format messages in a fixed-width block format</li>
</ul>
<p>The <code>MessageFormat(raw|variable|fixed)</code> method returns a robot object with the specified format. A plugin can use
<code>GetBotAttribute(&quot;protocol&quot;)</code> to determine the connector protocol (e.g. &quot;slack&quot;) to make intelligent decisions
about the format to use, or modify the content of raw messages depending on the connection protocol.</p>
<h1 id="say-and-reply"><a class="header" href="#say-and-reply">Say and Reply</a></h1>
<p><code>Say</code> and <code>Reply</code> are the staples of message sending. Both are generally used for replying to the person who spoke to the robot, but <code>Reply</code> will also <em>mention</em> the user. Normally, <code>Say</code> is used when the robot responds immediately to the user, but <code>Reply</code> is used when the robot is performing a task that takes more than a few minutes, and the robot needs to direct the message to the user to update them with progress on the task. Both <code>Say</code> and <code>Reply</code> take a <code>message</code> argument, and an optional second <code>format</code> argument that can be <code>variable</code> (the default) for variable-width text, or <code>fixed</code> for fixed-width text. The <code>fixed</code> format is normally used with embedded newlines to create tabular output where the columns will line up. The return value is not normally checked, but can be one of <code>Ok</code>, <code>UserNotFound</code>, <code>ChannelNotFound</code>, or <code>FailedMessageSend</code>.</p>
<h1 id="sendusermessage-sendchannelmessage-and-senduserchannelmessage"><a class="header" href="#sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></h1>
<p><code>Say</code> and <code>Reply</code> are actually convenience wrappers for the <code>Send*Message</code> family of methods. <code>SendChannelMessage</code> takes the obvious arguments of <code>channel</code> and <code>message</code> and just writes a message to a channel. <code>SendUserMessage</code> sends a direct message to a user, and <code>SendUserChannelMessage</code> directs the message to a user in a channel by using a connector-specific <em>mention</em>. Like <code>Say</code> and <code>Reply</code>, each of these functions also takes an optional <code>format</code> argument, and uses the same return values.</p>
<h1 id="code-examples-1"><a class="header" href="#code-examples-1">Code Examples</a></h1>
<h2 id="bash-2"><a class="header" href="#bash-2">Bash</a></h2>
<pre><code class="language-bash"># Note that bash isn't object-oriented
Say &quot;I'm sending a message to Bob in #general&quot;
SendUserChannelMessage &quot;bob&quot; &quot;general&quot; &quot;Hi, Bob!&quot;
RETVAL = $?
if [ $RETVAL -ne $GBRET_Ok ]
then
  Log &quot;Error&quot; &quot;Unable to message Bob in #general - return code $RETVAL&quot;
fi
</code></pre>
<h2 id="python-3"><a class="header" href="#python-3">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( retval != Robot.Ok ):
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
</code></pre>
<h2 id="ruby-3"><a class="header" href="#ruby-3">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if retval != Robot::Ok
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Gopherbot</strong> takes a slightly different approach to creating pipelines; pipelines are created by Add/Fail/Final Job/Command/Task family of methods, rather than by fixed configuration directives. This allows flexible configuration of pipelines if desired for e.g. a CI/CD application, or dynamic generation of pipelines based on logic at runtime.</p>
<p>Until more documentation is written, see:</p>
<ul>
<li><a href="https://github.com/lnxjedi/gopherbot/blob/master/.gopherci/pipeline.sh">The Gopherbot Pipeline Source</a></li>
<li><a href="https://github.com/parsley42/floyd-gopherbot">The Configuration repository for Floyd, the robot that builds Gopherbot</a></li>
</ul>
<h1 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h1>
<ul>
<li><a href="api/Pipeline-API.html#addtask">AddTask</a></li>
<li><a href="api/Pipeline-API.html#setparameter">SetParameter</a></li>
</ul>
<h2 id="addtask"><a class="header" href="#addtask">AddTask</a></h2>
<p>The <code>AddTask</code> method ... TODO: finish me!</p>
<h3 id="bash-3"><a class="header" href="#bash-3">Bash</a></h3>
<pre><code class="language-bash">AddTask &quot;echo&quot; &quot;hello, world&quot;
</code></pre>
<h3 id="python-4"><a class="header" href="#python-4">Python</a></h3>
<pre><code class="language-python">ret = bot.AddTask(&quot;echo&quot;, [&quot;hello&quot;, &quot;world&quot;])
bot.AddTask(&quot;robot-quit&quot;, [])
</code></pre>
<h3 id="ruby-4"><a class="header" href="#ruby-4">Ruby</a></h3>
<pre><code class="language-ruby">ret = bot.AddTask(&quot;echo&quot;, [&quot;hello&quot;, &quot;world&quot;])
bot.AddTask(&quot;robot-quit&quot;, [])
</code></pre>
<h2 id="setparameter-1"><a class="header" href="#setparameter-1">SetParameter</a></h2>
<h3 id="bash-4"><a class="header" href="#bash-4">Bash</a></h3>
<pre><code class="language-bash">SetParameter &quot;PING_LATENCY&quot; &quot;45ms&quot;
</code></pre>
<h3 id="python-5"><a class="header" href="#python-5">Python</a></h3>
<pre><code class="language-python">bot.SetParameter(&quot;PING_LATENCY&quot;, &quot;45ms&quot;)
</code></pre>
<h3 id="ruby-5"><a class="header" href="#ruby-5">Ruby</a></h3>
<pre><code class="language-ruby">bot.SetParameter(&quot;PING_LATENCY&quot;, &quot;45ms&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>The <code>Prompt*ForReply</code> methods make it simple to write interactive plugins where the bot can request additional input from the user.</p>
<h1 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h1>
<ul>
<li><a href="api/Response-Request-API.html#technical-background">Technical Background</a></li>
<li><a href="api/Response-Request-API.html#prompting-methods">Prompting Methods</a>
<ul>
<li><a href="api/Response-Request-API.html#method-arguments">Method Arguments</a></li>
<li><a href="api/Response-Request-API.html#return-values">Return Values</a></li>
</ul>
</li>
<li><a href="api/Response-Request-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Response-Request-API.html#bash">Bash</a></li>
<li><a href="api/Response-Request-API.html#python">Python</a></li>
<li><a href="api/Response-Request-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h2 id="technical-background"><a class="header" href="#technical-background">Technical Background</a></h2>
<p>Interactive plugins are complicated by the fact that multiple plugins can be running simultaneously and each can request input from the user. <strong>Gopherbot</strong> handles requests for replies this way:</p>
<ol>
<li>If there are no other plugins waiting for a reply for the given user/channel, the robot emits the prompt and waits to hear back from the user</li>
<li>If other plugins are waiting for a reply, the prompt is not emitted and the request goes in to a list of waiters</li>
<li>As other plugins get replies (or timeout while waiting), waiters in the list get a <code>RetVal</code> of <code>RetryPrompt</code>, indicating they should issue the prompt request again (this is handled internally in individual scripting libraries)</li>
</ol>
<h2 id="prompting-methods"><a class="header" href="#prompting-methods">Prompting Methods</a></h2>
<p>The following methods are available for prompting for replies:</p>
<ul>
<li><code>PromptForReply(regexID string, prompt string)</code> - issue a prompt to whoever/wherever the original command was issued</li>
<li><code>PromptUserForReply(regexID string, user string, prompt string)</code> - for prompting the user in a direct message (DM) (for e.g. a password or other sensitive information)</li>
<li><code>PromptUserChannelForReply(regexID string, user string, channel string, prompt string)</code> - prompt a specific user in a specific channel (for e.g. getting approval from another user for an action)</li>
</ul>
<h3 id="method-arguments"><a class="header" href="#method-arguments">Method arguments</a></h3>
<p>The <code>user</code> and <code>channel</code> arguments are obvious; the <code>prompt</code> is the question the robot is
asking the user, and should usually end with a <code>?</code>.</p>
<p>The <code>regexID</code> should correspond to a <code>ReplyMatcher</code> defined in the plugin configuration,
(see <a href="api/Configuration.html#plugin-configuration">Plugin Configuration</a>), or one of the
built-in regex's:</p>
<ul>
<li><code>Email</code></li>
<li><code>Domain</code> - an alpha-numeric domain name</li>
<li><code>OTP</code> - a 6-digit one-time password code</li>
<li><code>IPAddr</code></li>
<li><code>SimpleString</code> - Characters commonly found in most english sentences, doesn't include special characters like @, {, etc.</li>
<li><code>YesNo</code></li>
</ul>
<h3 id="return-values"><a class="header" href="#return-values">Return Values</a></h3>
<p>Two distinct values are returned from the prompting methods:</p>
<ol>
<li>A <code>RetVal</code> indicating success or error condition - <code>Reply.ret</code></li>
<li>When <code>RetVal</code> == <code>Ok</code>, the matched string is also returned - <code>Reply.reply</code></li>
</ol>
<p>In <strong>Go</strong>, these are returned as two separate values; in most scripting
languages, these are returned as a compound object whose string representation
is the returned string in <code>Reply.reply</code> (if the <code>RetVal</code> was <code>Ok</code>, otherwise it's the empty string).</p>
<p>Possible values for the <code>RetVal</code> in <code>Reply.ret</code> are:</p>
<ul>
<li><code>Ok</code> - If the user replied and the reply matched the regex identified by <code>regexID</code></li>
<li><code>UserNotFound</code>, <code>ChannelNotFound</code> - When an invalid user / channel is provided</li>
<li><code>MatcherNotFound</code> - When an invalid matcher is supplied</li>
<li><code>Interrupted</code> - If the user issues a new command to the robot (see NOTE below), too many <code>RetryPrompt</code> values are returned (&gt;3), or the user replies with a single dash: '<code>-</code>' (cancel)</li>
<li><code>TimeoutExpired</code> - If the user says nothing for 45 seconds</li>
<li><code>UseDefaultValue</code> - If the user replied with a single equal sign (<code>=</code>)</li>
<li><code>ReplyNotMatched</code> - When the reply from the user didn't match the supplied regex (the user was probably talking to somebody else)</li>
</ul>
<h2 id="code-examples-2"><a class="header" href="#code-examples-2">Code Examples</a></h2>
<h3 id="bash-5"><a class="header" href="#bash-5">Bash</a></h3>
<pre><code class="language-bash"># Note that bash isn't object-oriented
REPLY=$(PromptForReply &quot;YesNo&quot; &quot;Do you like kittens?&quot;)
if [ $? -ne 0 ]
then
	Reply &quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;
else
  if [[ $REPLY == y* ]] || [[ $REPLY == Y* ]]
  then
    Say &quot;No kidding! Me too!&quot;
  else
    Say &quot;Oh, come on - you're kidding, right?!?&quot;
  fi
fi
</code></pre>
<h3 id="python-6"><a class="header" href="#python-6">Python</a></h3>
<pre><code class="language-python">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot.Ok:
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else:
  reply = rep.__str__()
  if re.match(&quot;y.*&quot;, reply, flags=re.IGNORECASE):
    bot.Say(&quot;No kidding! Me too!&quot;)
  else:
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
</code></pre>
<h3 id="ruby-6"><a class="header" href="#ruby-6">Ruby</a></h3>
<pre><code class="language-ruby">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot::Ok
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else
  reply = rep.to_s()
  if /y.*/i =~ reply
    bot.Say(&quot;No kidding! Me too!&quot;)
  else
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log-method"><a class="header" href="#log-method">Log Method</a></h1>
<p>Besides the logging that Gopherbot does on it's own, plugins can also emit log messages with one of the following log levels:</p>
<ul>
<li><code>Trace</code> - for fine-grained logging of all actions</li>
<li><code>Debug</code> - for emitting debugging info</li>
<li><code>Info</code> - the default log level</li>
<li><code>Audit</code> - for auditable events - <strong>NOTE:</strong> <em>Audit events are always logged regardless of the current log level</em></li>
<li><code>Warn</code> - for potentially harmful events</li>
<li><code>Error</code> - for errors</li>
<li><code>Fatal</code> - emit fatal error and cause robot to exit(1)</li>
</ul>
<h2 id="bash-6"><a class="header" href="#bash-6">Bash</a></h2>
<pre><code class="language-bash">Log &quot;Error&quot; &quot;The robot broke&quot;
</code></pre>
<h2 id="python-7"><a class="header" href="#python-7">Python</a></h2>
<pre><code class="language-python">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2 id="ruby-7"><a class="header" href="#ruby-7">Ruby</a></h2>
<pre><code class="language-ruby">bot.Log(:error, &quot;The robot broke&quot;)
# or
bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<blockquote>
<p>Symbols look better and work just fine.</p>
</blockquote>
<h1 id="pause-method"><a class="header" href="#pause-method">Pause Method</a></h1>
<p>Every language has some means of sleeping / pausing, and this method is provided as a convenience to plugin authors and implemented natively. It takes a single argument, time in seconds.</p>
<h2 id="bash-7"><a class="header" href="#bash-7">Bash</a></h2>
<pre><code class="language-bash">Say &quot;Be back soon!&quot;
Pause 2
Say &quot;... aaaand I'm back!&quot;
</code></pre>
<h2 id="python-8"><a class="header" href="#python-8">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2 id="ruby-8"><a class="header" href="#ruby-8">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>Reference material for <strong>Gopherbot</strong> administrators and developers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a---gopherbot-installation-archive"><a class="header" href="#a---gopherbot-installation-archive">A - Gopherbot Installation Archive</a></h1>
<blockquote>
<p>Up-to-date with v2.6</p>
</blockquote>
<p>This appendix describes the contents of the <strong>Gopherbot</strong> install archive.</p>
<p><strong>Files</strong></p>
<ul>
<li><code>gopherbot</code> - the main executable, both a <em>daemon</em> and a <em>command-line interface</em></li>
<li><code>cbot.sh</code> - bash script for setting up, running and developing robots in a container</li>
<li><code>gb-install-links.sh</code> - trivial utility for creating symlinks to the above</li>
</ul>
<p><strong>Directories</strong></p>
<ul>
<li><code>conf/</code> - the default <strong>yaml</strong> configuration files, merged with / overridden by individual robots
<ul>
<li><code>conf/robot.yaml</code> - the primary configuration file for a robot</li>
<li><code>conf/plugins/</code> - default configuration for distributed plugins</li>
<li><code>conf/jobs/</code> - default configuration for distributed jobs</li>
</ul>
</li>
<li><code>lib/</code> - API libraries for <code>bash</code>, <code>python</code> and <code>ruby</code></li>
<li><code>plugins/</code> - default external script plugins</li>
<li><code>plugins/samples</code> - sample plugins that show API usage but aren't otherwise very useful</li>
<li><code>tasks/</code> - a collection of default pipeline task scripts</li>
<li><code>jobs/</code> - a collection of default jobs for robot management (backup/restore) and CI/CD</li>
<li><code>helpers/</code> - helper scripts not directly called by the robot</li>
<li><code>resources/</code> - miscellaneous useful bits for a running robot, also the <em>Containerfiles</em> used for publishing the stock containers</li>
<li><code>robot.skel/</code> - the initial configuration for new robots, analogous to the contents of <code>/etc/skel</code></li>
<li><code>licenses/</code> - licenses for other packages used by <strong>Gopherbot</strong>, as required</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-protocols"><a class="header" href="#appendix-a-protocols">Appendix A: Protocols</a></h1>
<p><strong>Gopherbot</strong> communicates with users via different protocols, and extensions can modify their behavior and provide protocol-specific functionality based on values provided to the extension. For <strong>Go</strong> extensions, this is provided in the <code>robot.Message</code> struct provided by the <code>GetMessage()</code> method. For external scripts, this is provided in the <code>GOPHER_PROTOCOL</code> environment variable.</p>
<p>The design of <strong>Gopherbot</strong> is meant for mainly protocol-agnostic functionality. Running jobs and querying infrastructure should operate in much the same way whether the protocol is <strong>Slack</strong> or <strong>Terminal</strong>. However, some teams may wish to create protocol-specific extensions, and accept the risk of a more difficult transition should the team switch their primary chat platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a1-slack"><a class="header" href="#a1-slack">A.1 Slack</a></h1>
<p>The first and best-supported protocol is <a href="https://slack.com">Slack</a>. Developers wishing to support new protocols should consider Slack the &quot;gold standard&quot;. <strong>Gopherbot</strong> uses the <a href="https://github.com/slack-go/slack">slack-go/slack</a> library.</p>
<p>The <code>Message</code> struct for Slack will have an <code>.Protocol</code> value of <code>robot.Slack</code>, and <code>.Incoming</code> pointer to a <code>robot.ConnectorMessage</code> struct:</p>
<ul>
<li><code>Protocol</code>: &quot;slack&quot;</li>
<li><code>MessageObject</code>: <code>*slack.MessageEvent</code></li>
<li><code>Client</code>: <code>*slack.Client</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a2-rocketchat"><a class="header" href="#a2-rocketchat">A.2 Rocket.Chat</a></h1>
<p><a href="https://rocket.chat/">Rocket.Chat</a> is currently the only other network-based team chat protocol for <strong>Gopherbot</strong>, coded as a fallback in the event that <strong>Slack</strong> changes the API in a ChatOps un-friendly way. When it was written, the <strong>Go</strong> library for <strong>Rocket.Chat</strong> lacked some basic functionality, so it was forked to an internal version. This protocol is not currently well supported, and could use some TLC from a developer using the protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal"><a class="header" href="#terminal">Terminal</a></h1>
<p>The <strong>terminal</strong> connector is the second-best supported connector, and will remain supported for the life of <strong>Gopherbot</strong>. It is built-in to the main binary, and heavily used for developing robot extensions prior to deployment in a network-connected chat protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test"><a class="header" href="#test">Test</a></h1>
<p>The <strong>test</strong> protocol is only used for the <strong>Gopherbot</strong> integration test suite. See the <code>test/</code> subdirectory for details on it's operation. The <strong>test</strong> protocol will also remain supported for the life of <strong>Gopherbot</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullconn"><a class="header" href="#nullconn">Nullconn</a></h1>
<p>The <strong>null</strong> connector is not actually able to communicate with users, and was written to support installation and bootstrapping code. In theory, the <strong>null</strong> connector could be used in production as an alternative to e.g. cron, running jobs developed with the <strong>terminal</strong> connector; however, no known users are doing this and it's currently unsupported for this use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-on-gopherbot"><a class="header" href="#working-on-gopherbot">Working on Gopherbot</a></h1>
<p>This chapter outlines the tools and methods for working on <strong>Gopherbot</strong> itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-robot"><a class="header" href="#development-robot">Development Robot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-integration-tests"><a class="header" href="#developing-integration-tests">Developing Integration Tests</a></h1>
<p>The current testing methodology for <strong>Gopherbot</strong> uses a special <code>test</code> protocol connector for sending test commands to the engine from various users in various channels, and then examining the responses and events generated. The tests themselves and test configurations are located in <code>/test</code>.</p>
<h2 id="building-the-special-testbot"><a class="header" href="#building-the-special-testbot">Building the special &quot;testbot&quot;</a></h2>
<p>The <strong>Gopherbot</strong> <code>Makefile</code> includes a special &quot;testbot&quot; target that builds the robot with a modified version of the terminal connector:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
</code></pre>
<h2 id="developing-tests"><a class="header" href="#developing-tests">Developing Tests</a></h2>
<p>See the contents of <code>test/*_test.go</code> for the format of the tests. After any given exchange with the robot, pressing <code>&lt;enter&gt;</code> by itself gives the events generated. Here's an example session for developing the tests in <code>test/bot_integration_test.go:TestPrompting</code>:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
[gopherbot]$ cd test/membrain
[membrain]$ ../../gopherbot 
Terminal connector running; Type '|c?' to list channels, '|u?' to list users
...
</code></pre>
<h2 id="debugging-deadlocks"><a class="header" href="#debugging-deadlocks">Debugging Deadlocks</a></h2>
<p>Occasionally locking changes in the core may result in deadlocks, which should hopefully be detected by the test suite. To assist in debugging these, the <code>SIGTERM</code> handler changes for the <code>test</code> build tag, causing the robot to perform a full stack dump and panic. Note that if an actual robot deadlocks, it should still accept an <code>abort</code> command from an administrator, which will trigger the same behavior.</p>
<p>If <code>make test</code> hangs, you can trigger a stack dump with <code>&lt;ctrl-c&gt;</code>; here's an example where updated locking of the <code>botContext</code> struct introduced a deadlock in the <code>reload</code> command:</p>
<pre><code class="language-shell">$ make test
...
=== RUN   TestReload
# Test hung here, &lt;ctrl-c&gt;
goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:24 +0x243
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
...
goroutine 590 [semacquire]:
sync.runtime_SemacquireMutex(0xc000358504, 0x900000000, 0x1)
        /usr/local/go/src/runtime/sema.go:71 +0x47
sync.(*Mutex).lockSlow(0xc000358500)
        /usr/local/go/src/sync/mutex.go:138 +0x1c1
sync.(*Mutex).Lock(0xc000358500)
        /usr/local/go/src/sync/mutex.go:81 +0x7d
github.com/lnxjedi/gopherbot/bot.Robot.getLockedContext(0xc00016e540, 0x81, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot.go:25 +0x4e
github.com/lnxjedi/gopherbot/bot.Robot.Reply(0xc00016e540, 0x81, 0xbf0ee6, 0x23, 0x0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot_connector_methods.go:212 +0x121
github.com/lnxjedi/gopherbot/bot.admin(0xce2020, 0xc0001ff930, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/builtins.go:345 +0x16b2
github.com/lnxjedi/gopherbot/bot.(*botContext).callTaskThread(0xc000358500, 0xc0003df6e0, 0xb0ef20, 0xc00012a180, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/calltask.go:138 +0xb64
created by github.com/lnxjedi/gopherbot/bot.(*botContext).callTask
        /home/davidparsley/git/gopherbot/bot/calltask.go:75 +0xe8
...
panic: Tests terminated by signal terminated

goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:27 +0x37a
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
FAIL    github.com/lnxjedi/gopherbot/test       58.197s
FAIL
Makefile:52: recipe for target 'test' failed
make: *** [test] Error 1
</code></pre>
<p>In this case the lock on the <code>botContext</code> was first aquired at the top of the admin <code>reload</code> built-in command, and then hung later when trying to acquire the lock in the robot <code>Reply</code> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-structs-and-interfaces"><a class="header" href="#important-structs-and-interfaces">Important Structs and Interfaces</a></h1>
<h2 id="the-robot-package"><a class="header" href="#the-robot-package">The <code>robot</code> package</a></h2>
<p>The <code>robot</code> package defines structs and interfaces for <strong>Go</strong> tasks, plugins and jobs.</p>
<h3 id="the-robot-interface"><a class="header" href="#the-robot-interface">The <code>Robot</code> interface</a></h3>
<p><code>Robot</code> defines the methods available to a <strong>Go</strong> task, plugin or job. Whenever the engine calls a handler for one of these, the first argument to the handler is always an object that implements the <code>Robot</code> interface. Internally (in the <code>bot</code> package), this is a <code>bot.Robot</code> struct, with methods that implement the <code>robot.Robot</code> interface.</p>
<h3 id="the-message-struct"><a class="header" href="#the-message-struct">The <code>Message</code> struct</a></h3>
<p>The <code>GetMessage()</code> method on the <code>Robot</code> will return a <code>robot.Message</code>, which contains information about the user and channel, as well as a pointer to a copy of the original incoming data structure from the external connector. The complete definition is available from <a href="https://godoc.org/github.com/lnxjedi/robot#Message">godoc.org</a>.</p>
<h2 id="the-bot-package"><a class="header" href="#the-bot-package">The <code>bot</code> package</a></h2>
<p>The <code>bot</code> package contains all the logic for a running robot.</p>
<h3 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h3>
<p>Any time <strong>Gopherbot</strong> runs a task, plugin or job, it is part of a pipeline (which may consist only of a single job or plugin executing). The data structures for representing a pipeline are the <code>worker</code> and the <code>pipeContext</code>.</p>
<h3 id="workers"><a class="header" href="#workers">Workers</a></h3>
<p>The <code>worker</code> struct represents a thread of execution. The worker contains all the invariant information about how it was created, whether from an incoming message, a scheduled job, or a job spawn from another worker. Workers are created for every incoming message, regardless of whether a pipeline is ever started. The worker includes a <code>context</code> pointer that is populated when <code>startPipeline(...)</code> is called.</p>
<h3 id="pipe-context"><a class="header" href="#pipe-context">Pipe Context</a></h3>
<p>Whenever a pipeline is started, the <code>context</code> member of the <code>worker</code> struct is populated with a <code>pipeContext</code> (by <code>bot.registerActive</code>), to keep state for the pipeline. At this time four bytes of entropy are consumed for the <code>GOPHER_CALLER_ID</code> environment variable, to be passed to external scripts that run in the pipeline. This allows <code>bot/http.go</code> to look up the correct robot on each external script method call. The <code>pipeContext</code> contains a <code>sync.Mutex</code> member for locking, as it can be changed in different threads of execution. Note, however, that a well written task, plugin or job is not multi-threaded, and under normal circumstances all access to the <code>pipeContext</code> <em>should</em> be serialized.</p>
<h3 id="robots"><a class="header" href="#robots">Robots</a></h3>
<p>The <code>bot.Robot</code> struct is created any time a task, plugin or job is run, and contains a pointer to the <code>robot.Message</code>, a pointer to the <code>bot.worker</code>, and a snapshot of the current <code>pipeContext</code> when <code>w.makeRobot</code> was called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols"><a class="header" href="#protocols">Protocols</a></h1>
<p>At different points during the development of <strong>Gopherbot</strong>, consideration was given to the possibility of being <em>multi-protocol</em>, allowing messages to come in from different protocols to a single running instance. This has not come to fruition, and is left as being 'under consideration'.</p>
<p>The primary use for the <strong>Protocol</strong> struct fields (and <code>GOPHER_PROTOCOL</code> environment variable) is being informative for extensions; this functionality should remain, and stay much the same. Otherwise, the multi-protocol question is left open.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releases"><a class="header" href="#releases">Releases</a></h1>
<p>Given the relative infrequency of releases and newness of the development structure, this is still a manual process. Documented here for repeatability until it's automated.</p>
<h2 id="cutting-a-new-minor-release---2x"><a class="header" href="#cutting-a-new-minor-release---2x">Cutting a new Minor Release - 2.x</a></h2>
<p>To release e.g. v2.1:</p>
<ol>
<li>Check out a new branch of the form <code>release-2.x</code>, e.g. <code>release-2.1</code>
<blockquote>
<p>Note that this just prevents an automatic build on push</p>
</blockquote>
</li>
<li>Edit <code>main.go</code> and update <code>Version</code>
<ul>
<li>Automation note: the pipeline could be updated to pass this in to the build, similar to the commit.</li>
</ul>
</li>
<li>Tag the release with the form <code>v2.x</code>, e.g. <code>v2.1</code></li>
<li>Tell Mr. Data to <code>build gopherbot v2.x</code></li>
<li>Check out <code>main</code> branch</li>
<li>Update the <code>Version</code> to <code>v2.(x+1)-pre</code>, e.g. <code>v2.2-pre</code></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
