<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gopherbot DevOps Chatbot</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="Title.html">Title</a></li><li class="expanded affix "><a href="Foreward.html">Foreward</a></li><li class="expanded affix "><a href="Introduction.html">Introduction</a></li><li class="expanded affix "><a href="Terminology.html">Terminology</a></li><li class="expanded "><a href="Installation.html"><strong aria-hidden="true">1.</strong> Settting Up a Gopherbot Robot</a></li><li><ol class="section"><li class="expanded "><a href="install/Requirements.html"><strong aria-hidden="true">1.1.</strong> Gopherbot Requirements</a></li><li class="expanded "><a href="install/ManualInstall.html"><strong aria-hidden="true">1.2.</strong> Manual Installation</a></li><li class="expanded "><a href="RobotInstall.html"><strong aria-hidden="true">1.3.</strong> Initial Robot Configuration</a></li><li><ol class="section"><li class="expanded "><a href="botsetup/Requirements.html"><strong aria-hidden="true">1.3.1.</strong> Requirements</a></li><li class="expanded "><a href="botsetup/gopherhome.html"><strong aria-hidden="true">1.3.2.</strong> Robot Directory Structure</a></li><li class="expanded "><a href="botsetup/Plugin.html"><strong aria-hidden="true">1.3.3.</strong> Quick Start with Autosetup</a></li><li class="expanded "><a href="botsetup/Gitpod.html"><strong aria-hidden="true">1.3.4.</strong> Setting up a Robot with Gitpod</a></li><li class="expanded "><a href="botsetup/ContainerSetup.html"><strong aria-hidden="true">1.3.5.</strong> Setup with Containers</a></li><li class="expanded "><a href="botsetup/ManualSetup.html"><strong aria-hidden="true">1.3.6.</strong> Manual Setup</a></li><li><ol class="section"><li class="expanded "><a href="botsetup/bothome.html"><strong aria-hidden="true">1.3.6.1.</strong> Create the GOPHER_HOME directory</a></li><li class="expanded "><a href="botsetup/initenv.html"><strong aria-hidden="true">1.3.6.2.</strong> Create the Initial .env File</a></li><li class="expanded "><a href="botsetup/initcrypt.html"><strong aria-hidden="true">1.3.6.3.</strong> Initialize Encryption</a></li><li class="expanded "><a href="botsetup/copystd.html"><strong aria-hidden="true">1.3.6.4.</strong> Copy the Standard Robot</a></li><li class="expanded "><a href="botsetup/sshkeys.html"><strong aria-hidden="true">1.3.6.5.</strong> Generate SSH Keypairs</a></li><li class="expanded "><a href="botsetup/finalenv.html"><strong aria-hidden="true">1.3.6.6.</strong> Finish the .env File</a></li><li class="expanded "><a href="botsetup/connect.html"><strong aria-hidden="true">1.3.6.7.</strong> Connect Robot to Team</a></li><li class="expanded "><a href="botsetup/saverobot.html"><strong aria-hidden="true">1.3.6.8.</strong> Saving Your Robot to Git</a></li><li class="expanded "><a href="botsetup/finished.html"><strong aria-hidden="true">1.3.6.9.</strong> Finished</a></li></ol></li></ol></li></ol></li><li class="expanded "><a href="Upgrading.html"><strong aria-hidden="true">2.</strong> Upgrading from Version 1</a></li><li><ol class="section"><li class="expanded "><a href="upgrade/BotInfo.html"><strong aria-hidden="true">2.1.</strong> Required Bot Info</a></li><li class="expanded "><a href="upgrade/External-Plugin.html"><strong aria-hidden="true">2.2.</strong> External Plugin Configuration</a></li><li class="expanded "><a href="upgrade/Custom-Dir.html"><strong aria-hidden="true">2.3.</strong> Custom Configuration Directory</a></li><li class="expanded "><a href="upgrade/robot-yaml.html"><strong aria-hidden="true">2.4.</strong> Main Configuration File Rename</a></li><li class="expanded "><a href="upgrade/Encryption.html"><strong aria-hidden="true">2.5.</strong> Early Encryption Initialization</a></li><li class="expanded "><a href="upgrade/Memories.html"><strong aria-hidden="true">2.6.</strong> Long-Term Memories</a></li></ol></li><li class="expanded "><a href="RunRobot.html"><strong aria-hidden="true">3.</strong> Deploying and Running Your Robot</a></li><li><ol class="section"><li class="expanded "><a href="deploy/CLI.html"><strong aria-hidden="true">3.1.</strong> CLI Operation</a></li><li><ol class="section"><li class="expanded "><a href="deploy/local.html"><strong aria-hidden="true">3.1.1.</strong> Local Install</a></li><li class="expanded "><a href="deploy/containercli.html"><strong aria-hidden="true">3.1.2.</strong> Container Operation</a></li><li class="expanded "><a href="deploy/gitpodcli.html"><strong aria-hidden="true">3.1.3.</strong> Using Gitpod</a></li><li class="expanded "><a href="deploy/secrets.html"><strong aria-hidden="true">3.1.4.</strong> Encrypting Secrets</a></li></ol></li><li class="expanded "><a href="deploy/systemd.html"><strong aria-hidden="true">3.2.</strong> Running with Systemd</a></li><li class="expanded "><a href="deploy/Container.html"><strong aria-hidden="true">3.3.</strong> Running in a Container</a></li></ol></li><li class="expanded "><a href="Basics.html"><strong aria-hidden="true">4.</strong> Robot Basics</a></li><li><ol class="section"><li class="expanded "><a href="basics/ping.html"><strong aria-hidden="true">4.1.</strong> Addressing your Robot</a></li><li class="expanded "><a href="basics/matching.html"><strong aria-hidden="true">4.2.</strong> Command Matching</a></li><li class="expanded "><a href="basics/channels.html"><strong aria-hidden="true">4.3.</strong> Availability by Channel</a></li><li class="expanded "><a href="basics/help.html"><strong aria-hidden="true">4.4.</strong> The built-in Help System</a></li><li class="expanded "><a href="basics/stdplugins.html"><strong aria-hidden="true">4.5.</strong> Standard Commands</a></li><li class="expanded "><a href="basics/context.html"><strong aria-hidden="true">4.6.</strong> Context</a></li></ol></li><li class="expanded "><a href="Admin.html"><strong aria-hidden="true">5.</strong> Robot Administration</a></li><li><ol class="section"><li class="expanded "><a href="usage/update.html"><strong aria-hidden="true">5.1.</strong> Updating from Git</a></li><li class="expanded "><a href="usage/terminal.html"><strong aria-hidden="true">5.2.</strong> Using the Terminal Connector</a></li><li class="expanded "><a href="usage/admin.html"><strong aria-hidden="true">5.3.</strong> Administrator Commands</a></li><li class="expanded "><a href="usage/cli.html"><strong aria-hidden="true">5.4.</strong> Command-Line Use</a></li><li class="expanded "><a href="usage/logging.html"><strong aria-hidden="true">5.5.</strong> Logging</a></li></ol></li><li class="expanded "><a href="botprogramming.html"><strong aria-hidden="true">6.</strong> Developing Extensions for Your Robot</a></li><li class="expanded "><a href="Configuration.html"><strong aria-hidden="true">7.</strong> Gopherbot Configuration Reference</a></li><li><ol class="section"><li class="expanded "><a href="Environment-Variables.html"><strong aria-hidden="true">7.1.</strong> Environment Variables</a></li><li class="expanded "><a href="config/file.html"><strong aria-hidden="true">7.2.</strong> Configuration File Loading</a></li><li class="expanded "><a href="config/job-plug.html"><strong aria-hidden="true">7.3.</strong> Job and Plugin Configuration</a></li><li class="expanded "><a href="config/troubleshooting.html"><strong aria-hidden="true">7.4.</strong> Troubleshooting</a></li></ol></li><li class="expanded "><a href="pipelines/jobspipes.html"><strong aria-hidden="true">8.</strong> Pipelines, Plugins, Jobs and Tasks</a></li><li><ol class="section"><li class="expanded "><a href="pipelines/primary.html"><strong aria-hidden="true">8.1.</strong> The Primary Pipeline</a></li><li class="expanded "><a href="pipelines/final.html"><strong aria-hidden="true">8.2.</strong> The Final Pipeline</a></li><li class="expanded "><a href="pipelines/fail.html"><strong aria-hidden="true">8.3.</strong> The Fail Pipeline</a></li><li class="expanded "><a href="pipelines/TaskEnvironment.html"><strong aria-hidden="true">8.4.</strong> Task Environment Variables</a></li><li class="expanded "><a href="pipelines/tasks.html"><strong aria-hidden="true">8.5.</strong> All Included Tasks</a></li></ol></li><li class="expanded "><a href="pipelines/integrations.html"><strong aria-hidden="true">9.</strong> Gopherbot Tool Integrations</a></li><li><ol class="section"><li class="expanded "><a href="pipelines/ssh.html"><strong aria-hidden="true">9.1.</strong> Integrating with SSH</a></li></ol></li><li class="expanded "><a href="api/API-Introduction.html"><strong aria-hidden="true">10.</strong> Gopherbot API</a></li><li><ol class="section"><li class="expanded "><a href="api/Languages.html"><strong aria-hidden="true">10.1.</strong> Language Templates</a></li><li class="expanded "><a href="api/Attribute-Retrieval-API.html"><strong aria-hidden="true">10.2.</strong> Attribute Retrieval</a></li><li class="expanded "><a href="api/Brain-API.html"><strong aria-hidden="true">10.3.</strong> Brain Methods</a></li><li class="expanded "><a href="api/Message-Sending-API.html"><strong aria-hidden="true">10.4.</strong> Message Sending</a></li><li class="expanded "><a href="api/Pipeline-API.html"><strong aria-hidden="true">10.5.</strong> Pipeline Construction</a></li><li class="expanded "><a href="api/Response-Request-API.html"><strong aria-hidden="true">10.6.</strong> Requesting Responses</a></li><li class="expanded "><a href="api/Utility-API.html"><strong aria-hidden="true">10.7.</strong> Utility</a></li></ol></li><li class="expanded "><a href="Modules.html"><strong aria-hidden="true">11.</strong> Module Support</a></li><li class="expanded "><a href="appendices/Appendix.html"><strong aria-hidden="true">12.</strong> Appendix</a></li><li><ol class="section"><li class="expanded "><a href="appendices/Protocols.html"><strong aria-hidden="true">12.1.</strong> A - Protocols</a></li><li><ol class="section"><li class="expanded "><a href="appendices/slack.html"><strong aria-hidden="true">12.1.1.</strong> A.1 - Slack</a></li><li class="expanded "><a href="appendices/rocket.html"><strong aria-hidden="true">12.1.2.</strong> A.2 - Rocket.Chat</a></li><li class="expanded "><a href="appendices/terminal.html"><strong aria-hidden="true">12.1.3.</strong> A.3 - Terminal</a></li><li class="expanded "><a href="appendices/testproto.html"><strong aria-hidden="true">12.1.4.</strong> A.4 - Test</a></li><li class="expanded "><a href="appendices/nullconn.html"><strong aria-hidden="true">12.1.5.</strong> A.5 - Nullconn</a></li></ol></li></ol></li><li class="expanded "><a href="GopherDev.html"><strong aria-hidden="true">13.</strong> Working on Gopherbot</a></li><li><ol class="section"><li class="expanded "><a href="botdev/DevelRobot.html"><strong aria-hidden="true">13.1.</strong> Development Robot</a></li><li class="expanded "><a href="botdev/IntegrationTests.html"><strong aria-hidden="true">13.2.</strong> Integration Tests</a></li><li class="expanded "><a href="botdev/Gitpod.html"><strong aria-hidden="true">13.3.</strong> Coding with Gitpod</a></li><li class="expanded "><a href="botdev/StructsInterfaces.html"><strong aria-hidden="true">13.4.</strong> Important Structs and Interfaces</a></li><li class="expanded "><a href="botdev/protocols.html"><strong aria-hidden="true">13.5.</strong> Protocols</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Gopherbot DevOps Chatbot</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gopherbotbrdevops-chatbot" id="gopherbotbrdevops-chatbot">Gopherbot</br>DevOps Chatbot</a></h1>
<p><img src="gopherbot.png" alt="Gophers+bot by Renee French, cropped, cc3.0" /></p>
<p>By David Parsley, <a href="mailto:parsley@linuxjedi.org">parsley@linuxjedi.org</a></p>
<p><strong>NOTE: This manual is a work in progress; currently incomplete and partly outdated. This note will be removed for the 2.0 release - for now YMMV.</strong></p>
<p>Gophers + Robot by Renee French (cropped) licensed under <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons License 3.0</a></p>
<p>My work with ChatOps began with Hubot around 2012 when I was working as an systems engineer for a small hosting provider. The owner had sent me a link to Hubot, asking me to have a look. I took to the concept immediately, and started automating all kinds of tasks that our support team could easily access from our team chat. Soon they were using our robot to troubleshoot email routing and DNS issues, migrate mailboxes, and build new cPanel server instances.</p>
<p>Not being a very talented (or motivated) Javascript/NodeJS programmer, my Hubot commands invariably followed the same pattern: write it in Javascript if it was <em>trivially</em> easy  to do so, otherwise shell out to bash and return the results. This was productive and gave results, but it was ugly and limited in functionality.</p>
<p>When I began teaching myself Go, I needed a good project to learn with. After my experience with Hubot, I decided to write a robot that was more approachable for Systems and DevOps engineers like myself - tasked with providing functionality most easily accessible from e.g. bash or python scripts. Towards that end, Gopherbot's design:</p>
<ul>
<li>Is CGI-like in operation: the compiled server process spawns scripts which can then use a simple API for interacting with the user / chat service</li>
<li>Supports any number of scripting languages by using a simple json-over-http localhost interface</li>
<li>Uses a multi-process design with method calls that block</li>
</ul>
<p>Ultimately, Gopherbot gives me a strong alternative to writing Yet Another Web Application to deliver some kind of reporting, security, or management functionality to managers and technical users. It's a good meet-in-the-middle solution that's nearly as easy to use as a web application, with some added benefits:</p>
<ul>
<li>The chat application gives you a single pane of glass for access to a wide range of functionality</li>
<li>The shared-view nature of channels gives an added measure of security thanks to visibility, and also a simple means of training users to interact with a given application</li>
<li>Like a CGI, applications can focus on functionality, with security and access control being configured in the server process</li>
</ul>
<p>It is my hope that this design will appeal to other engineers like myself, and that somewhere, somebody will exclaim &quot;Wait, what? I can write chat bot plugins <em><strong>in BASH</strong></em>?!?&quot;</p>
<p>David Parsley, March 2017 / September 2019</p>
<pre><code class="language-bash">#!/bin/bash

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z &quot;$GOPHER_INSTALLDIR&quot; ] &amp;&amp; { echo &quot;GOPHER_INSTALLDIR not set&quot; &gt;&amp;2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat &lt;&lt;&quot;EOF&quot;
---
Help:
- Keywords: [ &quot;repeat&quot; ]
  Helptext: [ &quot;(bot), repeat (me) - prompt for and trivially repeat a phrase&quot; ]
CommandMatchers:
- Command: &quot;repeat&quot;
  Regex: '(?i:repeat( me)?)'
EOF
}

case &quot;$command&quot; in
# NOTE: only &quot;configure&quot; should print anything to stdout
	&quot;configure&quot;)
		configure
		;;
	&quot;repeat&quot;)
		REPEAT=$(PromptForReply SimpleString &quot;What do you want me to repeat?&quot;)
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply &quot;Sorry, I had a problem getting your reply: $RETVAL&quot;
		else
			Reply &quot;$REPEAT&quot;
		fi
		;;
esac
</code></pre>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><strong>Gopherbot</strong> DevOps Chatbot is a tool for teams of developers, operators, infrastructure engineers and support personnel - primarily for those that are already using Slack or another team chat platform for day-to-day communication. It belongs to and integrates well with a larger family of tools including <em>Ansible</em>, <em>git</em> and <em>ssh</em>, and is able to perform many tasks similar to <em>Jenkins</em> or <em>TravisCI</em>; all of this functionality is made available to your team via the chat platform you're already using.</p>
<p>To help give you an idea of the kinds of tasks you can accomplish, here are a few of the things my teams have done with <strong>Gopherbot</strong> over the years:</p>
<ul>
<li>Generating and destroying <a href="https://aws.amazon.com">AWS</a> instances on demand</li>
<li>Running software build, test and deploy pipelines, triggered by git service integration with team chat</li>
<li>Updating service status on the department website</li>
<li>Allowing support personnel to search and query user attributes</li>
<li>Running scheduled backups to gather artifacts over <code>ssh</code> and publish them to an artifact service</li>
<li>Occasionally - generating silly memes</li>
</ul>
<p>The primary strengths of <strong>Gopherbot</strong> stem from it's simplicity and flexibility. It installs and bootstraps readily on a VM or in a container with just a few environment variables, and can be run behind a firewall where it can perform tasks like rebooting server hardware over IPMI. Simple command plugins can be written in <code>bash</code> or <code>python</code>, with easy to use encrypted secrets for accomplishing privileged tasks. Like any user, the robot can also have it's own (encrypted, naturally) ssh key for performing remote work and interfacing with <em>git</em> services.</p>
<p>The philosophy underlying <strong>Gopherbot</strong> is the idea of solving the most problems with the smallest set of general purpose tools, accomplishing a wide variety of tasks reasonably well. It's true that <strong>Gopherbot</strong> doesn't do CI/CD to the level of, say, <em>Jenkins</em> - but it's amazing how productive I am with it. Perhaps the best example of it's flexibility can be seen in the CI/CD pipeline for <strong>Gopherbot</strong> itself; start reading with <code>pipeline.sh</code> in <a href="https://github.com/lnxjedi/gopherbot/tree/master/.gopherci">the <code>.gopherci</code> directory</a>.</p>
<p>The major design goals for <strong>Gopherbot</strong> are reliability and portability, leaning heavily on &quot;configuration as code&quot;. Ideally, custom add-on plugins and jobs that work for a robot instance in <a href="https://slack.com">Slack</a> should work just as well if your team moves, say, to <a href="https://rocket.chat">Rocket.Chat</a>. This goal ends up being a trade-off with supporting specialized features of a given platform, though the <strong>Gopherbot</strong> API enables platform-specific customizations if desired.</p>
<p>Secondary but important design goals are configurability and security. Individual commands can be constrained to a subset of channels and/or users, require external authorization or elevation plugins, and administrators can customize help and command matching patterns for stock plugins. <strong>Gopherbot</strong> has been built with security considerations in mind from the start; employing strong encryption, privilege separation, and a host of other measures to make your robot a difficult target.</p>
<p>Version 2 for the most part assumes that your robot will employ encryption and get it's configuration from a <em>git</em> repository. Other deployments are possible, but not well documented. This manual will focus on working with <strong>Gopherbot</strong> instances whose configuration is stored on <a href="https://github.com">Github</a>, but other <em>git</em> services are easy to use, as well.</p>
<p>That's it for the &quot;marketing&quot; portion of this manual - by now you should have an idea whether <strong>Gopherbot</strong> would be a good addition to your DevOps tool set.</p>
<h1><a class="header" href="#terminology" id="terminology">Terminology</a></h1>
<p>This section is most important for referring back to as you read the documentation, to disambiguate terms.</p>
<p>(It's also for me, to help maintain some consistency)</p>
<ul>
<li><strong>Gopherbot</strong> - The installed software archive that comprises the <strong>Gopherbot DevOps Chatbot</strong> service daemon</li>
<li><strong>robot</strong> - you'll see the term <em>robot</em> in several different contexts in the documentation with these several meanings:
<ul>
<li><strong>robot</strong> - A configured instance of a running <strong>Gopherbot</strong> daemon, available in your team chat; normally associated with a <em>git</em> repository that holds all the configuration and extensions for the robot</li>
<li><strong>Robot</strong> - The object passed to user plugins, jobs and tasks</li>
<li><strong>robot</strong> - the <strong>Go</strong> library for loadable modules, i.e. <code>import github.com/lnxjedi/robot</code></li>
</ul>
</li>
<li><strong>default robot</strong> - If you run Gopherbot with no custom configuration, you get <em>Floyd</em>, the default robot</li>
<li><strong>standard robot</strong> - A standard robot is what you get from using <code>robot.skel</code> or running the <code>autosetup</code> plugin from the <strong>default robot</strong>; more generally, any robot that has the standard <code>robot.skel</code> configuration as it's base is still a <strong>standard robot</strong></li>
<li><strong>GOPHER_HOME</strong> - The top-level directory for a given robot; the <strong>Gopherbot</strong> binary (<code>/opt/gopherbot/gopherbot</code>) is run from this directory to start or interact with the robot</li>
<li><strong>bootstrapping</strong> - When you start the <code>gopherbot</code> daemon in a container with a few environment variables, or in an empty directory with a suitable <code>.env</code> environment file, the <strong>bootstrap</strong> plugin included with the <strong>default robot</strong> will use a deploy key to pull your robot from a <em>git</em> repository and start it up; this process is called <strong>bootstrapping</strong> your robot, and allows deploying your robot to new environments quickly</li>
<li><strong>plugin</strong> (or <strong>command plugin</strong>) - A piece of code that provides new interactive commands; plugins may also provide code for authorization and/or elevation, which may also interact with users</li>
<li><strong>authorizer</strong> - special plugin command used to determine whether a given user is authorized for a given command, normally checking some kind of group membership</li>
<li><strong>elevator</strong> - special plugin command providing additional verification of user identity; this can be as simple as a totp token or <a href="https://duo.com">Duo</a> two-factor, or as complex as prompting another user before allowing a command to proceed</li>
<li><strong>job</strong> - jobs are pieces of code that typically use the pipeline API for creating pipelines to perform complex scheduled tasks such as backups and monitoring, or for software builds that may be triggered by hosted git service integrations with your chat platform; see the chapter on <a href="pipelines/jobspipes.html">jobs and pipelines</a></li>
<li><strong>task</strong> - tasks are small pieces of code that generally form the parts of a pipeline, such as initializing (and tearing down) the <code>ssh-agent</code>, running pipeline scripts, or sending notifications; the task is also the base object for jobs and plugins, so &quot;task&quot; may refer to any entry in <code>ExternalPlugins</code>, <code>ExternalTasks</code>, <code>ExternalJobs</code>, etc.</li>
<li><strong>parameter</strong> - a name/value setting configurable for tasks, plugins, jobs and repositories, presented to external scripts as environment variables</li>
</ul>
<p>In addition, this manual may periodically reference two important robots:</p>
<ul>
<li><strong>Floyd</strong> - Floyd is the production robot in the <code>linuxjedi</code> Slack team, currently running on a <code>t2.nano</code> in AWS. Floyd is responsible for building, testing and publishing the <strong>Gopherbot</strong> artifacts. The name is taken from Infocom's <strong>Planetfall</strong>, circa 1983. Also, as above, the <strong>Gopherbot</strong> default robot is named <em>Floyd</em>, but every other mention of <strong>Floyd</strong> refers to my production robot, whose repository can always be found <a href="https://github.com/parsley42/floyd-gopherbot">on Github</a>.</li>
<li><strong>Clu</strong> - Clu is &quot;the best program that's ever been written ... dogged and relentless&quot;; also, the development robot that changes frequently as I develop <strong>Gopherbot</strong>. Clu runs on workstations, chromebooks, containers, in <a href="https://www.gitpod.io/">Gitpod</a>, or wherever I happen to be doing development. If you've seen <strong>Tron: Legacy</strong> - it's not <strong>THAT</strong> Clu, but rather the short-lived <strong>Clu</strong> from the original <strong>TRON</strong>, circa 1982. <strong>Clu's</strong> repository is also always available <a href="https://github.com/parsley42/clu-gopherbot">on Github</a>, and generally has a pretty up-to-date README (not so much Floyd).</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>There are three distinct tasks involved in installing and running a <strong>Gopherbot</strong> robot:</p>
<ol>
<li>The first section discusses installing the <strong>Gopherbot</strong> distribution archive, normally in <code>/opt/gopherbot</code>; this provides the <code>gopherbot</code> binary, default configuration, and an assortment of included batteries (libraries, plugins, jobs, tasks, helper scripts and more); if you're using a <a href="https://hub.docker.com/r/lnxjedi/gopherbot">Gopherbot container</a>, installation is essentially a no-op.</li>
<li>Configuring a runnable instance of a robot for your team; the included <strong>autosetup</strong> plugin should make this an &quot;easy button&quot; - discussed in the chapter on <a href="RobotInstall.html">Initial Configuration</a>.</li>
<li>Deploying and running your robot on a server, VM, or in a container - covered in the chapter on <a href="RunRobot.html">Running your Robot</a>.</li>
</ol>
<h2><a class="header" href="#gopherbot-and-robots" id="gopherbot-and-robots"><strong>Gopherbot</strong> and <em>Robots</em></a></h2>
<p>It's helpful to understand the relationship between <strong>Gopherbot</strong> and individual robots you run. It's apt to compare Gopherbot with <em>Ansible</em>:</p>
<ul>
<li><em>Gopherbot</em> is similar to <em>Ansible</em> - a common code base with an assortment of included batteries, but with limited functionality on it's own</li>
<li>A <em>Robot</em> is comparable to a collection of playbooks and/or roles - this is your code for accomplishing work in your environment, which uses <em>Gopherbot</em> and it's included extensions to do it's work</li>
</ul>
<p>Similar to Ansible playbooks and roles, individual robots may periodically require updates as you upgrade the <strong>Gopherbot</strong> core.</p>
<h1><a class="header" href="#requirements" id="requirements">Requirements</a></h1>
<p>Since <strong>Gopherbot</strong> is primarily a <em>Go</em> daemon that utilizes external tools and scripts to perform most of the real work, you'll probably want to have most of the (common) listed dependencies. Note that if you deploy your robot in a container, most of these are included in the base container.</p>
<ul>
<li><code>git</code> - with version 2, <strong>Gopherbot</strong> is tightly integrated with git for updating configuration and keeping state; <strong>Gopherbot</strong> requires fairly recent versions of <em>git</em> supporting <code>git remote get-url ...</code>
<ul>
<li>Note that the version of <em>git</em> in CentOS 7 is not supported, see the <a href="https://ius.io/">Inline with Upstream Stable</a> site for a newer version</li>
</ul>
</li>
<li><code>ssh</code> - robots configured from this manual require <em>ssh</em> for setup and deployment; additionally, most robots should have an encrypted private key / public key pair for performing <em>git</em> operations and running remote jobs</li>
<li><code>bash</code> - the majority of the <em>batteries included</em> scripts included with <strong>Gopherbot</strong> are written in good 'ol <strong>Bash</strong>; this is nearly universal but listed here for containerized deployments</li>
<li><code>jq</code> - required by the <code>gopherbot/lib/gopherbot_v1.sh</code> <strong>bash</strong> library for parsing the <strong>JSON</strong> responses from the robot
<ul>
<li>Note this is available from the <a href="https://fedoraproject.org/wiki/EPEL">EPEL</a> repositories for CentOS 7</li>
</ul>
</li>
<li><code>python</code> - (version 3) next to <code>bash</code>, the second most common language for extensions is <strong>python</strong> version 3, which includes several management jobs</li>
</ul>
<p><strong>Optional</strong></p>
<ul>
<li><code>ruby</code> - ruby isn't heavily used with the default extensions, but is a supported language and included in the pre-built containers</li>
<li><code>go</code> - the pre-built containers all include a recent version of <em>Go</em>, which can be used for e.g. building loadable modules for <em>Go</em> plugins, jobs and tasks</li>
</ul>
<h1><a class="header" href="#installing-the-gopherbot-software-archive" id="installing-the-gopherbot-software-archive">Installing the <code>gopherbot</code> software archive</a></h1>
<p>The latest release, pre-release and beta versions are available for download on the <a href="https://github.com">Github</a> releases page for <a href="https://github.com/lnxjedi/gopherbot/releases">gopherbot</a>.</p>
<ol>
<li>As <strong>root</strong>, download the <code>.tar.gz</code> or <code>.zip</code> archive of your choice, and extract the archive in <code>/opt</code> to create <code>/opt/gopherbot</code>, e.g.:</li>
</ol>
<pre><code class="language-shell">[root]# cd /opt
[opt]# wget https://github.com/lnxjedi/gopherbot/releases/download/v2.0.0-snapshot/gopherbot-linux-amd64.tar.gz
[opt]# tar xzf gopherbot-linux-amd64.tar.gz
</code></pre>
<ol start="2">
<li>(Optional) Also as root, make the <code>gopherbot</code> binary <strong>setuid nobody</strong> (see <a href="install/ManualInstall.html#privilege-separation">below</a>):</li>
</ol>
<pre><code class="language-shell">[opt]# chown nobody gopherbot/gopherbot
[opt]# chmod u+s gopherbot/gopherbot
</code></pre>
<h2><a class="header" href="#archive-contents" id="archive-contents">Archive Contents</a></h2>
<p><strong>Files</strong></p>
<ul>
<li><code>gopherbot</code> - the main executable, both a <em>daemon</em> and a <em>command-line interface</em></li>
<li><code>fetch-robot.sh</code> - a developer utility script for retrieving a robot for local development</li>
</ul>
<p><strong>Directories</strong></p>
<ul>
<li><code>connectors/</code> - loadable modules for protocol connectors, e.g. <em>slack</em></li>
<li><code>goplugins/</code> - loadable modules for non-default <em>Go</em> plugins</li>
<li><code>brains/</code> - lodable modules for non-default brain implementations</li>
<li><code>conf/</code> - the default configuration, overridden by individual robots</li>
<li><code>lib/</code> - API libraries for <code>bash</code>, <code>python</code> and <code>ruby</code></li>
<li><code>plugins/</code> - external script plugins</li>
<li><code>plugins/samples</code> - sample plugins that show API usage but aren't otherwise useful</li>
<li><code>tasks/</code> - a collection of pipeline task scripts</li>
<li><code>jobs/</code> - a collection of jobs for robot management (backup/restore) and CI/CD</li>
<li><code>helpers/</code> - helper scripts not directly called by the robot</li>
<li><code>resources/</code> - miscellaneous useful bits for a running robot, also <em>Dockerfiles</em></li>
<li><code>doc/</code> - the source for this documentation on <a href="https://lnxjedi.github.io/gopherbot/">github pages</a></li>
<li><code>robot.skel/</code> - the initial configuration for new robots</li>
<li><code>licenses/</code> - licenses for other packages used by <strong>Gopherbot</strong>, as required</li>
</ul>
<h1><a class="header" href="#privilege-separation" id="privilege-separation">Privilege Separation</a></h1>
<p><strong>Gopherbot</strong> need never run as root; all of it's privileges derive from the collection of encrypted secrets that a given robot collects. However, given that chat bots tend to accumulate an assortment of 3rd-party command plugins (like the included <strong>Chuck Norris</strong>, hell yeah), <strong>Gopherbot</strong> can be installed <em>setuid nobody</em>. This will cause the robot to run with a <code>umask</code> of <code>0022</code>, and external plugins will run by default as real/effective user <code>nobody</code>. Since <strong>Gopherbot</strong> child processes do not inherit environment from the parent daemon, this effectively prevents any potential access to the <code>GOPHER_ENCRYPTION_KEY</code>, and any ability to modify the robot's running environment.</p>
<blockquote>
<p><strong>NOTE!</strong> Be wary of a false sense of security! The process still retains it's primary GID and supplementary groups, so if e.g. your robot unix user belongs to the <code>wheel</code> group, external scripts running as <code>nobody</code> will still be able to <code>sudo</code>. Privilege separation is just a simple means of providing additional hardening for your robot's execution environment.</p>
</blockquote>
<h1><a class="header" href="#initial-configuration" id="initial-configuration">Initial Configuration</a></h1>
<p>This chapter discusses the process of setting up a new <strong>Gopherbot</strong> robot to connect to your team chat. Even if you use the <code>autosetup</code> plugin to create your new robot, you may want to read the section on manual installation for the technical detail it provides.</p>
<h1><a class="header" href="#robot-requirements" id="robot-requirements">Robot Requirements</a></h1>
<p>To set up your robot you'll need:</p>
<ul>
<li>Access to a Linux host with the <strong>Gopherbot</strong> software installed, or an environment where you can run and interact with the <a href="https://hub.docker.com/repository/docker/lnxjedi/gopherbot">official Gopherbot container image</a>
<ul>
<li>If you've signed up for an account on <a href="https://gitpod.io">Gitpod</a> (free accounts available), you can set up a new robot with the online <a href="https://gitpod.io/#https://github.com/lnxjedi/gopherbot">Gopherbot Gitpod Demo</a></li>
</ul>
</li>
<li>Credentials your robot can use to log in to your team chat; you can obtain a <strong>Gopherbot</strong>-compatible <a href="https://slack.com">Slack</a> token here: https://&lt;team-name&gt;.slack.com/services/new/bot</li>
<li>The name of a channel where your robot will run jobs by default, e.g. <code>clu-jobs</code> or <code>floyd-jobs</code></li>
<li>A completely empty (no README, LICENSE, etc.) public or private <em>git</em> repository, to store your robot, normally called <em>botname</em>-gopherbot; for example you can find <strong>Clu</strong> at <a href="https://github.com/parsley42/clu-gopherbot">https://github.com/parsley42/clu-gopherbot</a></li>
<li>If you're using a container and/or the <strong>autosetup plugin</strong>, you'll need to be able to configure read/write and read-only deploy keys for the robot's repository - this is widely supported with almost all of the major <em>git</em> hosting services and applications, check your repository settings or consult the documentation for your particular service</li>
</ul>
<blockquote>
<p>Note on Deploy Keys: If you are unfamiliar with ssh deploy keys, you should take a few minutes to read your git provider's documentation. A standard <em>Gopherbot</em> robot uses two deploy keys which are dedicated for use only with the robot's repository.</p>
</blockquote>
<p>The other requirements listed here are mainly items for consideration before setting up your <strong>Gopherbot</strong> robot.</p>
<h2><a class="header" href="#git-access" id="git-access">Git Access</a></h2>
<p><strong>Gopherbot</strong> version 2 integrates heavily with <em>git</em>, using <em>ssh</em> as the authentication mechanism. This guide and the setup plugin require a <em>git</em> repository that your robot can push to it with it's encrypted management ssh key (<code>manage_key</code>), which will be set up as a read-write deployment key. In addition to saving it's initial configuration to this repository, the standard robot configured with this guide will back up it's long-term memories to a separate <code>robot-state</code> branch.</p>
<blockquote>
<p>Note: The standard robot configured with this guide will have THREE DIFFERENT SSH KEYS, with the following uses:</p>
<ul>
<li>A dedicated encrypted <code>manage_key</code>, configured as a read-write deploy key for the robot's git repository; the robot will use this for saving it's initial configuration and backing up it's long-term memories from the <code>state/</code> directory</li>
<li>An unencrypted, read-only <code>deploy_key</code> that can be used for deploying your robot to e.g. a container or new VM</li>
<li>A default encrypted <code>robot_key</code> which the robot will use for all other CI/CD and remote ssh jobs; this is the key that should be associated with a git user, or machine user</li>
</ul>
</blockquote>
<p>Additionally, you may want to take advantage of <strong>Gopherbot</strong>'s CI/CD funcationality or ability to run git-driven jobs, which can be scheduled and/or on-demand; for example, <strong>Floyd</strong> updates the <code>gh-pages</code> branch of <a href="https://github.com/lnxjedi/gopherbot">lnxjedi/gopherbot</a> and also the <a href="https://github.com/lnxjedi">gopherbot-docker</a> repository after a successful build - see <a href="https://github.com/lnxjedi/gopherbot/blob/master/.gopherci/pipeline.sh">gopherbot/.gopherci/pipeline.sh</a>. It's worth considering how you'll set up your robot to access <em>git</em> repositories.</p>
<h3><a class="header" href="#machine-users" id="machine-users">Machine Users</a></h3>
<p>It's a good idea to create a machine account for your robot with the <em>git</em> service of your choice. Both <a href="https://github.com/floyd42">Floyd</a> and <a href="https://github.com/clu49">Clu</a> have machine accounts and belong to the <a href="https://github.com/lnxjedi">lnxjedi</a> organization on <a href="https://github.com">Github</a>. Having an organization and adding robots to teams makes it easy to provide flexible read/write access to repositories without having to jump through repository collaborator hoops.</p>
<h3><a class="header" href="#deploy-keys" id="deploy-keys">Deploy Keys</a></h3>
<p><em>Github</em>, at least, allows you to associate unique ssh deploy keys with a single repository, and even grant read-write access. The limitation of one repository per key pair increases administration overhead, and makes your robot's life more difficult. Though not fully documented here, it's possible to do this with <strong>Gopherbot</strong> by carefully managing the <code>KEYNAME</code> and <code>BOT_SSH_PHRASE</code> parameters (environment variables). See the section on <a href="botsetup/../pipelines/TaskEnvironment.html">task environment variables</a> for more information on parameter precedence.</p>
<p>The standard setup uses a read-write deploy key because it is the easiest means of configuring your robot initially, compatible with private repositories.</p>
<h3><a class="header" href="#user-ssh-keys" id="user-ssh-keys">User SSH Keys</a></h3>
<p>Git services also allow you to add multiple ssh keys to an individual user. It's also possible to add your robot's <code>robot_key.pub</code>, allowing your robot read-write access to all the repositories you have access to. This is the least recommended means of providing <em>git</em> repository write access for your robot, but may be the most expedient.</p>
<h2><a class="header" href="#brain-storage" id="brain-storage">Brain Storage</a></h2>
<p><strong>Gopherbot</strong> supports the notion of long-term memories, which are technically just key-blob stores. The included <code>lists</code> and <code>links</code> plugins both use long-term memory storage.</p>
<h3><a class="header" href="#file-backed-brains" id="file-backed-brains">File backed brains</a></h3>
<p>The standard configuration for a new robot uses the file-backed brain, with memories stored in <code>$GOPHER_HOME/state/brain</code>. You can schedule the included <code>backup</code> job to run periodically, and by default your robot will commit new memories as they're updated to a separate <code>robot-state</code> branch of it's configuration repository. If you want to store state in a separate repository, you can configure the <code>GOPHER_STATE_REPOSITORY</code> and optionally <code>GOPHER_STATE_BRANCH</code> for the included <code>backup</code> and <code>restore</code> jobs.</p>
<h3><a class="header" href="#dynamodb-brains" id="dynamodb-brains">DynamoDB brains</a></h3>
<p>As of this writing, the <a href="https://aws.amazon.com/">AWS</a> free tier provides a very generous 25GB of free DynamoDB storage - far more than any reasonable robot should use. See the section on <a href="botsetup/TODO">configuring the DynamoDB brain</a>.</p>
<h1><a class="header" href="#robot-directory-structure" id="robot-directory-structure">Robot Directory Structure</a></h1>
<p><strong>Gopherbot</strong> robots run in the context of a standard directory structure. The root of this directory structure is the <code>$GOPHER_HOME</code> for a given robot, and your robot starts by running the <em>gopherbot</em> binary in this directory. This section documents a standard directory structure; though it's possible to modify your particular configuration for different directories, only the standard structure is documented. There are no requirements on this directory except that it needs to be owned and writable by the UID running the <em>gopherbot</em> binary; it should not be located under <code>/opt/gopherbot</code>, to avoid complicating upgrades.</p>
<p>Note that in the standard directory structure, much of the content is automatically generated when a robot starts. Thanks to the <strong>bootstrap</strong> plugin in the default robot, a fully configured robot can be started with just a <code>.env</code> file in an empty directory. In the case of container-based robots, environment variables are provided by the container engine, and all content is generated during bootstrapping.</p>
<p>We'll use <a href="https://github.com/parsley42/clu-gopherbot">Clu</a> as example:</p>
<ul>
<li><code>clu/</code> - Top-level directory, <code>$GOPHER_HOME</code>; mostly empty of files and not containing a git repository (<code>.git/</code>)
<ul>
<li><code>.env</code> (user provided) - file containing environment variables for the robot, including it's encryption key and git clone url; on start-up the permissions will be forced to <code>0600</code>, or start-up will fail - note that this file may be absent in containers</li>
<li><code>gopherbot</code> (optional/generated) - convenience symlink to <code>/opt/gopherbot/gopherbot</code></li>
<li><code>known_hosts</code> (generated) - used by the robot to record the hosts it connects to over <em>ssh</em></li>
<li><code>robot.log</code> (generated) - log file created when the robot is run in <strong>terminal mode</strong></li>
<li><code>custom/</code> - directory for your robot's git repository, containing custom configuration, plugins, jobs and tasks; for <em>Clu</em>, this is <a href="https://github.com/parsley42/clu-gopherbot">https://github.com/parsley42/clu-gopherbot</a></li>
<li><code>state/</code> - for the standard file-backed brain, <strong>state/</strong> contains the robot's encrypted memories in a <strong>state/brain/</strong> directory; this directory is normally linked to the <code>robot-state</code> branch of the robot's configuration repository - for <em>Clu</em> this is <a href="https://github.com/parsley42/clu-gopherbot/tree/robot-state">https://github.com/parsley42/clu-gopherbot/tree/robot-state</a></li>
<li><code>history/</code> - the standard robot keeps job / plugin logs here</li>
<li><code>workspace/</code> - default location for the robot's workspace, where repositories are cloned, etc.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#the-custom-directory" id="the-custom-directory">The <code>custom/</code> directory</a></h2>
<p>The <code>custom/</code> directory is essentially <em>your robot</em>, and is generally used differently for development and deployment.</p>
<h3><a class="header" href="#during-development" id="during-development">During Development</a></h3>
<p>When developing jobs, tasks and plugins for your robot, you may provide the <code>.env</code> file, manually clone your robot's repository to <code>custom/</code>, and treat <code>state/</code> as disposable. A fairly standard workflow goes like this:</p>
<ol>
<li>Copy the robot's <code>.env</code> to an empty directory, with <code>GOPHER_PROTOCOL</code> commented out; when you start a standard robot this way, the bootstrap plugin will clone the robot to <code>custom/</code> and start in <strong>terminal connector</strong> mode
<ol>
<li>It's also possible, but generally unecessary, to manually clone</li>
</ol>
</li>
<li>Use the <strong>terminal</strong> connector, configured to mirror your team chat environment, for developing extensions for your robot</li>
<li>From the <code>custom/</code> directory, manually push changes with appropriate commit messages</li>
<li>Send an administrator <code>update</code> command to your production robot to pull down the latest changes and reload</li>
<li>Remove everything but <code>.env</code> until the next time you work on the robot</li>
</ol>
<p>For more information on developing, see the chapter on <a href="botsetup/../botprogramming.html">Developing Extensions</a>.</p>
<h3><a class="header" href="#deployment-to-production" id="deployment-to-production">Deployment to Production</a></h3>
<p>Production robots normally clone <code>custom/</code> the first time they start on a new VM or container, and update by an administrator <code>update</code> command.</p>
<blockquote>
<p>Production robots can also be configured to automatically update whenever the master branch updates. <strong>Floyd</strong>, for example, does this. See the <code>Triggers:</code> section in Floyd's <a href="https://github.com/parsley42/floyd-gopherbot/blob/master/conf/jobs/updatecfg.yaml">updatecfg.yaml file</a>.</p>
</blockquote>
<h1><a class="header" href="#quick-start-with-autosetup" id="quick-start-with-autosetup">Quick Start with Autosetup</a></h1>
<p>If you've installed the <a href="botsetup/../Installation.html">Gopherbot software</a> on a Linux host or VM, you can create a new robot quickly using the <strong>autosetup</strong> plugin. Using <strong>Clu</strong> as an example:</p>
<p><strong>1.</strong> Create an empty directory for your robot and use the <code>init</code> CLI command to retrieve an <code>answerfile.txt</code> template for your team chat protocol:</p>
<pre><code>[~]$ mkdir clu
[~]$ cd clu/
[clu]$ /opt/gopherbot/gopherbot init slack
Edit 'answerfile.txt' and run './gopherbot' with no arguments to generate your robot.
</code></pre>
<p><strong>2.</strong> Use the editor of your choice to edit the <code>answerfile.txt</code> template. Note that the answerfile template also contains documentation regarding the requirements for setting up your robot, including information on obtaining credentials for your robot to use with team chat.</p>
<blockquote>
<p>If you're not already familiar with <strong>ssh deploy keys</strong>, you should read up on the documentation for your <em>git</em> provider; see for example the <a href="https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys">Github deploy keys</a> documentation, which also has useful information about <a href="https://developer.github.com/v3/guides/managing-deploy-keys/#machine-users">machine users</a>.</p>
</blockquote>
<p><strong>3.</strong> Run <code>./gopherbot</code></p>
<pre><code>$ ./gopherbot 
2020/03/22 10:40:57 Info: Logging to robot.log
null connector: Initializing encryption and restarting...
2020/03/22 10:40:59 Info: Logging to robot.log
null connector: Continuing automatic setup...
null connector: Generating ssh keys...
...
null connector: ********************************************************


null connector: Initial configuration of your robot is complete. To finish
setting up your robot, and to add yourself as an administrator:
1) Open a second terminal window in the same directory as answerfile.txt; you'll
need this for completing setup.
2) Add a read-write deploy key to the robot's repository, using the contents of
'custom/ssh/manage_key.pub'; this corresponds to an encrypted 'manage_key' that
your robot will use to save and update it's configuration.
3) Add a read-only deploy key to the robot's repository, using the contents of
'custom/ssh/deploy_key.pub'; this corresponds to an unencrypted 'deploy_key'
(file removed) which is trivially encoded as the 'GOPHER_DEPLOY_KEY' in the
'.env' file. *Gopherbot* will use this deploy key, along with the
'GOPHER_CUSTOM_REPOSITORY', to initially clone it's repository during
bootstrapping.
4) Once these tasks are complete, in your second terminal window, run
'./gopherbot' without any arguments. Your robot should connect to your team
chat.
5) Invite your robot to #clu-jobs; slack robots will need to be invited to any
channels where they will be listening and/or speaking.
6) Open a direct message (DM) channel to your robot, and give this command to
add yourself as an administrator: &quot;add administrator LoveMyRobot&quot;; your
robot will then update 'custom/conf/slack.yaml' to make you an administrator,
and reload it's configuration.
7) Once that completes, you can instruct the robot to store it's configuration
in it's git repository by issuing the 'save' command.
8) Finally, copy the contents of the '.env' file to a safe place, with the
GOPHER_PROTOCOL commented out; this avoids accidentally connecting another
instance of your robot to team chat when run from a terminal window. With proper
configuration of your git repository, the '.env' file is all that's needed to
bootstrap your robot in to an empty *Gopherbot* container,
(https://hub.docker.com/r/lnxjedi/gopherbot) or on a Linux host or VM with the
*Gopherbot* software archive installed.

Now you've completed all of the initial setup for your *Gopherbot* robot. See
the chapter on deploying and running your robot
(https://lnxjedi.github.io/gopherbot/RunRobot.html) for information on day-to
day operations. You can stop the running robot in your second terminal window
using &lt;ctrl-c&gt;.
</code></pre>
<p><strong>4.</strong> Follow the instructions to add yourself as a robot administrator, and save your robot to it's <em>git</em> repository.</p>
<p>That's it - your robot is ready to start doing some work. The rest of this manual details deploying and managing your robot.</p>
<h1><a class="header" href="#setting-up-a-robot-with-gitpod" id="setting-up-a-robot-with-gitpod">Setting up a Robot with Gitpod</a></h1>
<p><a href="https://gitpod.io">Gitpod</a> is an online development environment with a generous free offering for use with public free software projects. You can use <strong>Gitpod</strong> to configure a new robot, or to develop <strong>Gopherbot</strong> on your own fork. Once you've signed up for an account, you can use the <strong>autosetup</strong> plugin from the <a href="https://gitpod.io/#https://github.com/lnxjedi/gopherbot">Gitpod Online Demo</a>.</p>
<p><strong>1.</strong> Use the <code>setup</code> command to create <code>answerfile.txt</code>, then press <code>&lt;enter&gt;</code> to exit:</p>
<pre><code>############################################################################
Welcome to the Gopherbot Demo. This will run Gopherbot
in terminal connector mode, where you can use the 
autosetup plugin to configure a new robot and store it
in a git repository.
############################################################################

2020/03/22 18:25:29 Logging to robot.log; warnings and errors duplicated to stdout
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration
was detected, you're connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try
'gopherbot --help'; otherwise feel free to play around with the default robot -
you can start by typing 'help'. If you'd like to start configuring a new robot,
type: ';setup &lt;protocol&gt;'.
c:general/u:alice -&gt; ;setup slack
general: Edit 'answerfile.txt' and re-run gopherbot with no arguments to
generate your robot.
Exiting (press &lt;enter&gt; ...)
c:general/u:alice -&gt; &lt;enter&gt;
Terminal connector finished
gitpod /workspace $
</code></pre>
<p><strong>2.</strong> Open <code>answerfile.txt</code> in the left pane, and edit, taking note of the embedded documentation, and setting the &quot;alias&quot; per CLI-based setup.</p>
<p><strong>3.</strong> Back in the <strong>/workspace</strong> tab, re-run <code>gopherbot</code> to continue setup (note the path to the binary is <code>./gopherbot/gopherbot</code>):</p>
<pre><code>gitpod /workspace $ ./gopherbot/gopherbot 
2020/03/22 18:38:46 Info: Logging to robot.log
null connector: Initializing encryption and restarting...
2020/03/22 18:38:48 Info: Logging to robot.log
null connector: Continuing automatic setup...
...
</code></pre>
<p><strong>4.</strong> Follow the instructions given (you'll need to scroll back) to set yourself up as an administrator and save the robot's configuration to <em>git</em>. Note that when you re-run gopherbot, the path is once again <code>./gopherbot/gopherbot</code>.</p>
<h1><a class="header" href="#setup-with-containers" id="setup-with-containers">Setup with Containers</a></h1>
<p>If you have an environment where you can run and interact with containers in a terminal window, using either <a href="https://www.docker.com/">Docker</a> or <a href="https://podman.io/">Podman</a>, you can supply an answerfile for using the <strong>autosetup</strong> plugin in a container.</p>
<h2><a class="header" href="#creating-answerfiletxt" id="creating-answerfiletxt">Creating <code>answerfile.txt</code></a></h2>
<p>For container-based installs, you can start an empty container and use the <code>setup</code> command to display an appropriate <code>answerfile.txt</code>, using <strong>Podman</strong> to set up <strong>slack</strong> as an example:</p>
<pre><code>$ podman run -it --name ansfile lnxjedi/gopherbot:latest
Info: PID == 1, spawning child
Info: Starting pid 1 signal handler
Logging to robot.log; warnings and errors duplicated to stdout
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration was detected, you're
connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try 'gopherbot --help';
otherwise feel free to play around with the default robot - you can start by typing 'help'. If you'd like
to start configuring a new robot, type: ';setup &lt;protocol&gt;'.
c:general/u:alice -&gt; ;setup slack
general: Copy to answerfile.txt:
&lt;-- snip answerfile.txt --&gt;
## Note on commenting conventions:
...
&lt;-- /snip --&gt;

Edit your 'answerfile.txt' and run the container with '--env-file answerfile.txt'.
Exiting (press &lt;enter&gt; ...)
c:general/u:alice -&gt; 
Terminal connector finished
# Remove the temporary container
$ podman container rm ansfile
</code></pre>
<p>Once you have your <code>answerfile.txt</code> you'll need to edit the file and set appropriate values for each <code>ANS_*</code> variable appropriate to your robot. Take care to use an unquoted value for <code>ANS_ROBOT_ALIAS</code>.</p>
<h2><a class="header" href="#starting-the-autosetup-plugin" id="starting-the-autosetup-plugin">Starting the <em>autosetup</em> plugin</a></h2>
<p>With a complete answerfile, you can start a <em>Gopherbot</em> container, passing the answerfile in for the environment. After the <em>autosetup</em> plugin runs and generates configuration, it'll pause and provide instructions for completing setup.</p>
<p><strong>With Podman</strong>:</p>
<pre><code>$ podman run -it --env-file answerfile.txt lnxjedi/gopherbot:latest
Trying to pull docker.io/lnxjedi/gopherbot:latest...
Getting image source signatures
...
Info: PID == 1, spawning child
Info: Starting pid 1 signal handler
Info: Logging to robot.log
null connector: Initializing encryption and restarting...
Info: Logging to robot.log
null connector: Continuing automatic setup...
...
</code></pre>
<p><strong>With Docker</strong>:</p>
<pre><code>$ docker run -it --env-file answerfile.txt lnxjedi/gopherbot:latest
Unable to find image 'lnxjedi/gopherbot:latest' locally
latest: Pulling from lnxjedi/gopherbot
...
Info: PID == 1, spawning child
Info: Starting pid 1 signal handler
Info: Logging to robot.log
null connector: Initializing encryption and restarting...
Info: Logging to robot.log
null connector: Continuing automatic setup...
...
</code></pre>
<p>... then follow the provided instructions to set yourself up as an administrator and save your robot's configuration to a <em>git</em> repository.</p>
<h2><a class="header" href="#finishing-up" id="finishing-up">Finishing Up</a></h2>
<p>After your robot has successfully saved it's configuration to it's <em>git</em> repository, you can press <code>&lt;ctrl-c&gt;</code> to stop the container, then remove it. Your robot is now ready to be <a href="botsetup/../RunRobot.html">deployed</a>.</p>
<h1><a class="header" href="#manual-setup" id="manual-setup">Manual Setup</a></h1>
<p>This section documents manual setup of a new robot custom configuration repository, using a Linux system or VM with the <strong>Gopherbot</strong> software <a href="botsetup/../install/ManualInstall.html">already installed</a>. Note that the documentation will often refer to a robot's <em>configuration repository</em>, even though using a <em>git</em> repository isn't strictly required.</p>
<blockquote>
<p>Note: This manual in general, and this section in particular, is not written as a complete step-by-step guide. Rather more of an outline, it skips a lot of e.g. <code>mkdir</code>, <code>sudo</code>, etc. If you're somewhat new to Linux systems administration, but have some experience with containers (e.g. <a href="https://www.docker.com/">Docker</a>), you might get more from the chapter on <a href="botsetup/ContainerSetup.html">Setup with Containers</a>. If you've signed up for a free <a href="https://gitpod.io">Gitpod</a> account, you can set up a new robot with the online <a href="https://gitpod.io/#https://github.com/lnxjedi/gopherbot">Gopherbot Gitpod Demo</a>.</p>
</blockquote>
<h1><a class="header" href="#create-the-gopher_home-directory" id="create-the-gopher_home-directory">Create the GOPHER_HOME directory</a></h1>
<p>Similar to an <a href="https://www.ansible.com/">Ansible</a> playbook, a <strong>Gopherbot</strong> robot is heavily oriented around a standard directory structure for a given robot. To begin with, create an empty directory for your robot; <code>/var/lib/robots</code> or <code>/home/robots</code> are good places for this. I normally name the directory after the robot; in this example setup, we'll use <code>clu</code>:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots$ mkdir clu
davidparsley@penguin:/home/robots$ cd clu/
davidparsley@penguin:/home/robots/clu$ ln -s /opt/gopherbot/gopherbot .
</code></pre>
<blockquote>
<p>Note that we've created a symlink to the <strong>Gopherbot</strong> binary for convenience, and this is required for the rest of this chapter.</p>
</blockquote>
<h1><a class="header" href="#create-the-initial-env-file" id="create-the-initial-env-file">Create the Initial .env File</a></h1>
<p>Though it's possible to run <strong>Gopherbot</strong> with neither encryption nor a <em>git</em> repository, this example documents the more common scenario. To begin with, create a <code>.env</code> file in your new directory with contents similar to the following:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ echo &quot;GOPHER_ENCRYPTION_KEY=SomeLongStringAtLeast32CharsOrItWillFail&quot; &gt; .env
</code></pre>
<p>Note that the robot will only use the first 32 chars of the encryption key, so no need to go crazy here. Keep your <code>GOPHER_ENCRYPTION_KEY</code> in a safe place, outside of any git repository. Your robot will need it, along with <code>$GOPHER_HOME/custom/binary-encrypted-key</code> (kept in the robot's repository), to decrypt it's secrets - such as a Slack token.</p>
<h1><a class="header" href="#initialize-encryption" id="initialize-encryption">Initialize Encryption</a></h1>
<p>Now that you've set the robot's encryption key, you can initialize encryption and create the binary key (<code>binary-encrypted-key</code>) encrypted with your <code>GOPHER_ENCRYPTION_KEY</code>. Start the default robot using the terminal connector, and the binary encryption key will be automatically created in <code>custom/binary-encrypted-key</code>; use <code>ctrl-d</code> to exit:</p>
<pre><code>davidparsley@penguin:/home/robots/clu$ ./gopherbot 
2020/03/09 18:29:43 Logging to robot.log; warnings and errors duplicated to stdout
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration was detected, you're
connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try 'gopherbot --help';
otherwise feel free to play around with the default robot - you can start by typing 'help'.
c:general/u:alice -&gt; exit
general: @alice Hasta la vista!
Terminal connector finished
davidparsley@penguin:/home/robots/clu$ ls custom/
binary-encrypted-key
</code></pre>
<h1><a class="header" href="#copy-and-modify-the-standard-robot" id="copy-and-modify-the-standard-robot">Copy and Modify the Standard Robot</a></h1>
<p>Now copy the contents of <code>robot.skel</code> from the distribution archive to the new <code>custom/</code> directory:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ cp -a /opt/gopherbot/robot.skel/* /opt/gopherbot/robot.skel/.??* custom/
</code></pre>
<blockquote>
<p>Note the <code>.??*</code> wildcard picks up any hidden files</p>
</blockquote>
<h3><a class="header" href="#41-encrypting-your-slack-token-and-other-secrets" id="41-encrypting-your-slack-token-and-other-secrets">4.1 Encrypting your Slack Token (and other secrets)</a></h3>
<p>With encryption initialized, you can use the <code>gopherbot encrypt</code> command to generate base64 encoded ciphertext. This ciphertext can then be placed in your configuration <code>yaml</code> files by using e.g. <code>{{ decrypt &quot;jfhPe8akfivTRnfeCxyIetdUl+Jb7hIWnjeVFiwLJarFHuW4TuSD7GQ3F0s2puuZ3JUotw==&quot; }}</code>. The default configuration assumes you'll only encrypt the portion of your slack token (from https://&lt;org&gt;.slack.com/services/new/bot) following the common <code>xoxb-</code> prefix. So, for a slack token of <code>xoxb-123-abc-XXXXX</code>, you would generate the ciphertext with:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ ./gopherbot encrypt 123-abc-XXXXX
FverBqdWHzHfEPDy/cQ8U9AJ3z4v8KdGSubDMALPfHIupwDLctDWQ1c=
</code></pre>
<p>(Note that we use <code>-l robot.log</code> to send some superfluous error messages to a log file)</p>
<p>Now edit your <code>conf/slack.yaml</code> file and replace <code>&lt;slackencrypted&gt;</code> with the ciphertext, e.g.:</p>
<pre><code class="language-yaml">  SlackToken: xoxb-{{ decrypt &quot;FverBqdWHzHfEPDy/cQ8U9AJ3z4v8KdGSubDMALPfHIupwDLctDWQ1c=&quot; }}
</code></pre>
<h3><a class="header" href="#42-editing-standard-configuration" id="42-editing-standard-configuration">4.2 Editing Standard Configuration</a></h3>
<p>Now you need to edit the configuration files under <code>custom/</code>, replacing most of the <code>&lt;replacevalue&gt;</code> instances with values for your robot.</p>
<p>In <code>custom/conf/robot.yaml</code>:</p>
<ul>
<li>Replace <code>&lt;botname&gt;</code> with the name of your robot, e.g. <code>clu</code></li>
<li>Replace <code>&lt;botemail&gt;</code> with an email address for your robot; will be used for &quot;from:&quot;</li>
<li>Replace <code>&lt;botfullname&gt;</code> with a full name, informational only; e.g. &quot;Clu Gopherbot&quot;</li>
<li>Replace <code>&lt;botalias&gt;</code> with a single-character alias for addressing your robot from the list <code>'&amp;!;:-%#@~&lt;&gt;/*+^\$?\[]{}'</code> (&quot;;&quot; is good for this)</li>
<li>Replace <code>&lt;sshencrypted&gt;</code> encrypted ciphertext for a 16+ char ssh passphrase for your robot, generated with <code>./gopherbot encrypt</code> as above</li>
</ul>
<p>In <code>custom/conf/slack.yaml</code>:</p>
<ul>
<li>Leave alone for now; you'll replace <code>&lt;adminusername&gt;</code> and <code>&lt;adminuserid&gt;</code> later, after your robot has successfully connected</li>
</ul>
<p>In <code>custom/conf/terminal.yaml</code>:</p>
<ul>
<li>Replace <code>&lt;botalias&gt;</code> with your robot's single-character alias</li>
</ul>
<p>In <code>custom/git/config</code>, replace the values for <code>&lt;botfullname&gt;</code> and <code>&lt;botemail&gt;</code>; these will be used when your robot performs a <code>git commit</code>.</p>
<h1><a class="header" href="#generate-ssh-keypairs" id="generate-ssh-keypairs">Generate SSH Keypairs</a></h1>
<p>Now generate the ssh keypairs for your robot - use the passphrase you encrypted previously for generating both <code>manage_key</code> and <code>robot_key</code>; finally create an unencrypted <code>deploy_key</code> and move it out of the repo:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ mkdir custom/ssh
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;VeryLovelyNicePassword&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/manage_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/manage_key.
Your public key has been saved in custom/ssh/manage_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;VeryLovelyNicePassword&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/robot_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/robot_key.
Your public key has been saved in custom/ssh/robot_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/deploy_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/deploy_key.
Your public key has been saved in custom/ssh/deploy_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ mv custom/ssh/deploy_key .
</code></pre>
<blockquote>
<p>Note that deploy_key is unencrypted, and not kept in the robot's repository which is rooted in the <code>custom</code> directory.</p>
</blockquote>
<h1><a class="header" href="#finish-the-env-file" id="finish-the-env-file">Finish the <code>.env</code> File</a></h1>
<p>First, use <code>tr</code> to dump a flattened version of the <code>deploy_key</code> private key to the <code>.env</code> file:</p>
<pre><code>$ cat custom/ssh/deploy_key | tr ' \n' '_:' &gt;&gt; .env
</code></pre>
<p>Now edit the <code>.env</code> file and stick <code>GOPHER_DEPLOY_KEY=</code> in front of that mess, and add values for <code>GOPHER_PROTOCOL</code> and <code>GOPHER_CUSTOM_REPOSITORY</code>. Using <strong>Clu</strong> as an example, the end result should look something like this:</p>
<pre><code>GOPHER_ENCRYPTION_KEY=&lt;redacted&gt;
GOPHER_PROTOCOL=slack
GOPHER_CUSTOM_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
GOPHER_DEPLOY_KEY=-----BEGIN_OPENSSH_PRIVATE_KEY-----:lksjflsjdf&lt;muchjunkremoved&gt;ljsdflsjdf:-----END_OPENSSH_PRIVATE_KEY-----:
</code></pre>
<blockquote>
<p>Note that <code>GOPHER_DEPLOY_KEY</code> is a very long line, a bit over 2k. The format with spaces and newlines replaced was chosen as most compatible with the shell, docker, and <code>.env</code>-reading libraries.</p>
</blockquote>
<h1><a class="header" href="#connect-robot-to-team" id="connect-robot-to-team">Connect Robot to Team</a></h1>
<p>Now your robot should be able to connect to team chat, and respond to your messages:</p>
<pre><code class="language-shell">davidparsley@penguin:~/git/clu$ GOPHER_PROTOCOL=slack ./gopherbot 
2020/02/19 15:50:00 Initialized logging ...
2020/02/19 15:50:00 Loaded initial private environment from '.env'
...
2020/02/19 15:50:20 Info: Robot is initialized and running
</code></pre>
<p>Now you can <code>/invite</code> your robot to the <code>#general</code> channel, and get the information you need from Slack to configure yourself as the robot's administrator:</p>
<pre><code>#general me-&gt; clu, whoami
#general clu-&gt; You are 'Slack' user 'parsley/U0JLW8EMS', speaking in channel 'general/C0JLW8EP6', email address: parsley@linuxjedi.org
</code></pre>
<p>Given this reply, you would replace <code>&lt;adminusername&gt;</code> with <code>parsley</code> and <code>&lt;adminuserid&gt;</code> with <code>U0JLW8EMS</code> in <code>custom/conf/slack.yaml</code>. Now you can stop the robot with <code>ctrl-c</code> and restart with access to administrative commands.</p>
<h1><a class="header" href="#saving-your-robot-to-git" id="saving-your-robot-to-git">Saving Your Robot to Git</a></h1>
<p>At this point the contents of <code>custom/</code> should be committed to a git repository, and your robot should be run with <code>GOPHER_CUSTOM_REPOSITORY=&lt;clone-url&gt;</code>, where the <code>clone-url</code> is for use with ssh credentials. You can perform this step manually, or set up your robot's deploy keys and let the robot save it's own configuration.</p>
<h2><a class="header" href="#configuring-deploy-keys" id="configuring-deploy-keys">Configuring Deploy Keys</a></h2>
<p>As noted in <a href="botsetup/Requirements.html#git-access">requirements</a>, the standard robot has three ssh keypairs by default, two of which are configured as deploy keys for the repository.</p>
<p>Find the <strong>deploy keys</strong> section for the robot's git repository, then:</p>
<ul>
<li>Configure a <strong>read-write</strong> deploy key with the contents of <code>custom/ssh/manage_key.pub</code>; this corresponds to the encrypted <code>manage_key</code> the robot can use to save it's own configuration, or back up it's state / brain</li>
<li>Configure a <strong>read-only</strong> deploy key with the contents of <code>custom/ssh/deploy_key.pub</code>; this corresponds to the unencrypted <code>GOPHER_DEPLOY_KEY</code> in the <code>.env</code> file, and the gopherbot <strong>bootstrap</strong> plugin can use this to deploy your robot to e.g. a generic container or new VM</li>
</ul>
<p>Once you've set up the deploy keys, open a private chat with your robot and tell it to <code>save</code>; if all has gone well, your robot will push the contents of <code>custom/</code> to it's git repository, and should be ready to go.</p>
<p>This setup allows for a common workflow where the robot is running in a container, VM, or server in your infrastructure, and updates to robot configuration are made by updating the robot's configuration repository, followed by an administrator <code>update</code> command, (e.g. <code>clu, update</code>). The <code>update</code> command will cause the robot to <code>git pull</code> it's custom configuration, then perform a reload and report any errors.</p>
<h1><a class="header" href="#finished" id="finished">Finished</a></h1>
<p>That's it! You've created the initial configuration for your <strong>Gopherbot</strong> robot, which you can now customize and deploy.</p>
<h1><a class="header" href="#upgrading-from-version-1" id="upgrading-from-version-1">Upgrading from Version 1</a></h1>
<p>The following sections detail the required and optional changes for upgrading a robot from version 1 to version 2. Over the course of developing version 2, there were several intermediary states for different configuration options that are not described here. If you need information on upgrading from any of these intermediary states, please <a href="https://github.com/lnxjedi/gopherbot/issues/new">open an issue</a>.</p>
<p>Note that this chapter is not exhaustive in the changes required for updating your robot. The best approach would be to set up a new robot, then port your customizations from version 1; the API hasn't changed, but there are configuration changes described here. Another approach might be to set up a new test robot to understand the v2 robot architecture, then examine the contents of <code>robot.skel</code> and incrementally update your robot to the v2 standard.</p>
<h1><a class="header" href="#required-bot-info" id="required-bot-info">Required Bot Info</a></h1>
<p>Earlier versions of <strong>Gopherbot</strong> expected to get info about the robot - name, handle, etc. - from the protocol connector; however, that can't be counted on. For your robot to respond to a command like <code>floyd, ping</code>, it will need a minimal <code>BotInfo</code> section in <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">BotInfo:
  UserName: floyd
</code></pre>
<p>To provide other information about the robot to the <code>GetBotAttribute()</code> method, you might want to fill out the entire structure:</p>
<pre><code class="language-yaml">BotInfo:
  UserName: floyd
  Email: floyd@linuxjedi.org
  FullName: Floyd Gopherbot
  FirstName: Floyd
  LastName: Gopherbot
</code></pre>
<p>The robot's single-character <code>Alias</code> is still specified by itself, as before; e.g. <code>Alias: &quot;;&quot;</code>.</p>
<h1><a class="header" href="#external-plugin-configuration" id="external-plugin-configuration">External Plugin Configuration</a></h1>
<p>ExternalPlugins were formerly a list, but are now a hash, so:</p>
<pre><code class="language-yaml">ExternalPlugins:
- Name: chuck
  Path: plugins/chuck.rb
</code></pre>
<p>becomes:</p>
<pre><code class="language-yaml">ExternalPlugins:
  &quot;chuck&quot;:
    Path: plugins/chuck.rb
</code></pre>
<p>This allows all default configuration in the installation to be flexibly modified for a particular robot, using the new configuration merging.</p>
<h1><a class="header" href="#custom-configuration-directory" id="custom-configuration-directory">Custom Configuration Directory</a></h1>
<p>Version 2's configuration layout is heavily oriented towards an all-in-one robot directory, <code>$GOPHER_HOME</code>, with brain, job logs, workspaces, and others as subdirectories. It standardizes the location of the custom configuration directory (repository) to <code>$(pwd)/custom</code> (a.k.a. <code>$GOPHER_HOME/custom</code>). While setting the location with <code>-c &lt;dir&gt;</code> or via the <code>GOPHER_CONFIGDIR</code> environment variable are still supported, existing installations should locate custom configuration in a directory named <code>custom/</code>, with the robot started from the parent directory. See the <a href="upgrade/../InstallOverview.html">Installation Overview</a> for more information on the standard directory structure.</p>
<p>If your configuration is already in a repository, and the previous updates have already been made, then you can probably just run <code>/opt/gopherbot/gopherbot</code> from an empty directory and use the new setup plugin to bootstrap your robot.</p>
<h2><a class="header" href="#optional-rename-of-gopherbotyaml" id="optional-rename-of-gopherbotyaml">Optional rename of <code>gopherbot.yaml</code></a></h2>
<p>Version 2 defaults to <code>robot.yaml</code> for the name of the main configuration file for your robot. For backwards-compatibility, gopherbot will fall back to <code>gopherbot.yaml</code>.</p>
<h1><a class="header" href="#main-configuration-file-rename" id="main-configuration-file-rename">Main Configuration File Rename</a></h1>
<p>To make naming more consistent, <strong>Gopherbot</strong> v2 and the standard robot now expect to find <code>conf/robot.yaml</code> for the robot's main configuration file. It should still fall back to the old <code>conf/gopherbot.yaml</code> if <code>robot.yaml</code> isn't present, but for maximum forward-compatibility the old <code>gopherbot.yaml</code> should be renamed.</p>
<h2><a class="header" href="#early-encryption-initialization" id="early-encryption-initialization">Early Encryption Initialization</a></h2>
<p><strong>Gopherbot</strong> uses two separate keys for encrypting and decrypting secret data:</p>
<ul>
<li>The start-up key, normally 32 printable <code>ASCII</code> characters, used only for decrypting the binary, 32-byte random encryption key</li>
<li>The permanent runtime encryption key, 32 random bytes generated on the first run </li>
</ul>
<p>In version 1 and early snapshots of version 2, the runtime key was stored in the brain, and encryption was only initialized after the robot's brain provider and protocol connector. Secrets for these had to be provided in the environment, or unencrypted in <code>robot.yaml</code>. Version 2 addresses this by storing the binary encrypted runtime key in a <code>base64</code> encoded file, <code>custom/binary-encrypted-key</code>. This allows storing encrypted values for e.g. the <em>slack token</em> or <em>AWS credentials</em> in <code>robot.yaml</code>, and only needing to provide the start-up <code>GOPHER_ENCRYPTION_KEY</code> in the environment, or in an external environment file - <code>$GOPHER_HOME/.env</code> or <code>$GOPHER_HOME/private/environment</code>.</p>
<p>For a robot instance with a file-backed brain, the following command can be used to generate the version 2 key file:</p>
<pre><code class="language-bash">$ cat /path/to/brain/bot:encryptionKey | base64 -w 0 &gt; /path/to/custom/binary-encrypted-key
</code></pre>
<p>This file can then be committed to the custom configuration repository.</p>
<h2><a class="header" href="#default-brain-encryption" id="default-brain-encryption">Default Brain Encryption</a></h2>
<p>In version 2, <strong>Gopherbot</strong> defaults to an encrypted brain, which requires a <code>GOPHER_ENCRYPTION_KEY</code> to be set. To run your robot without brain encryption, you need to explicitly turn it off in your custom <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">EncryptBrain: false
</code></pre>
<h1><a class="header" href="#long-term-memories" id="long-term-memories">Long-Term Memories</a></h1>
<p>Version 1 robots allowed long-term memory keys to contain <code>:</code> in the name, now disallowed as it is used as an internal separator. Memories with this character will need to be renamed, and plugins will need to be updated.</p>
<h1><a class="header" href="#deploying-and-running-your-robot" id="deploying-and-running-your-robot">Deploying and Running Your Robot</a></h1>
<p><strong>Gopherbot</strong> is very flexible about being able to bootstrap and run in a variety of environments, and is designed to be remotely updated via git integration. This chapter discusses the three primary ways you'll run your robot:</p>
<ul>
<li>It's helpful if you have access to a Linux or Mac workstation, VM, or container where you can bootstrap your robot and use <a href="deploy/CLI.html">CLI commands</a>
<ul>
<li>Microsoft's free <a href="https://code.visualstudio.com/">VisualStudio Code</a> has a remote extension that will allow you to edit files directly in a container, and the robot's adminstrator <strong>save</strong> command can push updates to the robot's git repository</li>
<li>If you robot is stored in a public <a href="https://github.com">Github</a> repository, you can use <a href="https://gitpod.io">Gitpod</a> to work with your robot at the CLI</li>
</ul>
</li>
<li>The <code>resources/</code> directory contains a template <code>robot.service</code> that can be used to run your robot on a Linux host <a href="deploy/systemd.html">using Systemd</a></li>
<li>Using <a href="https://podman.io">Podman</a>, <a href="https://docker.com">Docker</a>, <a href="https://kubernetes.io">Kubernetes</a>, or any number of other container-centric environments, you can bootstrap and run your robot <a href="deploy/Container.html">in a Container</a></li>
</ul>
<h2><a class="header" href="#the-env-file" id="the-env-file">The <code>.env</code> file</a></h2>
<p>Regardless of your running environment, you'll need a copy of your robot's <code>.env</code> file generated when you configured your robot. If <code>GOPHER_PROTOCOL</code> is set, you might want it commented out so you can run your robot with the <strong>terminal</strong> connector, instead of having it connect to your team chat. For <strong>Clu</strong>, the <code>.env</code> looks like this:</p>
<pre><code>GOPHER_ENCRYPTION_KEY=&lt;redacted&gt;
#GOPHER_PROTOCOL=slack
GOPHER_CUSTOM_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
GOPHER_DEPLOY_KEY=-----BEGIN_OPENSSH_PRIVATE_KEY-----:&lt;much junk removed&gt;:-----END_OPENSSH_PRIVATE_KEY-----:
</code></pre>
<h1><a class="header" href="#cli-operation" id="cli-operation">CLI Operation</a></h1>
<p>The <code>gopherbot</code> binary can run as both a daemon and a command-line interface, mainly used for generating encrypted secrets. This section discusses running your robot from the command-line.</p>
<h2><a class="header" href="#setting-up-for-cli-operation" id="setting-up-for-cli-operation">Setting up For CLI Operation</a></h2>
<p>The next sections describe several methods of running the <strong>Gopherbot</strong> CLI. Be sure <code>GOPHER_PROTOCOL</code> is commented out in your <code>.env</code> file, to prevent your robot from connecting to your team chat.</p>
<h1><a class="header" href="#local-install" id="local-install">Local Install</a></h1>
<p>If you've <a href="deploy/../install/ManualInstall.html">installed Gopherbot</a> on a Linux host, you can just create an empty directory, add your <code>.env</code> file, and start <strong>gopherbot</strong> in terminal mode - letting the <strong>bootstrap</strong> plugin retrieve the rest of your robot:</p>
<pre><code>[parse@hakuin ~]$ mkdir clu
[parse@hakuin ~]$ cd clu/
[parse@hakuin clu]$ vim .env
[parse@hakuin clu]$ ln -s /opt/gopherbot/gopherbot .
[parse@hakuin clu]$ ./gopherbot 
2020/02/20 14:14:20 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 14:14:20 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 14:14:20 Initialized logging ...
...
2020/02/20 14:14:21 Info: Robot is initialized and running
2020/02/20 14:14:21 Info: Creating bootstrap pipeline for git@github.com:parsley42/clu-gopherbot.git
2020/02/20 14:14:21 Warning: /home/parse/clu/custom/git/config not found, git push will fail
2020/02/20 14:14:21 Info: ssh-init starting in bootstrap mode
2020/02/20 14:14:21 Warning: Output from stderr of external command '/home/gopherbot/tasks/ssh-init.sh': Identity added: (stdin) (parse@hakuin.localdomain)
2020/02/20 14:14:22 Warning: Output from stderr of external command '/home/gopherbot/tasks/git-clone.sh': Cloning into '.'...
2020/02/20 14:14:22 Warning: Repository pipeline not found in job  (wd: /home/parse/clu/custom, repo: not set), ignoring
2020/02/20 14:14:22 Info: Restart triggered in pipeline 'bootstrap' with 0 pipelines running (including this one)
2020/02/20 14:14:22 Info: Stop called with 1 pipelines running
2020/02/20 14:14:22 Info: Restarting...
2020/02/20 14:14:22 Info: Stopping signal handler
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
clu-jobs: Starting restore of robot state...
OUT: Agent pid 11337
ERR: Identity added: /home/parse/clu/custom/ssh/manage_key (parse@hakuin.localdomain)
ERR: Cloning into '.'...
ERR: Warning: Permanently added the RSA host key for IP address '192.30.253.112' to the list of known hosts.
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 11337 killed;
c:general/u:alice -&gt; &lt;ctrl-d&gt;
general: @alice Adios
Terminal connector finished
[parse@hakuin clu]$ gopherbot list
pythondemo:memory
links:links
lists:listmap
...
</code></pre>
<h1><a class="header" href="#container-operation" id="container-operation">Container Operation</a></h1>
<p>The next best option to a local install is running the CLI in a container; just drop your robot's <code>.env</code> file in a directory and run the one of the <a href="https://hub.docker.com/r/lnxjedi/gopherbot">stock images</a>, overriding the entrypoint. Using <code>podman</code> as an example:</p>
<pre><code>[parse@hakuin ~]$ mkdir clu
[parse@hakuin ~]$ cd clu/
[parse@hakuin clu]$ vim .env
[parse@hakuin clu]$ podman run -it --entrypoint /bin/bash --env-file .env lnxjedi/gopherbot:latest
daemon@af2a1924e1ff:~$ gopherbot
2020/02/20 19:23:32 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 19:23:32 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 19:23:32 Initialized logging ...
...
2020/02/20 19:26:29 Info: Robot is initialized and running
2020/02/20 19:26:29 Info: Creating bootstrap pipeline for git@github.com:parsley42/clu-gopherbot.git
2020/02/20 19:26:29 Warning: /home/custom/git/config not found, git push will fail
2020/02/20 19:26:29 Info: ssh-init starting in bootstrap mode
2020/02/20 19:26:29 Warning: Output from stderr of external command '/opt/gopherbot/tasks/ssh-init.sh': Identity added: (stdin) (parse@hakuin.localdomain)
2020/02/20 19:26:30 Warning: Output from stderr of external command '/opt/gopherbot/tasks/git-clone.sh': Cloning into '.'...
2020/02/20 19:26:30 Warning: Repository pipeline not found in job  (wd: /home/custom, repo: not set), ignoring
2020/02/20 19:26:30 Info: Restart triggered in pipeline 'bootstrap' with 0 pipelines running (including this one)
2020/02/20 19:26:30 Info: Stop called with 1 pipelines running
2020/02/20 19:26:30 Info: Restarting...
2020/02/20 19:26:30 Info: Stopping signal handler
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
OUT: GOPHER_PROTOCOL is terminal
clu-jobs: Starting restore of robot state...
OUT: Agent pid 440
ERR: Identity added: /home/custom/ssh/manage_key (parse@hakuin.localdomain)
ERR: Cloning into '.'...
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 440 killed;
c:general/u:alice -&gt; &lt;ctrl-d&gt;
general: @alice Sayonara!
Terminal connector finished
daemon@af2a1924e1ff:~$ gopherbot list
pythondemo:memory
links:links
lists:listmap
...
...
</code></pre>
<h1><a class="header" href="#using-gitpod" id="using-gitpod">Using Gitpod</a></h1>
<p><a href="https://gitpod.io">Gitpod</a> is a pretty good way to work with your robot's CLI, with the caveat that your robot needs to be stored in a public repository to use the free service. The standard robot includes a <code>.gitpod.yml</code> file, so if you've already signed up for <strong>Gitpod</strong> you can just visit: https://gitpod.io/#https://github.com/&lt;org&gt;/&lt;robot-repo&gt;, or click the <strong>Gitpod</strong> button if you've installed the <a href="https://www.gitpod.io/docs/browser-extension">browser extension</a>.</p>
<p>When your workspace opens, you can use the <code>File</code> menu to create a new <code>.env</code> file directly in the <code>/workspace</code> folder. Once you've pasted in the contents and saved the file, just start the robot in the lower terminal pane:</p>
<pre><code>gitpod /workspace $ gopherbot 
2020/02/20 19:52:01 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 19:52:01 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 19:52:01 Initialized logging ...
...
2020/02/20 19:52:02 Info: Robot is initialized and running
2020/02/20 19:52:02 Info: Creating bootstrap pipeline for git@github.com:parsley42/clu-gopherbot.git
2020/02/20 19:52:02 Warning: /workspace/custom/git/config not found, git push will fail
2020/02/20 19:52:02 Info: ssh-init starting in bootstrap mode
2020/02/20 19:52:02 Warning: Output from stderr of external command '/opt/gopherbot/tasks/ssh-init.sh': Identity added: (stdin) (parse@hakuin.localdomain)
2020/02/20 19:52:03 Warning: Output from stderr of external command '/opt/gopherbot/tasks/git-clone.sh': Cloning into '.'...
2020/02/20 19:52:03 Warning: Repository pipeline not found in job  (wd: /workspace/custom, repo: not set), ignoring
2020/02/20 19:52:03 Info: Restart triggered in pipeline 'bootstrap' with 0 pipelines running (including this one)
2020/02/20 19:52:03 Info: Stop called with 1 pipelines running
2020/02/20 19:52:03 Info: Restarting...
2020/02/20 19:52:03 Info: Stopping signal handler
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
OUT: GOPHER_PROTOCOL is terminal
clu-jobs: Starting restore of robot state...
OUT: Agent pid 1764
ERR: Identity added: /workspace/custom/ssh/manage_key (parse@hakuin.localdomain)
ERR: Cloning into '.'...
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 1764 killed;
c:general/u:alice -&gt; &lt;ctrl-d&gt;
general: @alice Later gator!
Terminal connector finished
gitpod /workspace $ gopherbot list
links:links
pythondemo:memory
lists:listmap
...
</code></pre>
<h1><a class="header" href="#encrypting-secrets" id="encrypting-secrets">Encrypting Secrets</a></h1>
<p>Once you've set up CLI access, you can use the <code>gopherbot</code> binary to encrypt various secrets:</p>
<pre><code class="language-shell">gitpod /workspace $ gopherbot encrypt foobarbaz
UK+T6/HocaR9AAD8Ty2giHdNR3r03pbffpah/rk+MZumPK4Y3A==
</code></pre>
<h1><a class="header" href="#running-with-systemd" id="running-with-systemd">Running with Systemd</a></h1>
<p>One way of running your robot is to use a <strong>systemd</strong> unit file on a systemd-managed Linux host:</p>
<ul>
<li>Copy <code>resources/robot.service</code> to <code>/etc/systemd/system/&lt;botname&gt;.service</code> and edit with values for your system; you'll need to create a local user, and a directory for your robot that the user can write to</li>
<li>Reload <code>systemd</code> with <code>systemctl daemon-reload</code></li>
<li>Enable the service with <code>systemctl enable &lt;botname&gt;</code></li>
<li>Place your robot's <code>.env</code> in the robot's home directory, mode <code>0400</code>, owned by the robot user; you can leave <code>GOPHER_PROTOCOL</code> commented out, since the value should be set in the <code>&lt;botname&gt;.service</code> file</li>
<li>Start the service: <code>systemctl start &lt;botname&gt;</code></li>
</ul>
<p>That's it! Your robot should start and connect to your team chat.</p>
<h1><a class="header" href="#running-in-a-container" id="running-in-a-container">Running in a Container</a></h1>
<p>A major goal for <strong>Gopherbot</strong> v2 was container-native operation, and the ability to run your robot with all it's functionality and state/context, without requiring a persistent volume mount or a custom image with your robot baked-in. You can launch your robot using any of the <a href="https://hub.docker.com/r/lnxjedi/gopherbot">stock images</a>; you should only need to create a custom image if your robot requires specific extra tools or libraries to do it's work, such as e.g. an ldap client or specific python module.</p>
<p>This section doesn't delve in to the specifics of running your robot in any particular container environment. Whether your robot runs as a persistent container on a Docker host, or as a managed container in a Kubernetes or Openshift cluster - or elsewhere - the same principles apply. If you're planning on deploying in a container, it is presumed that you're already running other containerized workloads, and can provide the requirements by common means for your container environment.</p>
<p>The contents of your robot's <code>.env</code> file are all that's needed - the built-in <strong>bootstrap</strong> plugin will use your robot's <code>deploy_key</code> key to clone it's <code>GOPHER_CUSTOM_REPOSITORY</code> configuration repository, then use the <code>GOPHER_ENCRYPTION_KEY</code> to decrypt the <code>manage_key</code> ssh private key to restore file-backed memories if you use the default <code>file</code> brain for the standard robot.</p>
<p>You can find example <code>docker</code> commands and comments regarding usage in <code>resources/docker/Makefile</code>.</p>
<h2><a class="header" href="#container-considerations" id="container-considerations">Container Considerations</a></h2>
<h3><a class="header" href="#backing-up-state-and-memories" id="backing-up-state-and-memories">Backing up State and Memories</a></h3>
<p>The standard robot includes a commented-out definition for scheduling the <code>backup</code> job in the stock <code>robot.yaml</code>. You should uncomment this and set a relatively frequent schedule for backups. The underlying job uses <code>git status --porcelain</code> to determine if a backup is needed, so there's little overhead in the case where memories don't change frequently. Since new memories tend to come in batches - for instance, adding bookmarks with the links plugin - an hourly schedule probably strikes a good balance between keeping the <code>robot-state</code> branch updated while not creating too many superfluous commits.</p>
<p>The <strong>bootstrap</strong> plugin will trigger a restore during start-up, so launching your robot into a new, empty container should restore it's state and memories automatically. Take care that you don't run multiple instances of your robot; not only would this run the risk of corrupting state, but this can produce strange behavior in your team chat.</p>
<h3><a class="header" href="#providing-environment-variables" id="providing-environment-variables">Providing Environment Variables</a></h3>
<p>When launching your robot in a container, you'll need to provide the environment variables defined in the robot's <code>.env</code> file. There are two primary ways of accomplishing this:</p>
<ul>
<li>Both <code>docker</code> and <code>podman</code> allow you to set environment variables with a <code>--env-file .env</code> argument</li>
<li>Container orchestration environments or e.g. <code>docker-compose</code> provide other means of providing these values; take care that the value for <code>GOPHER_ENCRYPTION_KEY</code> doesn't get committed to a repository</li>
</ul>
<h3><a class="header" href="#setting-the-gopher_protocol-environment-variable" id="setting-the-gopher_protocol-environment-variable">Setting the <code>GOPHER_PROTOCOL</code> Environment Variable</a></h3>
<p>When starting <code>gopherbot</code> at the CLI, or using systemd, the value for <code>GOPHER_PROTOCOL</code> should be commented out in the <code>.env</code>; this value is required for launching in a container so that your robot will start and connect to your team chat.</p>
<h1><a class="header" href="#robot-basics" id="robot-basics">Robot Basics</a></h1>
<p>Central to the design of Gopherbot is the idea that once your robot connects to your team chat and joins one or more channels, the robot &quot;hears&quot; every message in those channels, just as a user would. Every time the robot hears a message<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<ul>
<li>It checks to see if the message was directed to it by name</li>
<li>It checks for &quot;ambient&quot; message matches</li>
<li>It checks for matching job triggers</li>
</ul>
<p>This chapter focuses on the first case - sending commands directly to your robot.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Depending on the configured values for <code>IgnoreUnlistedUsers</code> and <code>IgnoreUsers</code>, messages may be dropped entirely without any processing. This would show up in the logs at log level <strong>Debug</strong>.</p>
</div>
<h1><a class="header" href="#addressing-your-robot-and-using-ping" id="addressing-your-robot-and-using-ping">Addressing your Robot and using Ping</a></h1>
<p>Most chat platforms provide some kind of capability for &quot;mentioning&quot; your robot using an <code>@...</code> syntax; normally, prefixing a message with your robot's mention name will cause it to process the message as a command. For maximum compatibility when switching chat platforms, <strong>Gopherbot</strong> robots all have a regular 'name' like 'Floyd' which they recognize, as well as a single-character 'alias'. To verify your robot &quot;hears&quot; messages, you would normally use the single &quot;ping&quot; command, which defaults to being available in all the channels where the robot is present. Here are some examples of using &quot;ping&quot; with <strong>Floyd</strong>, whose alias is <code>;</code>:</p>
<pre><code>c:general/u:alice -&gt; floyd, ping
general: @alice PONG
c:general/u:alice -&gt; ;ping
general: @alice PONG
c:general/u:alice -&gt; floyd ping
general: @alice PONG
c:general/u:alice -&gt; floyd: ping
general: @alice PONG
c:general/u:alice -&gt; ping, floyd
general: @alice PONG
c:general/u:alice -&gt; ping
c:general/u:alice -&gt; floyd
general: @alice PONG
c:general/u:alice -&gt; ping
c:general/u:alice -&gt; ;
general: @alice PONG
c:general/u:alice -&gt; ping floyd
c:general/u:alice -&gt;
</code></pre>
<p>The last three examples are instructive: 1) if you type a command for your robot but forget to address the robot, typing the robot's name or alias alone as your next message will cause it to process your previous message as a command if done within a short period of time. 2) While &quot;&lt;command&gt;, &lt;botname&gt;&quot; is considered a command, &quot;&lt;command&gt; &lt;botname&gt;&quot; (without a comma) is not; this allows the robot to be discussed (e.g. &quot;try using floyd&quot;) without the robot parsing it as a command.</p>
<h1><a class="header" href="#command-matching-and-command-not-found" id="command-matching-and-command-not-found">Command Matching and &quot;command not found&quot;</a></h1>
<p>Like the UNIX command-line, your robot is sensitive to typos; more accurately, every robot command is checked against a set of regular expressions to see if a plugin is matched. It's not rocket science, and it's not AI - it's just good 'ol regexes. When you address your robot directly, but the message doesn't match a command regex, the robot's reply is a little more verbose than &quot;command not found&quot;:</p>
<pre><code>general: @alice Sorry, that didn't match any commands I know,
or may refer to a command that's not available in this channel;
try 'floyd, help &lt;keyword&gt;'
</code></pre>
<p>If you're sure you've typed the command correctly, your plugin may not be available in the current channel; the help system is useful for that:</p>
<pre><code>c:chat/u:alice -&gt; tell me a joke, clu
chat: @alice Sorry, that didn't match any commands I know,
or may refer to a command that's not available in this channel;
try 'Clu, help &lt;keyword&gt;'
c:chat/u:alice -&gt; clu, help joke
chat: Command(s) matching keyword: joke
Clu, tell me a (knock-knock) joke (channels: general, random, botdev, clu-jobs)
c:chat/u:alice -&gt; |cgeneral
Changed current channel to: general
c:general/u:alice -&gt; tell me a joke, clu
general: Hang on while I Google that for you (just kidding ;-)
general: @alice Knock knock
c:general/u:alice -&gt; Who's there?
general: @alice Weevil
c:general/u:alice -&gt; Weevil who?
general: Weevil weevil rock you
</code></pre>
<h1><a class="header" href="#availability-by-channel" id="availability-by-channel">Availability by Channel</a></h1>
<p>Individual <strong>Gopherbot</strong> robots normally limit commands to certain channels, contextually; for instance, the &quot;build&quot; command may be limited to a job channel, where developers can all &quot;see&quot; each other starting builds. Generally speaking, limiting commands to select channels is fairly common for a <strong>Gopherbot</strong> robot. By adding <code>Channels: [ &quot;foo&quot;, &quot;bar&quot; ]</code> to a plugin's <code>*.yaml</code> configuration file, an administrator can easily override the default channels for a given plugin.</p>
<h2><a class="header" href="#default-channels" id="default-channels">Default Channels</a></h2>
<p>Many of the robot's plugins aren't context-sensitive, and can be available anywhere. Practically, however, you might want to limit these to a small number of channels to prevent common channels from getting junked up with robot noise. The slack protocol configuration for the standard robot has:</p>
<pre><code>DefaultChannels: [ &quot;general&quot;, &quot;random&quot; ]
</code></pre>
<h1><a class="header" href="#the-built-in-help-system" id="the-built-in-help-system">The Built-in Help System</a></h1>
<p>For a quick intro to the robot, the ambient<sup class="footnote-reference"><a href="#1">1</a></sup> command &quot;help&quot;, by itself, will provide you with a quick overview of using the help system:</p>
<pre><code>c:chat/u:alice -&gt; help
chat: @alice I've sent you a private message introducing myself
(dm:alice): Hi, I'm Clu, a staff robot. I see you've asked for help.
...
</code></pre>
<p>Note that if you address the robot with it's name or alias, you instead get help for all the commands in the current channel:</p>
<pre><code>c:chat/u:alice -&gt; clu, help
chat: @alice (the help output was pretty long, so I sent you a private message)
(dm:alice): Command(s) available in channel: chat
Clu, help with robot - give general help on the help system and using the robot

Clu, help &lt;keyword&gt; - find help for commands matching &lt;keyword&gt;
...
</code></pre>
<p><strong>Gopherbot</strong> ships with a simple keyword-based help system. Each plugin specifies a set of help texts linked to keywords, and these can easily be added to by providing custom <code>AppendHelp: ...</code> for a given plugin. Since <strong>Gopherbot</strong> commands are commonly linked to channels, keyword help will list the channels where a command is available if it's not in the current channel.</p>
<p>Additionally, some plugins may define custom &quot;help with &lt;foo&gt;&quot; commands that give extended help information about the plugin.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>&quot;ambient&quot; commands are matched against the entire message, every time. Once example of this is the &quot;Chuck Norris&quot; plugin; any time The Great One is mentioned, the robot will pipe up with an anecdote.</p>
</div>
<h1><a class="header" href="#standard-plugins-and-commands" id="standard-plugins-and-commands">Standard Plugins and Commands</a></h1>
<p>In addition to &quot;ping&quot;, and &quot;help&quot;, which we've already introduced, there are a few other standard commands normally available to all users:</p>
<ul>
<li><code>info</code> - provides basic information about the robot's software version and where it's running:</li>
</ul>
<pre><code>c:chat/u:alice -&gt; !info
chat: Here's some information about me and my running environment:
The hostname for the server I'm running on is: 
My name is 'Clu', alias '!', and my Terminal internal ID is '(unknown)'
This is channel 'chat', Terminal internal ID: #chat
The gopherbot install directory is: /home/davidparsley/git/gopherbot
My home directory ($GOPHER_HOME) is: /home/davidparsley/git/clu
My git repository is: git@github.com:parsley42/clu-gopherbot.git
My software version is: Gopherbot v2.0.0-beta3-snapshot, commit: dec5573
The administrators for this robot are: alice
The administrative contact for this robot is: David Parsley, &lt;parsley@linuxjedi.org&gt;
</code></pre>
<ul>
<li><code>whoami</code> - gives information about how the robot &quot;sees&quot; you, with information useful for the <code>UserRoster</code>:</li>
</ul>
<pre><code>c:chat/u:alice -&gt; !whoami
chat: You are 'Terminal' user 'alice/u0001', speaking in channel 'chat/#chat',
email address: alice@example.com
</code></pre>
<h2><a class="header" href="#the-links-plugin" id="the-links-plugin">The &quot;links&quot; Plugin</a></h2>
<p>To simplify sharing common bookmarks with the rest of your team, you can use the &quot;links&quot; plugin:</p>
<pre><code>c:general/u:alice -&gt; !link employee manual to https://example.com/hr.html
general: Link added
c:general/u:alice -&gt; !look up manual
general: Here's what I have for &quot;manual&quot;:
https://example.com/hr.html: employee manual
c:general/u:alice -&gt; !help with links
general: The links plugin stores URLs and associates them with a text key that can
be words or phrases. The 'link' command stores a link and key in one command, and the
'save' command will prompt the user to enter the key. The lookup command
will return all links whose key contains the provided word or phrase,
case insensitive. Links can be deleted with the 'remove' command.
</code></pre>
<h2><a class="header" href="#the-lists-plugin" id="the-lists-plugin">The &quot;lists&quot; Plugin</a></h2>
<p>Slightly less useful, the &quot;lists&quot; plugin can be used for keeping simple lists of items:</p>
<pre><code>c:general/u:alice -&gt; !add beans to the grocery list
general: Ok, I added beans to the grocery list
c:general/u:alice -&gt; !add milk to the list
general: Ok, I added milk to the grocery list
c:general/u:alice -&gt; !show the list
general: Here's what I have on the grocery list:
bacon
tomatoes
bananas
wine
beer
mint cookies
salad
beans
milk
</code></pre>
<blockquote>
<p>Note that the last few commands simply referred to &quot;the list&quot;, instead of fully specifying &quot;the grocery list&quot;. Again, it's not AI; see the next section on &quot;context&quot;.</p>
</blockquote>
<h1><a class="header" href="#context" id="context">Context</a></h1>
<p>Commands can be configured to store certain matched fields as labeled context items, e.g. &quot;item&quot; or &quot;list&quot;. This feature is somewhat experimental, but could occasionally be useful. A somewhat contrived example uses the &quot;list&quot; and &quot;item&quot; contexts with the aforementioned links and lists plugins:</p>
<pre><code>c:general/u:alice -&gt; !link broiled salmon to https://cooking.com/salmon.html
general: Link added
c:general/u:alice -&gt; !add it to the dinner meals list
general: @alice I don't have a 'dinner meals' list, do you want to create it?
c:general/u:alice -&gt; yes
general: Ok, I created a new dinner meals list and added broiled salmon to it
c:general/u:alice -&gt; !link tuna casserole to https://cooking.com/tuna.html
general: Link added
c:general/u:alice -&gt; !add it to the list
general: Ok, I added tuna casserole to the dinner meals list
</code></pre>
<h1><a class="header" href="#robot-administration" id="robot-administration">Robot Administration</a></h1>
<p><strong>Gopherbot</strong> robots are designed to be remotely administered, for common cases where a robot runs behind network firewalls, in virtual cloud networks, or in a container environment. Many of the frequently desired updates - such as changing the schedule of an automated job - can be safely and easily updated by pushing a commit to your robot's repository and instructing it to update. More significant updates can be tested locally by modelling with the <strong>terminal</strong> connector before committing and pushing.</p>
<p>This chapter outlines the common workflow for managing your robots remotely, and documents other important administrative tasks.</p>
<h1><a class="header" href="#updating-from-git" id="updating-from-git">Updating from Git</a></h1>
<h1><a class="header" href="#using-the-terminal-connector" id="using-the-terminal-connector">Using the Terminal Connector</a></h1>
<h1><a class="header" href="#administrator-commands" id="administrator-commands">Administrator Commands</a></h1>
<h1><a class="header" href="#command-line-use" id="command-line-use">Command-Line Use</a></h1>
<h1><a class="header" href="#logging" id="logging">Logging</a></h1>
<h1><a class="header" href="#developing-extensions-for-your-robot" id="developing-extensions-for-your-robot">Developing Extensions for Your Robot</a></h1>
<h1><a class="header" href="#configuring-gopherbot" id="configuring-gopherbot">Configuring Gopherbot</a></h1>
<blockquote>
<p>NOTE: This chapter has not been updated for <strong>Gopherbot</strong> version 2, but has reference material that may be of use when examining default and standard configuration.</p>
</blockquote>
<p><strong>Gopherbot</strong> has very powerful and flexible configuration capabilities based on <em>yaml</em> templates. The core concept is simple; <strong>Gopherbot</strong> ships with default configuration in the <code>conf/</code> directory of the installation archive, and individual robots can modify and override the default configuration with environment variables and custom configuration files. This chapter examines the configuration system in detail.</p>
<h1><a class="header" href="#gopherbot-environment-variables" id="gopherbot-environment-variables">Gopherbot Environment Variables</a></h1>
<p><strong>Gopherbot</strong> makes extensive use of environment variables, both for configuring the robot and plugins, and for providing parameters to external scripts. This article describes the various environment variables and their use; for the environment applicable to a given running task, see <a href="pipelines/TaskEnvironment.html">per-task environment</a>.</p>
<h2><a class="header" href="#robot-execution-environment" id="robot-execution-environment">Robot Execution Environment</a></h2>
<p>Certain environment variables can be supplied to the running <strong>Gopherbot</strong> process to configure and/or bootstrap your robot. These environment variables can be set by:</p>
<ul>
<li><code>systemd</code> - Not recommded; while systemd can provide environment variables to your robot, it's insecure and will allow local users on the system to view the values</li>
<li><code>$GOPHER_HOME/private/environment</code> - a slightly better option, normally used for devel robots with <code>fetch-robot.sh</code>, where <code>private</code> is a private repository with the single file <code>environment</code></li>
<li><code>docker</code> or <code>docker-compose</code> - these and other container environments provide more secure means of providing environment variables to containers</li>
<li><code>$GOPHER_HOME/.env</code> - the most secure means is by creating a <code>.env</code> in <code>$GOPHER_HOME</code>, outside of any git repository, mode <code>0600</code></li>
</ul>
<p>The last two options are recommended for production deployments of a <strong>Gopherbot</strong> robot.</p>
<h3><a class="header" href="#start-up-environment" id="start-up-environment">Start-up Environment</a></h3>
<p>The following values can be provided to your robot on start-up:</p>
<ul>
<li><code>GOPHER_ENCRYPTION_KEY</code> - 32+ character encryption key used for decrypting the <code>binary-encrypted-key</code></li>
<li><code>GOPHER_CUSTOM_REPOSITORY</code> - clone URL for the robot's custom configuration, used in bootstrapping</li>
<li><code>GOPHER_CUSTOM_BRANCH</code> - branch to use if other than <code>master</code></li>
<li><code>GOPHER_LOGFILE</code> - where to write out a log file</li>
<li><code>GOPHER_CONFIGDIR</code> - absolute or relative path to configuration directory</li>
<li><code>GOPHER_DEPLOY_KEY</code> - ssh deploy key for cloning the custom repository</li>
</ul>
<p>For the optional <code>state</code> and <code>private</code> repositories, the included jobs will use the <code>GOPHER_CUSTOM_REPOSITORY</code> value with <code>s/gopherbot/state/</code> and <code>s/gopherbot/private/</code> (same branch). If desired, the values can also be supplied:</p>
<ul>
<li><code>GOPHER_STATE_REPOSITORY</code> - repository holding state, normally just a file-backed brain, defaults to <code>$GOPHER_CUSTOM_REPOSITORY</code> and <code>robot-state</code> branch</li>
<li><code>GOPHER_STATE_BRANCH</code> - if <code>GOPHER_STATE_REPOSITORY</code> is set, this defaults to <code>master</code>, otherwise <code>robot-state</code></li>
<li><code>GOPHER_PRIVATE_REPOSITORY</code> - non-public repository with <code>environment</code>, for dev only</li>
<li><code>GOPHER_PRIVATE_BRANCH</code> - branch to use if other than <code>master</code></li>
</ul>
<h3><a class="header" href="#configuration-environment-variables" id="configuration-environment-variables">Configuration Environment Variables</a></h3>
<p><strong>Gopherbot</strong> normally takes almost all of it's configuration from the collection of <code>*.yaml</code> files in the custom configuration directory, but for easy flexibility, a collection of environment variables are referenced in the default configuration. These are some of the values that are expanded; the actual configuration files are the definitive reference.</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - used to select a non-default protocol (e.g. &quot;terminal&quot;)</li>
<li><code>GOPHER_LOGLEVEL</code> - error, warn, info, debug, trace</li>
<li><code>GOPHER_BOTNAME</code> - the name the robot will answer to, e.g. &quot;floyd&quot;</li>
<li><code>GOPHER_ALIAS</code> - the one-character alias for the robot, e.g. &quot;;&quot;</li>
<li><code>GOPHER_BOTMAIL</code> - the robot's email address</li>
<li><code>GOPHER_BOTFULLNAME</code> - the robot's full name</li>
<li><code>GOPHER_HISTORYDIR</code> - directory for storing file-based historical job logs</li>
<li><code>GOPHER_WORKSPACE</code> - workspace directory where e.g. build jobs clone and run</li>
<li><code>GOPHER_BRAIN</code> - non-default brain provider to use</li>
<li><code>GOPHER_STATEDIR</code> - default dir for storing state, normally just the brain</li>
<li><code>GOPHER_BRAIN_DIRECTORY</code> - directory where file-based memories are stored, overrides above</li>
<li><code>GOPHER_JOBCHANNEL</code> - where jobs run by default if not otherwise specified</li>
<li><code>GOPHER_TIMEZONE</code> - UNIX tz, e.g. &quot;America/New_York&quot; (default)</li>
</ul>
<h2><a class="header" href="#external-script-environment" id="external-script-environment">External Script Environment</a></h2>
<p><strong>Gopherbot</strong> always scrubs the environment when executing tasks, so environment variables set on execution are not automatically passed to child processes. The only environment variables that are passed through from original execution are:</p>
<ul>
<li><code>HOME</code> - this should rarely be used; for portable robots, use <code>GOPHER_HOME</code>, instead</li>
<li><code>HOSTNAME</code></li>
<li><code>LANG</code></li>
<li><code>PATH</code> - this should be used with care since it can make your robot less portable</li>
<li><code>USER</code></li>
</ul>
<p>In addition to the above passed-through environment vars, <strong>Gopherbot</strong> supplies the following environment variables to external scripts:</p>
<ul>
<li><code>GOPHER_INSTALLDIR</code> - absolute path to the gopherbot install, normally <code>/opt/gopherbot</code></li>
</ul>
<h2><a class="header" href="#automatic-environment-variables" id="automatic-environment-variables">Automatic Environment Variables</a></h2>
<p>During startup, <strong>Gopherbot</strong> will examine it's environment and potentially set values for a few environment variables to support the bootstrap and setup plugins, and simplify common operations.</p>
<p>First, <strong>Gopherbot</strong> will check for custom configuration or the presence of a <code>GOPHER_CUSTOM_REPOSITORY</code> environment variable. In the absence of either, the following will be automatically set:</p>
<ul>
<li><code>GOPHER_UNCONFIGURED</code> - set true</li>
<li><code>GOPHER_LOGFILE</code> - set to &quot;robot.log&quot; if not already set</li>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;terminal&quot; so the default robot will start</li>
</ul>
<p>If no custom configuration is present but <code>GOPHER_CUSTOM_REPOSITORY</code> is set:</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;nullconn&quot;, the null connector, to allow the bootstrap plugin to bootstrap your robot</li>
</ul>
<p>If the robot is configured but <code>GOPHER_PROTOCOL</code> isn't set:</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;terminal&quot; for local operations</li>
<li><code>GOPHER_LOGFILE</code> - set to &quot;robot.log&quot; if not already set</li>
</ul>
<p>Finally, if encryption is initialized on start-up, <code>GOPHER_ENCRYPTION_INITIALIZED</code> will be set to <code>true</code>, regardless of whether the robot is configured.</p>
<h2><a class="header" href="#pipeline-environment-variables" id="pipeline-environment-variables">Pipeline Environment Variables</a></h2>
<p>The following environment variable are set for all pipelines, whether started by a plugin or a job:</p>
<ul>
<li><code>GOPHER_CHANNEL</code> - the channel where the plugin/job is providing output</li>
<li><code>GOPHER_USER</code> - the user whose message created the pipeline (if any)</li>
<li><code>GOPHER_PROTOCOL</code> - the name of the protocol in use, e.g. &quot;slack&quot;</li>
<li><code>GOPHER_PIPE_NAME</code> - the name of the plugin or job that started the pipeline</li>
<li><code>GOPHER_TASK_NAME</code> - the name of the running task</li>
<li><code>GOPHER_PIPELINE_TYPE</code> - the event type that started the current pipeline, one of:
<ul>
<li><code>plugCommand</code> - direct robot command, not <code>run job ...</code></li>
<li><code>plugMessage</code> - ambient message matched</li>
<li><code>catchAll</code> - catchall plugin ran</li>
<li><code>jobTrigger</code> - triggered by a JobTrigger</li>
<li><code>scheduled</code> - started by a ScheduledTask</li>
<li><code>jobCommand</code> - started from <code>run job ...</code> command</li>
</ul>
</li>
</ul>
<p>The following are also supplied whenever a job is run:</p>
<ul>
<li><code>GOPHER_JOB_NAME</code> - the name of the running job</li>
<li><code>GOPHER_START_CHANNEL</code> - the channel where the job was started</li>
<li><code>GOPHER_REPOSITORY</code> - the extended namespace from <code>repositories.yaml</code>, if any</li>
<li><code>GOPHER_LOG_LINK</code> - link to job log, if non-ephemeral</li>
<li><code>GOPHER_LOG_REF</code> - log reference used for email log and tail log commands</li>
</ul>
<p>The following are set at the end of the main pipeline, and can be referenced in final and fail tasks:</p>
<ul>
<li><code>GOPHER_FINAL_TASK</code> - name of final task that ran in the pipeline</li>
<li><code>GOPHER_FINAL_TYPE</code> - type of last task to run, one of &quot;task&quot;, &quot;plugin&quot;, &quot;job&quot;</li>
<li><code>GOPHER_FINAL_COMMAND</code> - if type == &quot;plugin&quot;, set to the plugin command</li>
<li><code>GOPHER_FINAL_ARGS</code> - space-separated list of arguments to final task</li>
<li><code>GOPHER_FINAL_DESC</code> - <code>Description:</code> of final task</li>
<li><code>GOPHER_FAIL_CODE</code> - numeric return value if final task failed</li>
<li><code>GOPHER_FAIL_STRING</code> - string value of robot.TaskRetVal returned</li>
</ul>
<p>Pipelines and tasks that have <code>Homed: true</code> and/or <code>Privileged: true</code> may also get:</p>
<ul>
<li><code>GOPHER_HOME</code> - absolute path to the startup directory for the robot, relative paths are relative to this directory; unset if <code>cwd</code> can't be determined</li>
<li><code>GOPHER_WORKSPACE</code> - the workspace directory (normally relative to <code>GOPHER_HOME</code>)</li>
<li><code>GOPHER_CONFIGDIR</code> - absolute path to custom configuration directory, normally <code>$GOPHER_HOME/custom</code></li>
</ul>
<h3><a class="header" href="#gopherci-environment-variables" id="gopherci-environment-variables">GopherCI Environment Variables</a></h3>
<p>In addition to the environment variables set by the <strong>Gopherbot</strong> engine, the <code>localbuild</code> GopherCI builder sets the following environment variables that can be used to modify pipelines:</p>
<ul>
<li><code>GOPHERCI_BRANCH</code> - the branch being built (<code>GOPHER_REPOSITORY</code> is set by <code>ExtendNamespace</code>)</li>
<li><code>GOPHERCI_DEPBUILD</code> - set to &quot;true&quot; if the build was triggered by a dependency</li>
<li><code>GOPHERCI_DEPREPO</code> - the updated repository that triggered this build</li>
<li><code>GOPHERCI_DEPBRANCH</code> - the updated branch</li>
<li><code>GOPHERCI_CUSTOM_PIPELINE</code> - pipeline being run if other than &quot;pipeline&quot;</li>
</ul>
<h1><a class="header" href="#configuration-file-loading" id="configuration-file-loading">Configuration File Loading</a></h1>
<p><strong>Gopherbot</strong> uses <strong>YAML</strong> for it's configuration files, and Go text templates for expanding the files it reads. Any time <strong>Gopherbot</strong> loads a configuration file, say <code>conf/robot.yaml</code>, it first looks for the file in the installation directory, and loads and expands that file if found. Next it looks for the same file in the custom configuration directory; if found, it loads and expands that file, then recursively merges the two data structures:</p>
<ul>
<li>Map values merge and override</li>
<li>Array values are replaced</li>
</ul>
<p>To illustrate with an example, take the following two excerpts from <code>robot.yaml</code>:</p>
<p>Default from the install archive:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: general
  Channels:
  - random
  - general
  StartUser: alice
</code></pre>
<p>Custom local configuration:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
</code></pre>
<p>The resulting configuration would be:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
  StartUser: alice
</code></pre>
<h2><a class="header" href="#template-expansion" id="template-expansion">Template Expansion</a></h2>
<p><strong>Gopherbot</strong> uses standard <a href="https://golang.org/pkg/text/template">Go text templates</a> for expanding the configuration files it reads. In addition to the stock syntactic elements, the following functions and methods are available:</p>
<h3><a class="header" href="#the-env-function" id="the-env-function">The <code>env</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; }}
</code></pre>
<p>This would expand to the value of the <code>GOPHER_ALIAS</code> environment variable.</p>
<h3><a class="header" href="#the-default-function" id="the-default-function">The <code>default</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; | default &quot;;&quot; }}
</code></pre>
<p>The <code>default</code> function takes two arguments, and returns the first argument if it's length is &gt; 0, the second argument otherwise. The example would expand to the value of the <code>GOPHER_ALIAS</code> environment variable if set, or <code>;</code> otherwise.</p>
<h2><a class="header" href="#the-decrypt-function" id="the-decrypt-function">The <code>decrypt</code> function</a></h2>
<pre><code>ProtocolConfig:
  SlackToken: xoxb-18000000000-470000000000-{{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<p>To make it safe to store secret values in configuration, administrators can send a direct message to the robot requesting encryption, e.g.:</p>
<pre><code>c:(direct)/u:alice -&gt; encrypt MyLousyPassword
(dm:alice): RPzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx+9rf==
</code></pre>
<p>The encrypted value can then be pasted in to the <code>decrypt</code> function. See the section on <em>encryption</em> for more information.</p>
<p><strong>NOTE:</strong> In the example, the common, low-entropy portion of a <em>slack</em> token is left as-is, and only the high-entropy portion of the token is encrypted, to prevent attacks where a portion of the encrypted value is known.</p>
<h2><a class="header" href="#the-include-method" id="the-include-method">The <code>.Include</code> method</a></h2>
<pre><code>{{ .Include &quot;terminal.yaml&quot; }}
</code></pre>
<p><code>.Include</code> is a <em>method</em> on the configuration file object, which is either an install file or a custom file. If the above example is present in the installed <code>conf/robot.yaml</code>, it will include <em>only</em> the installed <code>conf/terminal.yaml</code>, if present, and ignore that file if it's also present in the custom directory.</p>
<p>Note that <code>.Include</code>'d files are also expanded as templates in the same manner.</p>
<h1><a class="header" href="#job-and-plugin-configuration" id="job-and-plugin-configuration">Job and Plugin Configuration</a></h1>
<h1><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h1>
<p>TODO: docs on using CLI commands to dump yaml.</p>
<h1><a class="header" href="#gopherbot-pipelines" id="gopherbot-pipelines">Gopherbot Pipelines</a></h1>
<p>Whenever a chat message matches a command plugin, or your robot runs a job, a new pipeline is created; or, more accurately, <em>three</em> pipelines are created:</p>
<ul>
<li>The <strong>primary</strong> pipeline does all the real work of the job or plugin, and stops on any failed task.</li>
<li>The <strong>final</strong> pipeline is responsible for cleanup work, and all tasks in this pipeline always run, in reverse of the order added; see the section on <a href="pipelines/final.html">the final pipeline</a> for more information.</li>
<li>The <strong>fail</strong> pipeline runs only after a failure in the primary pipeline.</li>
</ul>
<blockquote>
<p>NOTE: Jobs, plugins and simple tasks are all instances of a 'task'; the main differences are that 'simple' tasks are meant to be the &quot;worker bees&quot; for job and plugin tasks, which create new pipeline sets. A simple task never creates a new pipeline (though it may add tasks to the current set), it only serves as an element for pipelines created by jobs or plugins.</p>
</blockquote>
<h2><a class="header" href="#job-plugin-and-task-configuration" id="job-plugin-and-task-configuration">Job, Plugin and Task Configuration</a></h2>
<p>Every job, plugin and task needs to be listed in <code>robot.yaml</code> (or an included file). See the chapter on <a href="pipelines/../Configuration.html">robot configuration</a> for more about this topic.</p>
<h2><a class="header" href="#pipeline-state" id="pipeline-state">Pipeline State</a></h2>
<p>The main state items that connect one element in a pipeline to the next are:</p>
<ul>
<li>The <strong>robot</strong> object, generated at the start of the pipeline - this includes a channel where the pipeline is being run, and if started interactively, the user that issued the command.</li>
<li>The pipeline <strong>environment</strong> - these are environment variables provided to external scripts, or retrievable with <code>GetParameter(...)</code> in the <strong>Go</strong> API. Any task in the pipeline can also use the <code>SetParameter(...)</code> API call to set/update the environment for tasks that follow in the pipeline; for instance, the <code>ssh-init</code> task will set <code>$SSH_OPTIONS</code> that should be used with ssh commands later in the pipeline. See the section on <a href="pipelines/../Environment-Variables.html">environment variables</a>.</li>
<li>The pipeline <strong>working directory</strong> and it's contents - normally used for software builds, this is generally set early in the pipeline with <code>SetWorkingDirectory</code>, with a path relative to <code>$GOPHER_WORKSPACE</code>.</li>
</ul>
<h1><a class="header" href="#the-primary-pipeline" id="the-primary-pipeline">The Primary Pipeline</a></h1>
<p>For those with previous experience with CI/CD and pipelines, the <strong>primary</strong> pipeline is analogous to the pipelines you've worked with before. Each task in the pipeline runs until a task fails or the pipeline completes successfully.</p>
<p>Unlike statically configured pipelines, once a job or plugin starts a pipeline, the <code>AddTask</code> and <code>AddCommand</code> API calls are used to add tasks to this pipeline, and can vary, for instance, based on environment variables such as <code>$GOPHERCI_BRANCH</code> in a software build.</p>
<p>In the case of most plugins, there is only a single task in the primary pipeline, the plugin itself. In the case of most jobs, the job task normally adds tasks to each of the pipelines and then exits successfully, at which point the next task in the pipeline runs.</p>
<h2><a class="header" href="#initializing-the-environment" id="initializing-the-environment">Initializing the Environment</a></h2>
<p>There are a few differences between job and plugin pipelines, one of which is the initial environment. For jobs, any parameters set for the job are propagated to the environment for the entire pipeline; plugins must use the <code>SetParameter(...)</code> API call to propagate values. Environment variables are more thoroughly explained in the section on <a href="pipelines/TaskEnvironment.html">task environment variables</a>.</p>
<h2><a class="header" href="#populating-the-pipeline-set" id="populating-the-pipeline-set">Populating the Pipeline Set</a></h2>
<p>During the execution of the primary pipeline, the <code>Add*</code>, <code>Final*</code> and <code>Fail*</code> family of API calls can be used to populate the pipeline set; these calls will fail if used in the final and fail pipelines:</p>
<ul>
<li><code>AddTask</code>, <code>FinalTask</code> and <code>FailTask</code> add simple tasks to the pipeline set.</li>
<li><code>AddJob</code> adds another job to the pipeline, optionally with arguments; note, however, that this creates an entirely new child pipeline, with a new environment not inherited from the parent. If the child job pipeline fails, the parent pipeline also fails.</li>
<li><code>AddCommand</code>, <code>FinalCommand</code> and <code>FailCommand</code> are mostly special-purpose and generally little used, they add plugin commands to the respective pipelines in the set. One use is in wrapping existing plugins with shortcut commands in another plugin - for instance, when I say to my robot &quot;dinner?&quot;, it calls <code>AddCommand &quot;lists&quot; &quot;pick a random item from the dinner meals list&quot;</code>; see <a href="https://github.com/parsley42/floyd-gopherbot/blob/master/plugins/util.sh">Floyd's util plugin</a>. Adding plugins to the pipeline does <em>not</em> create a new child pipeline.</li>
</ul>
<h2><a class="header" href="#order-of-task-execution" id="order-of-task-execution">Order of Task Execution</a></h2>
<p>The normal case is having an initial job or plugin task that fully populates the primary, final and fail pipelines. There are some tasks, however, that add one or more additional tasks to the pipeline set. The final and fail pipelines just grow in length, but the behavior of the primary pipeline is special:</p>
<ul>
<li>If tasks are added in the last task of the pipeline, the added tasks are just appended and the pipeline runs them as normal.</li>
<li>If the tasks are added BEFORE the final task in the pipeline, <strong>all</strong> of the added tasks run before the next task in the original pipeline run. As an example:</li>
</ul>
<p><strong>Job A</strong>:</p>
<pre><code>AddTask A
AddTask B
AddTask C
AddTask D
</code></pre>
<p><strong>Task C</strong>:</p>
<pre><code>AddTask E
AddTask F
</code></pre>
<p>Assuming none of the other tasks add additional tasks, they will run in the order: A, B, C, E, F, D. This allows for slightly more complicated tasks that may, for instance, have several sub-steps in setting up the working directory, and need to all complete before the next task in the job proceeds.</p>
<p>In the case of <strong>GopherCI</strong>, the <code>localbuild</code> job adds (among others) the following tasks:</p>
<ul>
<li>&quot;startbuild&quot; - a task to provide information about the build that is starting</li>
<li>&quot;run-pipeline&quot; - a task that runs a pipeline specified in the repository</li>
<li>&quot;finishbuild&quot; - a task to report on how the build ended</li>
</ul>
<p>The contents of <code>&lt;repository&gt;/.gopherci/pipeline.sh</code> correspond most closely to the contents of e.g. <code>&lt;repository&gt;/.travis.yml</code> - they define the build, test and deploy tasks for the repository-specific pipeline. The task execution order for the primary pipeline insures that all the tasks in the repository pipeline are run before any other tasks added by the build job.</p>
<blockquote>
<p>NOTE: &quot;finishbuild&quot; is actually added to the final pipeline so it always runs, however the example still holds.</p>
</blockquote>
<h1><a class="header" href="#the-final-pipeline" id="the-final-pipeline">The Final Pipeline</a></h1>
<p>The final pipeline always runs after the primary pipeline, regardless of whether it failed, and every task in the pipeline runs, regardless of failures. Unlike the primary and fail pipelines, the tasks in the final pipeline run in <strong>FILO</strong> order - first in, last out. This creates a kind of &quot;bracketing&quot; behavior; the &quot;ssh-init&quot; task, for instance, adds a final task to kill the <code>ssh-agent</code> at the end of the pipeline. If the &quot;ssh-init&quot; task runs first, the &quot;kill&quot; task will run last; if a following task performs some kind of initialization / setup on a remote host, and adds a final task to clean up, this insures that the remote cleanup occurs before the ssh-agent is killed.</p>
<p>Note that there are several <a href="pipelines/../Environment-Variables.html">environment variables</a> that are set at the end of the primary pipeline that can be examined and used for reporting in the final pipeline. For an example of this, see the <a href="https://github.com/lnxjedi/gopherbot/blob/master/tasks/finishbuild.sh">finishbuild</a> task that runs in the final pipeline of a <strong>GopherCI</strong> build.</p>
<h1><a class="header" href="#the-fail-pipeline" id="the-fail-pipeline">The Fail Pipeline</a></h1>
<p>The fail pipeline is a straight-forward pipeline of actions to take in the event of a failure in the primary pipeline. There are a host of <a href="pipelines/../Environment-Variables.html">environment variables</a> that are set in the event of a primary pipeline failure, and fail tasks can use these for reporting the nature of the failure. Every task in the fail pipeline runs, regardless of individual task failures, in the order they were added.</p>
<blockquote>
<p>Note on Parameters and Environment Variables: The <strong>Gopherbot</strong> documentation uses <em>environment variable</em> and <em>parameter</em> somewhat interchangeably; this is due to configured and set parameters being made available to external scripts as environment variables.</p>
</blockquote>
<h1><a class="header" href="#task-environment-variables" id="task-environment-variables">Task Environment Variables</a></h1>
<p>Each time a task is run, a custom environment is generated for that task. For external tasks such as <code>ssh-init</code>, these values are actually set as environment variables for the process. <em>Go</em> tasks access these values with the <code>GetParameter()</code> API call.</p>
<p>The precedence of environment variables seen by a given task is determined by the algorithm in <code>bot/run_pipelines.go:getEnvironment()</code>. The various environment sources are listed here, in order from lowest to highest priority.</p>
<h2><a class="header" href="#namespace-parameters" id="namespace-parameters">NameSpace Parameters</a></h2>
<p>Various tasks, plugins and jobs can be configured to share parameters by defining <code>NameSpaces</code> in <code>conf/robot.yaml</code>, and setting the <code>NameSpace</code> parameter for a given task to the shared namespace. For instance, the <code>ssh-init</code> task and <code>ssh-admin</code> plugin both get access to the <code>BOT_SSH_PHRASE</code> environment variable via the <code>ssh</code> namespace.</p>
<h2><a class="header" href="#task-parameters" id="task-parameters">Task Parameters</a></h2>
<p>Individual tasks, plugins and jobs can also have <code>Parameters</code> defined. If present, these override any parameters set for a shared namespace.</p>
<h2><a class="header" href="#pipeline-parameters" id="pipeline-parameters">Pipeline Parameters</a></h2>
<p>Any time a job is run, the parameters for that job (including those inherited from it's namespace, if any) initialize the environment variables for the pipeline as a whole, and are available to all tasks in the pipeline. Parameters set in the pipeline override task and namespace parameters for any tasks run in the pipeline, allowing specific job parameters to override defaults for the task.</p>
<h3><a class="header" href="#plugins-and-pipelines" id="plugins-and-pipelines">Plugins and Pipelines</a></h3>
<p>Plugins can also start a new pipeline, but plugin parameters are not automatically added to the pipeline. Plugins can, however, explicity publish parameters to the pipeline with the <code>SetParameter()</code> API call.</p>
<p>Plugin tasks can also be added to a pipeline with the <code>AddCommand()</code>, <code>FinalCommand()</code> and <code>FailCommand()</code> API calls. Unlike tasks, plugins only inherit parameters from the pipeline when they are configured with <code>Privileged: true</code> in <code>robot.yaml</code>.</p>
<h2><a class="header" href="#repository-parameters" id="repository-parameters">Repository Parameters</a></h2>
<p>If a given Job calls the <code>ExtendNamespace()</code> API to start a build, the parameters for that repository set in <code>conf/repositories.yaml</code> overwrite any values in the current pipeline, which then behave as <strong>Pipeline Parameters</strong> as above.</p>
<h2><a class="header" href="#setparameter" id="setparameter">SetParameter()</a></h2>
<p>Parameters set with the <code>SetParameter()</code> API call overwrite the current value for a pipeline. Parameters set with <code>SetParameter()</code> have the highest priority, and will always apply to later tasks in the pipeline.</p>
<h1><a class="header" href="#included-tasks" id="included-tasks">Included Tasks</a></h1>
<blockquote>
<p>NOTE: This section is incomplete!</p>
</blockquote>
<p><strong>Gopherbot</strong> ships with a selection of available pipeline tasks, listed here alphabetically. Note that the given examples use <strong>bash</strong> syntax for simplicity; for <strong>ruby</strong> and <strong>python</strong> see the chapter on the <a href="pipelines/../api/API-Introduction.html">Gopherbot API</a>.</p>
<hr />
<p><strong>email-log</strong> - <em>privileged</em></p>
<p>Usage:</p>
<ul>
<li><code>FinalTask email-log joe@example.com emily@example.com frank bob</code></li>
<li><code>FinalTask email-log</code></li>
</ul>
<p>Normally used in the <strong>fail</strong> and <strong>final</strong> pipelines, emails a copy of the pipeline log. Can also be used with <code>AddTask</code> in the main pipeline, but content will be incomplete.</p>
<p><em>Notes on the current implementation:</em><br />
The email function call takes a byte slice for the email body, rather than an <code>io.Reader</code>, meaning the entire body of the message is read in to memory. To limit memory use, <strong>Gopherbot</strong> allocates a 10MB line-based circular buffer, with maximum 16KB-long lines (terminated by <code>\n</code>), and reads the log to that buffer for emailing. Logs that are longer than 10MB will only send the last 10MB of the log, and lines longer than 16KB will be truncated.</p>
<hr />
<p><strong>pause-brain</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask pause-brain</code></p>
<p>Pause brain operations for backups and restores. After half a minute, the brain automatically resumes; best practice is to add <code>resume-brain</code> after the backup/restore task.</p>
<hr />
<p><strong>restart-robot</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask restart-robot</code></p>
<p>Allow a privileged pipeline to queue a restart of the robot after the pipeline completes. Heavily used by bootstrap and setup plugins. <strong>NOTE:</strong> This behavior means that tasks added after <strong>restart-robot</strong> are actually completed <em>before</em> the restart. In practice, the current pipeline will change the state of the robot, and after restarting a plugin <strong>init</strong> function will check for the state change (e.g. presence of <code>.restore</code> file) and start a new pipeline.</p>
<hr />
<p><strong>resume-brain</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask resume-brain</code></p>
<p>Resume brain functions after backup/restore.</p>
<hr />
<p><strong>rotate-log</strong> - <em>privileged</em></p>
<p>Usage: <code>AddTask rotate-log &lt;extension&gt;</code></p>
<p>Useful for e.g. nightly log rotation jobs, when the robot has been started with e.g.: <code>gopherbot -d -l robot.log</code>. For example:</p>
<pre><code>AddTask rotate-log &quot;log.$(date +%a)&quot;
</code></pre>
<p>This would keep daily logs of the form <code>robot.log.Mon</code>, etc.</p>
<h1><a class="header" href="#tool-integrations" id="tool-integrations">Tool Integrations</a></h1>
<p>To simplify using tools like <code>ssh</code> and <code>ansible</code> in your pipeline, <strong>Gopherbot</strong> ships with some predefined pipeline elements detailed in the following sections.</p>
<h1><a class="header" href="#integrating-with-ssh" id="integrating-with-ssh">Integrating with SSH</a></h1>
<p>The <strong>GopherCI</strong> job(s) use <em>ssh</em> tasks for cloning repositories with public keys, and you can also use these tasks in your own pipelines for executing remote tasks.</p>
<h2><a class="header" href="#configuring-ssh" id="configuring-ssh">Configuring SSH</a></h2>
<p>You start by choosing a passphrase for your robot's ssh keypair - make it something quite long; you shouldn't need to type it more than once. Use the <code>encrypt</code> command (normally with the terminal connector) to produce the encrypted value, and put it in a stanza like the following in your <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">ExternalTasks:
  &quot;ssh-init&quot;:
    Parameters:
    - Name: BOT_SSH_PHRASE
      Value: {{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<h2><a class="header" href="#initializing" id="initializing">Initializing</a></h2>
<p>Once the robot knows it's passphrase, you can use the <code>generate keypair</code> administrator command to generate a new keypair, which will be stored in <code>$GOPHER_CONFIGDIR/ssh/</code>. The private key is encrypted with the robot's (also encrypted) passphrase, so this can be committed to the repository. The <code>pubkey</code> administrator command will display the robot's public key.</p>
<h2><a class="header" href="#using-in-pipelines" id="using-in-pipelines">Using in Pipelines</a></h2>
<p>A pipeline using <em>ssh</em> might look something like this:</p>
<pre><code class="language-bash">AddTask ssh-init

AddTask ssh-scan my.remote.host

AddTask exec ssh $SSH_OPTIONS user@my.remote.host &quot;whoami&quot;
</code></pre>
<ul>
<li>The <code>ssh-init</code> task will:
<ul>
<li>Start an <code>ssh-agent</code> and add the robot's key</li>
<li>Use <code>SetParameter</code> to store <code>SSH_AUTH_SOCK</code> and <code>SSH_AGENT_PID</code> in the pipeline</li>
<li>Set <code>SSH_OPTIONS</code> to e.g. <code>-F $GOPHER_CONFIGDIR/ssh/config</code> if the robot has a custom ssh config file</li>
<li>Add a <strong>FinalTask</strong> to kill the <code>ssh-agent</code> when the pipeline finishes</li>
</ul>
</li>
<li><code>ssh-scan</code> insures a host is listed in <code>known_hosts</code>, if desired (this may be unneeded depending on the contents of <code>ssh/config</code>)</li>
<li>The <code>exec</code> task calls ssh as normal, using <code>$SSH_OPTIONS</code> to pick up custom configuration if it exists</li>
</ul>
<h2><a class="header" href="#api-for-plugins-jobs-and-tasks" id="api-for-plugins-jobs-and-tasks">API for Plugins, Jobs and Tasks</a></h2>
<blockquote>
<p>NOTE: This chapter is badly outdated, mainly because it's missing a lot of information. The documenation for individual API calls, however, should be mostly accurate.</p>
</blockquote>
<p><strong>Gopherbot</strong> provides an object-oriented API for writing your own command plugins, jobs and tasks. With the exception of the <code>bash</code> library, API calls are accessed from methods on a <strong>robot</strong> object. The following sections detail the usage of the various methods.</p>
<p>Gopherbot's functionality can be easily extended by writing plugins in one of several different languages. A single plugin can provide:</p>
<ul>
<li>One or more new commands the robot will understand</li>
<li>Elevation logic for providing extra assurance of user identity</li>
<li>Authorization logic for determining a user's rights to issue various commands</li>
</ul>
<p>This article deals mainly with writing plugins in one of the scripting languages supported by Gopherbot, the most popular means for writing new command plugins. For writing native compiled-in plugins in Go, see <code>gopherbot/main.go</code> and the sample plugins in <code>goplugins/</code>. API documentation for Robot methods is available at:</p>
<p>https://godoc.org/github.com/lnxjedi/gopherbot/bot#Robot</p>
<p>Note that the script plugin API is implemented on top of the native Go API, so that document may also be of use for scripting plugin authors. The file <code>bot/http.go</code>, and the scripting libraries in <code>lib/</code> will illuminate the mapping from the script APIs to the native Go API.</p>
<h1><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="api/Languages.html#plugin-loading-and-precedence">Plugin Loading and Precedence</a></li>
<li><a href="api/Languages.html#default-configuration">Default Configuration</a></li>
<li><a href="api/Languages.html#calling-convention">Calling Convention</a>
<ul>
<li><a href="api/Languages.html#environment-variables">Environment Variables</a></li>
<li><a href="api/Languages.html#reserved-commands">Reserved Commands</a></li>
</ul>
</li>
<li><a href="api/Languages.html#plugin-types-and-calling-events">Plugin Types and Calling Events</a>
<ul>
<li><a href="api/Languages.html#command-plugins">Command Plugins</a></li>
<li><a href="api/Languages.html#authorization-plugins">Authorization Plugins</a></li>
<li><a href="api/Languages.html#elevation-plugins">Elevation Plugins</a></li>
</ul>
</li>
<li><a href="api/Languages.html#using-the-terminal-connector">Using the Terminal Connector</a></li>
<li><a href="api/Languages.html#plugin-debugging">Plugin Debugging</a>
<ul>
<li><a href="api/Languages.html#debug-plugin-command">Debug Plugin Command</a></li>
<li><a href="api/Languages.html#dump-plugin-command">Dump Plugin Command</a></li>
</ul>
</li>
<li><a href="api/Languages.html#getting-started">Getting Started</a>
<ul>
<li><a href="api/Languages.html#starting-from-a-sample-plugin">Starting from a Sample Plugin</a></li>
<li><a href="api/Languages.html#using-boilerplate-code">Using Boilerplate Code</a>
<ul>
<li><a href="api/Languages.html#bash-boilerplate">Bash Boilerplate</a></li>
<li><a href="api/Languages.html#powershell-boilerplate">PowerShell Boilerplate</a></li>
<li><a href="api/Languages.html#python-boilerplate">Python Boilerplate</a></li>
<li><a href="api/Languages.html#ruby-boilerplate">Ruby Boilerplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="api/Languages.html#the-plugin-api">The Plugin API</a></li>
</ul>
<h1><a class="header" href="#plugin-loading-and-precedence" id="plugin-loading-and-precedence">Plugin Loading and Precedence</a></h1>
<p>Gopherbot ships with a number of external script plugins in the <code>install</code> directory. These can be overridden by placing a plugin with the same filename in the optional configuration directory.</p>
<h1><a class="header" href="#default-configuration" id="default-configuration">Default Configuration</a></h1>
<p>Plugin configuration is fully documented in the <a href="api/Configuration.html">configuration</a> article; you should be familiar with that document before beginning to write your own plugins.</p>
<p>On start-up and during a reload, the robot will run each external script plugin with an argument of <code>configure</code>. The plugin should respond by writing the plugin default configuration to standard out and exiting with exit code 0. When responding to <code>configure</code>, the plugin shouldn't initialize a robot object or make any API calls, as <code>configure</code> is called without setting robot environment variables.</p>
<h1><a class="header" href="#calling-convention" id="calling-convention">Calling Convention</a></h1>
<p>The robot calls external plugins by creating a goroutine and exec'ing the external script with a set of environment variables. The external script uses the appropriate library for the scripting language to create a robot object from the environment. The script then examines it's command-line arguments to determine the type of action to take (normally a command followed by arguments to the command), and uses the library to make JSON-over-http calls for executing and returning results from methods. Depending on how the plugin is used, different kinds of events can cause external plugins to be called with a variety of commands and arguments. The most common means of calling an external plugin is for one of it's commands to be matched, or by matching a pattern in an ambient message (one not specifically directed to the robot).</p>
<p>There are two sources of information for an external plugin being called:</p>
<ul>
<li>Environment Variables - these should generally only be referenced by the scripting library</li>
<li>Command Line Arguments - these should be used by the plugin to determine what to do</li>
</ul>
<h2><a class="header" href="#environment-variables" id="environment-variables">Environment Variables</a></h2>
<p>Gopherbot sets two primary environment variables of use to the plugin developer:</p>
<ul>
<li>GOPHER_CONFIGDIR - the directory where Gopherbot looks for it's configuration</li>
<li>GOPHER_INSTALLDIR - the directory where the Gopherbot executable resides</li>
</ul>
<p>In addition, the following two environment variables are set for every script plugin:</p>
<ul>
<li>GOPHER_USER - the username of the user who spoke to the robot</li>
<li>GOPHER_CHANNEL - the channel the user spoke in (empty string indicates a direct message)</li>
</ul>
<h2><a class="header" href="#reserved-commands" id="reserved-commands">Reserved Commands</a></h2>
<p>The first argument to a plugin script is the <strong>command</strong>. In addition to the <code>configure</code> command, which instructs a plugin to dump it's default configuration to standard out, the following commands are reserved:</p>
<ul>
<li><code>init</code> - After starting the connector and on reload, the robot will call external plugins with a command argument of <code>init</code>. Since all environment variables for the robot are set at that point, it would be possible to e.g. save a robot data structure that could be loaded and used in a cron job.</li>
<li><code>authorize</code> - The plugin should check authorization for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>elevate</code> - The plugin should perform additional authentication for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>event</code> - This command is reserved for future use with e.g. user presence change &amp; channel join/leave events</li>
<li><code>catchall</code> - Plugins with <code>CatchAll: true</code> will be called for commands directed at the robot that don't match a command plugin. Normally these are handled by the compiled-in <code>help</code> plugin, but administrators could override that setting and provide their own plugin with <code>CatchAll: true</code>. Note that having multiple such plugins is probably a bad idea.</li>
</ul>
<h1><a class="header" href="#plugin-types-and-calling-events" id="plugin-types-and-calling-events">Plugin Types and Calling Events</a></h1>
<p>There are (currently) three different kinds of external plugin:</p>
<ul>
<li>Command / Message Plugins - these are called by the robot in respond to messages the user sends</li>
<li>Authorization Plugins - these plugins encapsulate the logic for authorizing specific users to use specific commands, and are called by the robot during authorization processing</li>
<li>Elevation Plugins - these plugins perform some variety of multi-factor authentication for higher assurance of user identity, and are called by the robot during elevation processing</li>
</ul>
<h2><a class="header" href="#command-plugins" id="command-plugins">Command Plugins</a></h2>
<p>A command plugin's configuration specifies <code>CommandMatchers</code> and <code>MessageMatchers</code> that associate regular expressions with plugin commands:</p>
<pre><code class="language-yaml">MessageMatchers:
- Command: help
  Regex: '^(?i:help)$'
CommandMatchers:
- Regex: (?i:remember ([-\w .,!?:\/]+))
  Command: remember
  Contexts: [ &quot;item&quot; ]
</code></pre>
<p>Whenever a <code>CommandMatcher</code> regex matches a command given to the robot, or a <code>MessageMatcher</code> matches an ambient message, the robot calls the plugin script with the first argument being the matched <code>Command</code>, and subsequent arguments corresponding to the regex capture groups (which may in some cases be an empty string). Command plugins should normally exit with status 0 (bot.Normal), or non-zero for unusual error conditions that may require an administrator to investigate. The robot will notify the user whenever a command plugin exits non-zero, or when it emits output to STDERR.</p>
<h2><a class="header" href="#authorization-plugins" id="authorization-plugins">Authorization Plugins</a></h2>
<p>To separate command logic from user authorization logic, Gopherbot supports the concept of an <strong>authorization plugin</strong>. The main <code>robot.yaml</code> can define a specific plugin as the <code>DefaultAuthorizer</code>, and individual plugins can be configured to override this value by specifying their own <code>Authorizer</code> plugin. If a plugin lists any commands in it's <code>AuthorizedCommands</code> config item, or specifies <code>AuthorizeAllCommands: true</code>, then the robot will call the authorizer plugin with a command of <code>authorize</code>, followed by the following arguments:</p>
<ul>
<li>The name of the plugin for which authorization is being requested</li>
<li>The optional value of <code>AuthRequire</code>, which may be interpreted as a group or role</li>
<li>The plugin command being called followed by any arguments passed to the command</li>
</ul>
<p>Based on these values and the <code>User</code> and <code>Channel</code> values from the robot, the authorization plugin should evaluate whether a user/plugin is authorized for the given command and exit with one of:</p>
<ul>
<li>bot.Succeed (1) - authorized</li>
<li>bot.Fail (2) - not authorized</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from determining authorization</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other values will result in an error and failed authentication.</p>
<p>Additionally, authorization plugins may provide extra feedback to the user on <code>Fail</code> or <code>MechanismFail</code> so they can have the issue addressed, e.g. &quot;Authorization failed: user not a member of group 'foo'&quot;. In some cases, however, authorization plugins may not have a full Gopherbot API library; they could be written in C, and thus not be able to interact with the user.</p>
<h2><a class="header" href="#elevation-plugins" id="elevation-plugins">Elevation Plugins</a></h2>
<p>Elevation plugins provide the means to request additional authentication from the user for commands where higher assurance of identity is desired. The main <code>robot.yaml</code> can specify an elevation plugin as the <code>DefaultElevator</code>, which can be overridden by a given plugin specifying an <code>Elevator</code>. When the plugin lists commands as <code>ElevatedCommands</code> or <code>ElevateImmediateCommands</code>, the robot will call the appropriate elevator plugin with a command of <code>elevate</code> and a first argument of <code>true</code> or <code>false</code> for <code>immediate</code>. The elevator plugin should interpret <code>immediate == true</code> to mean MFA is required every time; when <code>immediate != true</code>, successful elevation may persist for a configured timeout period.</p>
<p>Based on the result of the elevation determination, the plugin should have an exit status one of:</p>
<ul>
<li>bot.Succeed (1) - elevation succeeded</li>
<li>bot.Fail (2) - elevation failed</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from processing the elevation request</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other value will result in an error being logged and elevation failing.</p>
<p>Additionally, the elevation plugin may provide extra feedback to the user when elevation isn't successful to indicate the nature of the failure.</p>
<h1><a class="header" href="#using-the-terminal-connector-1" id="using-the-terminal-connector-1">Using the Terminal Connector</a></h1>
<p>Interacting with your bot in a chat app might not always be convenient or fast; to simplify
testing and plugin development, <strong>Gopherbot</strong> includes a terminal connector that emulates
a chat service with multiple users and channels, with a sample
configuration in the <code>cfg/term/</code> directory. You'll probably want to copy the directory and modify
it for your own use (mainly configuring the plugins you're developing), but it can be used
by using the <code>-c &lt;configpath&gt;</code> option:</p>
<pre><code>[gopherbot]$ ./gopherbot -c cfg/term/
2018/04/13 18:07:52 Initialized logging ...
2018/04/13 18:07:52 Starting up with config dir: cfg/term/, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/13 18:07:52 Debug: Loaded installed conf/robot.yaml
2018/04/13 18:07:52 Debug: Loaded configured conf/robot.yaml
Terminal connector running; Use '|C&lt;channel&gt;' to change channel, or '|U&lt;user&gt;' to change user
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; ;ping
general: @bob PONG
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;quit
random: @alice Adios
[gopherbot]$
</code></pre>
<h1><a class="header" href="#plugin-debugging" id="plugin-debugging">Plugin Debugging</a></h1>
<p>The most common problem for plugin authors is the robot does nothing after sending it a message,
or the robot just says <code>Sorry, that didn't match any commands I know, ...</code>.</p>
<p>This can be due to a number of issues:</p>
<ul>
<li>The plugin didn't load because of various configuration problems</li>
<li>The robot isn't in the channel, and doesn't hear the message</li>
<li>The plugin isn't visible because of channel, user, or other restrictions</li>
<li>The user message doesn't match a regex for the plugin</li>
<li>The plugin runs, but does nothing</li>
</ul>
<p>To track down these issues easily, <strong>Gopherbot</strong> has the builtin administrator commands <code>debug plugin</code> and <code>dump plugin</code>. Make sure your username / handle is listed in the
<code>AdminUsers</code> list in <code>robot.yaml</code> for your development environment.</p>
<h2><a class="header" href="#debug-plugin-command" id="debug-plugin-command">Debug Plugin Command</a></h2>
<p><strong>Gopherbot</strong> has a builtin command for plugin debugging that can help quickly pinpoint
most problems. Turning on plugin debugging will initiate a reload, then send debugging
information about a plugin in direct messages. If <code>verbose</code> is enabled, you will get debugging
information for every message you send, or every command sent to the robot by another user.
You can see an example of plugin debugging here with the terminal connector:</p>
<pre><code>[gopherbot]$ ./gopherbot
2018/04/18 15:43:01 Initialized logging ...
2018/04/18 15:43:01 Starting up with config dir: /home/user/.gopherbot, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/18 15:43:01 Debug: Loaded installed conf/robot.yaml
2018/04/18 15:43:01 Debug: Loaded configured conf/robot.yaml
Terminal connector running; Use '|C&lt;channel&gt;' to change channel, or '|U&lt;user&gt;' to change user
c:general/u:alice -&gt; ;ruby me!
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; ;help debug
general: Command(s) matching keyword: debug
floyd, debug plugin &lt;pluginname&gt; (verbose) - turn on debugging for the named plugin, optionally verbose

floyd, stop debugging - turn off debugging
c:general/u:alice -&gt; ;debug plugin rubydemo
general: Debugging enabled for rubydemo (verbose: false)
c:general/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:15 DEBUG rubydemo: plugin is NOT visible to user alice in channel general; channel 'general' is not on the list of allowed channels: random
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;ruby me to the max!
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me to the max!&quot;
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:ruby( me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:listen( to me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:remember(?: (slowly))? ([-\w .,!?:\/]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:recall ?([\d]+)?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:forget ([\d]{1,2}))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:check me)
random: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:random/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me!&quot;
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Matched command regex '(?i:ruby( me)?!?)', command: ruby
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Running plugin with command 'ruby' and arguments: [ me]
random: Sure, Alice!
random: I'll ruby you, but not right now - I'll wait 'til you're least expecting it...
(dm:alice): 2018/04/18 03:43:51 DEBUG rubydemo: Plugin finished with return value: Normal
</code></pre>
<p><strong>NOTE:</strong> If your plugin is disabled with a mysterious <code>File not found</code> error, be sure you've got the
appropriate scripting language installed. If the first line in your plugin is e.g.:</p>
<pre><code>#!/usr/bin/ruby
</code></pre>
<p>... you'll get <code>File not found</code> if <code>/usr/bin/ruby</code> isn't present on the system.</p>
<h2><a class="header" href="#dump-plugin-command" id="dump-plugin-command">Dump Plugin Command</a></h2>
<p>To view a plugin's default or final configuration, you can use the <code>dump plugin</code> command:</p>
<pre><code>c:general/u:alice -&gt; ;help dump
general: Command(s) matching keyword: dump
floyd, dump plugin (default) &lt;plugname&gt; - dump the current or default configuration for the plugin (direct message only)

floyd, dump robot - dump the current configuration for the robot (direct message only)
c:general/u:alice -&gt; |c
Changed current channel to: direct message
c:(direct)/u:alice -&gt; dump plugin rubydemo
(dm:alice): AdminCommands: null
AllChannels: false
AllowDirect: true
AuthRequire: &quot;&quot;
AuthorizeAllCommands: false
AuthorizedCommands: null
Authorizer: &quot;&quot;
CatchAll: false
... (MUCH more)
</code></pre>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<h2><a class="header" href="#starting-from-a-sample-plugin" id="starting-from-a-sample-plugin">Starting from a Sample Plugin</a></h2>
<p>The simplest way for a new plugin author to get started is to:</p>
<ul>
<li>Disable the demo plugin for your chosen scripting language (if enabled) in <code>&lt;config dir&gt;/conf/robot.yaml</code></li>
<li>Copy the demo plugin to <code>&lt;config dir&gt;/plugins/&lt;newname&gt;(.extension)</code></li>
<li>Enable your new plugin in <code>robot.yaml</code> and give it a descriptive <code>Name</code></li>
</ul>
<h2><a class="header" href="#using-boilerplate-code" id="using-boilerplate-code">Using Boilerplate Code</a></h2>
<p>Each supported scripting language has a certain amount of &quot;boilerplate&quot; code required in every command plugin; generally, the boilerplate code is responsible for:</p>
<ul>
<li>Loading the appropriate version of the Gopherbot library from <code>$GOPHER_INSTALLDIR/lib</code></li>
<li>Defining and providing the default config</li>
<li>Instantiating a Robot object with a library call
Normally this is followed by some form of case / switch statement that performs different functions based on the contents of the first argument, a.k.a. the &quot;command&quot;.</li>
</ul>
<h3><a class="header" href="#bash-boilerplate" id="bash-boilerplate">Bash Boilerplate</a></h3>
<pre><code class="language-bash">#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat &lt;&lt;&quot;EOF&quot;
&lt;yaml config document&gt;
EOF
}

case &quot;$COMMAND&quot; in
	&quot;configure&quot;)
		configure
		;;
...
esac
</code></pre>
<p><strong>NOTE:</strong> Bash doesn't have an object-oriented API</p>
<h3><a class="header" href="#python-boilerplate" id="python-boilerplate">Python Boilerplate</a></h3>
<pre><code class="language-python">#!/usr/bin/python3

import os
import sys
sys.path.append(&quot;%s/lib&quot; % os.getenv(&quot;GOPHER_INSTALLDIR&quot;))
from gopherbot_v2 import Robot # use _v1 for python2

bot = Robot()

default_config = '''
&lt;yaml config document&gt;
'''

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == &quot;configure&quot;:
    print default_config
...
</code></pre>
<h3><a class="header" href="#ruby-boilerplate" id="ruby-boilerplate">Ruby Boilerplate</a></h3>
<pre><code class="language-ruby">#!/usr/bin/ruby

# boilerplate
require ENV[&quot;GOPHER_INSTALLDIR&quot;] + '/lib/gopherbot_v1'

bot = Robot.new()

defaultConfig = &lt;&lt;'DEFCONFIG'
&lt;yaml config document&gt;
DEFCONFIG

command = ARGV.shift()

case command
when &quot;configure&quot;
	puts defaultConfig
	exit
...
end
</code></pre>
<h1><a class="header" href="#the-plugin-api" id="the-plugin-api">The Plugin API</a></h1>
<p>Gopherbot has a rich set of methods (functions) for interacting with the robot / user. Here we break down the API into sets of related functions:</p>
<ul>
<li><a href="api/Attribute-Retrieval-API.html">Attribute Lookup Methods</a> - for retrieving names, email addresses, etc.</li>
<li><a href="api/Message-Sending-API.html">Sending Messages and Replies</a> - for sending messages to the users</li>
<li><a href="api/Response-Request-API.html">Prompting for Input</a> - for getting replies from the user</li>
<li><a href="api/Brain-API.html">Brain Methods and Memories</a> - for storing and retrieving long- and short-term memories</li>
<li><a href="api/Utility-API.html">Utility Methods</a> - a collection of miscellaneous useful functions, like Pause() and Log()</li>
</ul>
<h1><a class="header" href="#getting-information-about-users-and-the-robot" id="getting-information-about-users-and-the-robot">Getting Information About Users and the Robot</a></h1>
<p>The <code>Get*Attribute(...)</code> family of methods can be used to get basic chat service directory information like first and last name, email address, etc. <code>GetSenderAttribute</code> and <code>GetBotAttribute</code> take a single argument, the name of the attribute to retrieve. The lesser-used <code>GetUserAttribute</code> takes two arguments, the user and the attribute. The return value is an object with <code>Attribute</code> and <code>RetVal</code> members. <code>RetVal</code> will be one of <code>Ok</code>, <code>UserNotFound</code> or <code>AttributeNotFound</code>.</p>
<h2><a class="header" href="#user-attributes" id="user-attributes">User Attributes</a></h2>
<p>The available attributes for a user / sender:</p>
<ul>
<li>name (handle)</li>
<li>fullName</li>
<li>email</li>
<li>firstName</li>
<li>lastName</li>
<li>phone</li>
<li>internalID (protocol internal representatation)</li>
</ul>
<h2><a class="header" href="#bot-attributes" id="bot-attributes">Bot Attributes</a></h2>
<p>The available attributes for the bot:</p>
<ul>
<li>name</li>
<li>alias</li>
<li>fullName / realName</li>
<li>contact / admin / adminContact</li>
<li>email</li>
<li>protocol (e.g. &quot;slack&quot;)</li>
</ul>
<p>Note: the values for most of these are configured in <code>conf/robot.yaml</code></p>
<h1><a class="header" href="#code-examples" id="code-examples">Code Examples</a></h1>
<h2><a class="header" href="#bash" id="bash">Bash</a></h2>
<pre><code class="language-bash">USEREMAIL=$(GetSenderAttribute email)
if [ $? -ne $GBRET_Ok ]
then
  Say &quot;I was unable to look up your email address&quot;
else
  Say &quot;Your email address is $USEREMAIL&quot;
fi
</code></pre>
<h2><a class="header" href="#powershell" id="powershell">PowerShell</a></h2>
<pre><code class="language-powershell">$attr = $bot.GetBotAttribute(&quot;email&quot;)
if ( $attr.Ret -eq &quot;Ok&quot; ) {
  $email = $attr.Attr
  $bot.Say(&quot;My email address is: $email&quot;)
} else {
  $bot.Say(&quot;I don't think I have an email address&quot;)
}
</code></pre>
<h2><a class="header" href="#python" id="python">Python</a></h2>
<pre><code class="language-python"># In some cases you might forego error checking
bot.Say(&quot;You can send email to %s&quot; % bot.GetBotAttribte(&quot;email&quot;))
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot.Ok:
  bot.Say(&quot;My full name is %s&quot; % botNameAttr)
else:
  bot.Say(&quot;I don't even know what my name is!&quot;)
</code></pre>
<h2><a class="header" href="#ruby" id="ruby">Ruby</a></h2>
<pre><code class="language-ruby"># In some cases you might forego error checking
bot.Say(&quot;You can send email to #{bot.GetBotAttribute(&quot;email&quot;)}&quot;)
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot::Ok
  bot.Say(&quot;My full name is #{botNameAttr}&quot;)
else
  bot.Say(&quot;I don't even know what my name is!&quot;)
end
</code></pre>
<p><strong>Gopherbot</strong> comes with brain methods allowing plugin authors to store information long-term information like a <code>TODO</code> list, or short-term contextual
information, such as a particular list item under discussion. An important supplement to this guide can be found in the example scripting
plugins in the <code>plugins/</code> directory, and the <code>links</code> and <code>lists</code> <em>Go</em> plugins in the <code>goplugins</code> directory (from the source,
not included in the distributed <code>.zip</code> files).</p>
<h1><a class="header" href="#table-of-contents-1" id="table-of-contents-1">Table of Contents</a></h1>
<ul>
<li><a href="api/Brain-API.html#memory-scoping">Memory Scoping</a></li>
<li><a href="api/Brain-API.html#long-term-memories">Long-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#long-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#long-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
<li><a href="api/Brain-API.html#short-term-memories">Short-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#method-summary">Method Summary</a></li>
<li><a href="api/Brain-API.html#short-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#short-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#memory-scoping" id="memory-scoping">Memory Scoping</a></h1>
<p>Long-term memories are scoped per-plugin by key, and so the data is not shareable between plugins. Short-term memories are stored
for each user/channel combination, and can be freely shared between plugins.</p>
<h1><a class="header" href="#long-term-memories-1" id="long-term-memories-1">Long-Term Memories</a></h1>
<p>The following methods are available for manipulating long-term memories:</p>
<ul>
<li><code>CheckoutDatum(key, RWflag)</code> - returns a complex data item (memory) with a short-term exclusive lock on the datum if RW is <code>true</code></li>
<li><code>CheckinDatum(memory)</code> - signals the robot to release the lock without updating</li>
<li><code>UpdateDatum(memory)</code> - updates the memory and releases the lock</li>
</ul>
<h2><a class="header" href="#long-term-memory-code-examples" id="long-term-memory-code-examples">Long-Term Memory Code Examples</a></h2>
<p>The memory stored can be an arbitrarily complex data item; a hash, array, or combination - anything that can be serialized to/from
JSON. The example plugins for <strong>Python</strong>, <strong>Ruby</strong> and <strong>PowerShell</strong> all implement a <em>remember</em> function that remembers a list (array)
of items. For the code examples, we'll start with a memory whose key is <code>memory</code>, and has two items defined by this snippet of JSON:</p>
<pre><code class="language-json">[&quot;the Alamo&quot;, &quot;Ferris Bueller&quot;]
</code></pre>
<p>The examples will check if the memory exists, add &quot;the answer is 42&quot;, and then update the memory.</p>
<p>Note that long-term memory commands aren't current implemented for <code>bash</code>.</p>
<h3><a class="header" href="#python-1" id="python-1">Python</a></h3>
<pre><code class="language-python">memory = bot.CheckoutDatum(&quot;memory&quot;, True)
if memory.exists:
    memory.datum.append(&quot;the answer is 42&quot;)
else:
    memory.datum = [ thing ]
ret = bot.UpdateDatum(memory)
if ret != Robot.Ok:
    bot.Say(&quot;Uh-oh, I must be gettin' old - having memory problems!&quot;)
</code></pre>
<h3><a class="header" href="#ruby-1" id="ruby-1">Ruby</a></h3>
<p>Note: the Ruby example is a little more complicated; adapted from plugins/rubydemo.rb.</p>
<pre><code class="language-ruby">memory = bot.CheckoutDatum(&quot;memory&quot;, true)
remembered = false
if memory.exists
  if memory.datum.include?(thing)
    bot.Say(&quot;That's already one of my fondest memories&quot;)
    bot.CheckinDatum(memory)
  else
    remembered = true
    memory.datum.push(&quot;the answer is 42&quot;)
  end
else
  remembered = true
  memory.datum = [ &quot;the answer is 42&quot; ]
end
if remembered
  ret = bot.UpdateDatum(memory)
  if ret != Robot::Ok
    bot.Say(&quot;Dang it, having problems with my memory&quot;)
  end
end
</code></pre>
<h3><a class="header" href="#powershell-1" id="powershell-1">PowerShell</a></h3>
<pre><code class="language-powershell">$memory = $bot.CheckoutDatum(&quot;memory&quot;, $TRUE)
if ($memory.exists) {
  $memory.Datum += &quot;the answer is 42&quot;
} else {
  [String[]] $memory.Datum = @( &quot;the answer is 42&quot; )
}
$ret = $bot.UpdateDatum($memory)
if ($ret -ne &quot;Ok&quot;) {
  $bot.Say(&quot;I'm having a hard time remembering things&quot;)
}
</code></pre>
<h2><a class="header" href="#long-term-memory-sample-transcript" id="long-term-memory-sample-transcript">Long-Term Memory Sample Transcript</a></h2>
<p>Using the <code>terminal</code> connector, you can see the <code>remember</code> function in action:</p>
<pre><code>c:general/u:alice -&gt; floyd, remember the answer is 42
general: Ok, I'll remember &quot;the answer is 42&quot;
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, recall
general: Here's everything I can remember:
#1: the Alamo
#2: Ferris Bueller
#3: the answer is 42
</code></pre>
<p>From the transcript you can see that <code>alice</code> added the item to the list, which
was then visible to <code>bob</code>. The <code>links</code> and <code>lists</code> plugins are more useful, and
allow easy sharing of bookmark items or <code>TODO</code> lists, for example.</p>
<h1><a class="header" href="#short-term-memories" id="short-term-memories">Short-Term Memories</a></h1>
<p>Short term memories are simple key -&gt; string values stored for each user / channel combination, and expiring
after a time. The best example of this uses the built-in <code>links</code> and <code>lists</code> plugins, shown in this example
using the <code>terminal</code> plugin:</p>
<pre><code>c:general/u:alice -&gt; link tuna casserole to https://www.allrecipes.com/recipe/17219/best-tuna-casserole/, floyd
general: Link added
c:general/u:alice -&gt; add it to the dinner meals list
c:general/u:alice -&gt; floyd
general: Ok, I added tuna casserole to the dinner meals list
c:general/u:alice -&gt; floyd
general: Yes?
c:general/u:bob -&gt; floyd, pick a random item from the dinner meals list
general: Here you go: tuna casserole
c:general/u:bob -&gt; look it up, floyd
general: Here's what I have for &quot;tuna casserole&quot;:
https://www.allrecipes.com/recipe/17219/best-tuna-casserole/: tuna casserole
</code></pre>
<p>Here, the robot is using short-term memories several times. When I forgot to address my command to the robot, the command
<code>add it to the dinner meals list</code> was stored in short-term memory for user <code>alice</code> in the <code>general</code> channel; then, when
I typed the robot's name, it checked short-term memory for the last thing <code>alice</code> said (stored automatically). Then,
the <code>links</code> plugin stored <code>tuna casserole</code> in the <code>item</code> short-term contextual memory; when I used <code>it</code> in the lists command,
the lists plugin checked the <code>item</code> short-term memory (see <code>contexts</code> in the plugin config for <code>lists</code>) and
substituted the value from the short-term memory.</p>
<h2><a class="header" href="#method-summary" id="method-summary">Method Summary</a></h2>
<p>These methods are available for short-term memories:</p>
<ul>
<li><code>Remember(key, value)</code> - associate the string <code>value</code> to <code>key</code>, always returns <code>Ok</code></li>
<li><code>RememberContext(context, value)</code> - store a short-term contextual memory for use with other plugins</li>
<li><code>Recall(key)</code> - return the short-term memory associated with <code>key</code>, or the empty string when the memory doesn't exist</li>
</ul>
<p>Note that the short-term memory API doesn't have complicated return values. They are always stored in the robot's working
memory and never persisted, and expire after several minutes - so plugins should always be prepared to get blank return
values.</p>
<h2><a class="header" href="#short-term-memory-code-examples" id="short-term-memory-code-examples">Short-Term Memory Code Examples</a></h2>
<p>Note that the short-term memory API is super trivial, so I didn't go to great lengths to provide
detailed examples. The <code>bash</code> example comes from the <code>bashdemo.sh</code> plugin.</p>
<h3><a class="header" href="#bash-1" id="bash-1">Bash</a></h3>
<pre><code class="language-bash">Remember &quot;$1&quot; &quot;$2&quot;
Say &quot;I'll remember \&quot;$1\&quot; is \&quot;$2\&quot; - but eventually I'll forget!&quot;
</code></pre>
<pre><code class="language-bash">MEMORY=$(Recall &quot;$1&quot;)
if [ -z &quot;$MEMORY&quot; ]
then
	Reply &quot;Gosh, I have no idea - I'm so forgetful!&quot;
else
	Say &quot;$1 is $MEMORY&quot;
fi
</code></pre>
<h3><a class="header" href="#python-2" id="python-2">Python</a></h3>
<pre><code class="language-python">bot.Remember(key, value)
</code></pre>
<pre><code class="language-python">mem = bot.Recall(key)
</code></pre>
<h3><a class="header" href="#ruby-2" id="ruby-2">Ruby</a></h3>
<pre><code class="language-ruby">bot.Remember(key, value)
</code></pre>
<pre><code class="language-ruby">mem = bot.Recall(key)
</code></pre>
<h3><a class="header" href="#powershell-2" id="powershell-2">PowerShell</a></h3>
<pre><code class="language-powershell">$bot.Remember($key, $value)
</code></pre>
<pre><code class="language-powershell">$mem = $bot.Recall($key)
</code></pre>
<h2><a class="header" href="#short-term-memory-sample-transcript" id="short-term-memory-sample-transcript">Short-Term Memory Sample Transcript</a></h2>
<p>Here you can see the robot's short term memories of Ferris Bueller in action (using
the <code>bashdemo.sh</code> plugin):</p>
<pre><code>c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: @bob Gosh, I have no idea - I'm so forgetful!
c:general/u:bob -&gt; floyd, store Ferris Bueller is a Righteous Dude
general: I'll remember &quot;Ferris Bueller&quot; is &quot;a Righteous Dude&quot; - but eventually I'll forget!
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; floyd, what is Ferris Bueller
general: @alice Gosh, I have no idea - I'm so forgetful!
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
</code></pre>
<h1><a class="header" href="#table-of-contents-2" id="table-of-contents-2">Table of Contents</a></h1>
<ul>
<li><a href="api/Message-Sending-API.html#message-formatting">Message Formatting</a></li>
<li><a href="api/Message-Sending-API.html#say-and-reply">Say and Reply</a></li>
<li><a href="api/Message-Sending-API.html#sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></li>
<li><a href="api/Message-Sending-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Message-Sending-API.html#bash">Bash</a></li>
<li><a href="api/Message-Sending-API.html#powershell">PowerShell</a></li>
<li><a href="api/Message-Sending-API.html#python">Python</a></li>
<li><a href="api/Message-Sending-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#messageformat-method-and-message-formatting" id="messageformat-method-and-message-formatting">MessageFormat method and Message Formatting</a></h1>
<p><strong>Gopherbot</strong> is designed to provide ChatOps functionality for a variety of team
chat platforms, with Slack being the first. Due to the technical nature of ChatOps,
characters like <code>_</code>, <code>*</code> and ` may need to be rendered in replies to the user;
at times omitting these characters (because they cause formatting changes) could
remove important information. To provide the plugin author with the most flexibility,
<strong>Gopherbot</strong> supports the notion of three message formats:</p>
<ul>
<li><code>Raw</code> - text sent by a plugin with <code>Raw</code> format is passed straight to the chat platform as-is; this is the default if no other default is specified</li>
<li><code>Variable</code> - for the <code>Variable</code> format, the protocol connector should attempt to process the message so that special characters are escaped or otherwise modified to render for the user in a standard variable-width font; for Slack, special characters are surrounded by nulls</li>
<li><code>Fixed</code> - the protocol connector should render <code>Fixed</code> format messages in a fixed-width block format</li>
</ul>
<p>The <code>MessageFormat(raw|variable|fixed)</code> method returns a robot object with the specified format. A plugin can use
<code>GetBotAttribute(&quot;protocol&quot;)</code> to determine the connector protocol (e.g. &quot;slack&quot;) to make intelligent decisions
about the format to use, or modify the content of raw messages depending on the connection protocol.</p>
<h1><a class="header" href="#say-and-reply" id="say-and-reply">Say and Reply</a></h1>
<p><code>Say</code> and <code>Reply</code> are the staples of message sending. Both are generally used for replying to the person who spoke to the robot, but <code>Reply</code> will also <em>mention</em> the user. Normally, <code>Say</code> is used when the robot responds immediately to the user, but <code>Reply</code> is used when the robot is performing a task that takes more than a few minutes, and the robot needs to direct the message to the user to update them with progress on the task. Both <code>Say</code> and <code>Reply</code> take a <code>message</code> argument, and an optional second <code>format</code> argument that can be <code>variable</code> (the default) for variable-width text, or <code>fixed</code> for fixed-width text. The <code>fixed</code> format is normally used with embedded newlines to create tabular output where the columns will line up. The return value is not normally checked, but can be one of <code>Ok</code>, <code>UserNotFound</code>, <code>ChannelNotFound</code>, or <code>FailedMessageSend</code>.</p>
<h1><a class="header" href="#sendusermessage-sendchannelmessage-and-senduserchannelmessage" id="sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></h1>
<p><code>Say</code> and <code>Reply</code> are actually convenience wrappers for the <code>Send*Message</code> family of methods. <code>SendChannelMessage</code> takes the obvious arguments of <code>channel</code> and <code>message</code> and just writes a message to a channel. <code>SendUserMessage</code> sends a direct message to a user, and <code>SendUserChannelMessage</code> directs the message to a user in a channel by using a connector-specific <em>mention</em>. Like <code>Say</code> and <code>Reply</code>, each of these functions also takes an optional <code>format</code> argument, and uses the same return values.</p>
<h1><a class="header" href="#code-examples-1" id="code-examples-1">Code Examples</a></h1>
<h2><a class="header" href="#bash-2" id="bash-2">Bash</a></h2>
<pre><code class="language-bash"># Note that bash isn't object-oriented
Say &quot;I'm sending a message to Bob in #general&quot;
SendUserChannelMessage &quot;bob&quot; &quot;general&quot; &quot;Hi, Bob!&quot;
RETVAL = $?
if [ $RETVAL -ne $GBRET_Ok ]
then
  Log &quot;Error&quot; &quot;Unable to message Bob in #general - return code $RETVAL&quot;
fi
</code></pre>
<h2><a class="header" href="#powershell-3" id="powershell-3">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
$retval = $bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( $retval -ne &quot;Ok&quot; ) {
  $bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code $retval&quot;)
}
</code></pre>
<h2><a class="header" href="#python-3" id="python-3">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( retval != Robot.Ok ):
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
</code></pre>
<h2><a class="header" href="#ruby-3" id="ruby-3">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if retval != Robot::Ok
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
end
</code></pre>
<p><strong>Gopherbot</strong> takes a slightly different approach to creating pipelines; pipelines are created by Add/Fail/Final Job/Command/Task family of methods, rather than by fixed configuration directives. This allows flexible configuration of pipelines if desired for e.g. a CI/CD application, or dynamic generation of pipelines based on logic at runtime.</p>
<p>Until more documentation is written, see:</p>
<ul>
<li><a href="https://github.com/lnxjedi/gopherbot/blob/master/.gopherci/pipeline.sh">The Gopherbot Pipeline Source</a></li>
<li><a href="https://github.com/parsley42/floyd-gopherbot">The Configuration repository for Floyd, the robot that builds Gopherbot</a></li>
</ul>
<h1><a class="header" href="#table-of-contents-3" id="table-of-contents-3">Table of Contents</a></h1>
<ul>
<li><a href="api/Pipeline-API.html#addtask">AddTask</a></li>
<li><a href="api/Pipeline-API.html#setparameter">SetParameter</a></li>
</ul>
<h2><a class="header" href="#addtask" id="addtask">AddTask</a></h2>
<p>The <code>AddTask</code> method ... TODO: finish me!</p>
<h3><a class="header" href="#bash-3" id="bash-3">Bash</a></h3>
<pre><code class="language-bash">AddTask &quot;echo&quot; &quot;hello, world&quot;
</code></pre>
<h3><a class="header" href="#python-4" id="python-4">Python</a></h3>
<pre><code class="language-python"></code></pre>
<h3><a class="header" href="#ruby-4" id="ruby-4">Ruby</a></h3>
<pre><code class="language-ruby"></code></pre>
<h3><a class="header" href="#powershell-4" id="powershell-4">PowerShell</a></h3>
<pre><code class="language-powershell">$ret = $bot.AddTask(&quot;echo&quot;, @(&quot;hello&quot;, &quot;world&quot;))
</code></pre>
<h2><a class="header" href="#setparameter-1" id="setparameter-1">SetParameter</a></h2>
<p>The <code>Prompt*ForReply</code> methods make it simple to write interactive plugins where the bot can request additional input from the user.</p>
<h1><a class="header" href="#table-of-contents-4" id="table-of-contents-4">Table of Contents</a></h1>
<ul>
<li><a href="api/Response-Request-API.html#technical-background">Technical Background</a></li>
<li><a href="api/Response-Request-API.html#prompting-methods">Prompting Methods</a>
<ul>
<li><a href="api/Response-Request-API.html#method-arguments">Method Arguments</a></li>
<li><a href="api/Response-Request-API.html#return-values">Return Values</a></li>
</ul>
</li>
<li><a href="api/Response-Request-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Response-Request-API.html#bash">Bash</a></li>
<li><a href="api/Response-Request-API.html#powershell">PowerShell</a></li>
<li><a href="api/Response-Request-API.html#python">Python</a></li>
<li><a href="api/Response-Request-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#technical-background" id="technical-background">Technical Background</a></h2>
<p>Interactive plugins are complicated by the fact that multiple plugins can be running simultaneously and each can request input from the user. <strong>Gopherbot</strong> handles requests for replies this way:</p>
<ol>
<li>If there are no other plugins waiting for a reply for the given user/channel, the robot emits the prompt and waits to hear back from the user</li>
<li>If other plugins are waiting for a reply, the prompt is not emitted and the request goes in to a list of waiters</li>
<li>As other plugins get replies (or timeout while waiting), waiters in the list get a <code>RetVal</code> of <code>RetryPrompt</code>, indicating they should issue the prompt request again (this is handled internally in individual scripting libraries)</li>
</ol>
<h2><a class="header" href="#prompting-methods" id="prompting-methods">Prompting Methods</a></h2>
<p>The following methods are available for prompting for replies:</p>
<ul>
<li><code>PromptForReply(regexID string, prompt string)</code> - issue a prompt to whoever/wherever the original command was issued</li>
<li><code>PromptUserForReply(regexID string, user string, prompt string)</code> - for prompting the user in a direct message (DM) (for e.g. a password or other sensitive information)</li>
<li><code>PromptUserChannelForReply(regexID string, user string, channel string, prompt string)</code> - prompt a specific user in a specific channel (for e.g. getting approval from another user for an action)</li>
</ul>
<h3><a class="header" href="#method-arguments" id="method-arguments">Method arguments</a></h3>
<p>The <code>user</code> and <code>channel</code> arguments are obvious; the <code>prompt</code> is the question the robot is
asking the user, and should usually end with a <code>?</code>.</p>
<p>The <code>regexID</code> should correspond to a <code>ReplyMatcher</code> defined in the plugin configuration,
(see <a href="api/Configuration.html#plugin-configuration">Plugin Configuration</a>), or one of the
built-in regex's:</p>
<ul>
<li><code>Email</code></li>
<li><code>Domain</code> - an alpha-numeric domain name</li>
<li><code>OTP</code> - a 6-digit one-time password code</li>
<li><code>IPAddr</code></li>
<li><code>SimpleString</code> - Characters commonly found in most english sentences, doesn't include special characters like @, {, etc.</li>
<li><code>YesNo</code></li>
</ul>
<h3><a class="header" href="#return-values" id="return-values">Return Values</a></h3>
<p>Two distinct values are returned from the prompting methods:</p>
<ol>
<li>A <code>RetVal</code> indicating success or error condition - <code>Reply.ret</code></li>
<li>When <code>RetVal</code> == <code>Ok</code>, the matched string is also returned - <code>Reply.reply</code></li>
</ol>
<p>In <strong>Go</strong>, these are returned as two separate values; in most scripting
languages, these are returned as a compound object whose string representation
is the returned string in <code>Reply.reply</code> (if the <code>RetVal</code> was <code>Ok</code>, otherwise it's the empty string).</p>
<p>Possible values for the <code>RetVal</code> in <code>Reply.ret</code> are:</p>
<ul>
<li><code>Ok</code> - If the user replied and the reply matched the regex identified by <code>regexID</code></li>
<li><code>UserNotFound</code>, <code>ChannelNotFound</code> - When an invalid user / channel is provided</li>
<li><code>MatcherNotFound</code> - When an invalid matcher is supplied</li>
<li><code>Interrupted</code> - If the user issues a new command to the robot (see NOTE below), too many <code>RetryPrompt</code> values are returned (&gt;3), or the user replies with a single dash: '<code>-</code>' (cancel)</li>
<li><code>TimeoutExpired</code> - If the user says nothing for 45 seconds</li>
<li><code>UseDefaultValue</code> - If the user replied with a single equal sign (<code>=</code>)</li>
<li><code>ReplyNotMatched</code> - When the reply from the user didn't match the supplied regex (the user was probably talking to somebody else)</li>
</ul>
<h2><a class="header" href="#code-examples-2" id="code-examples-2">Code Examples</a></h2>
<h3><a class="header" href="#bash-4" id="bash-4">Bash</a></h3>
<pre><code class="language-bash"># Note that bash isn't object-oriented
REPLY=$(PromptForReply &quot;YesNo&quot; &quot;Do you like kittens?&quot;)
if [ $? -ne 0 ]
then
	Reply &quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;
else
  if [[ $REPLY == y* ]] || [[ $REPLY == Y* ]]
  then
    Say &quot;No kidding! Me too!&quot;
  else
    Say &quot;Oh, come on - you're kidding, right?!?&quot;
  fi
fi
</code></pre>
<h3><a class="header" href="#powershell-5" id="powershell-5">PowerShell</a></h3>
<pre><code class="language-powershell">$rep = $bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if ($rep.Ret -ne &quot;Ok&quot;) {
  $bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
} else {
  $reply = [String]$rep
  switch -Wildcard ($reply) {
    &quot;y*&quot; { # PS is case-insensitive
      $bot.Say(&quot;No kidding! Me too!&quot;)
    }
    default {
      $bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
    }
  }
}
</code></pre>
<h3><a class="header" href="#python-5" id="python-5">Python</a></h3>
<pre><code class="language-python">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot.Ok:
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else:
  reply = rep.__str__()
  if re.match(&quot;y.*&quot;, reply, flags=re.IGNORECASE):
    bot.Say(&quot;No kidding! Me too!&quot;)
  else:
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
</code></pre>
<h3><a class="header" href="#ruby-5" id="ruby-5">Ruby</a></h3>
<pre><code class="language-ruby">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot::Ok
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else
  reply = rep.to_s()
  if /y.*/i =~ reply
    bot.Say(&quot;No kidding! Me too!&quot;)
  else
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
  end
end
</code></pre>
<h1><a class="header" href="#log-method" id="log-method">Log Method</a></h1>
<p>Besides the logging that Gopherbot does on it's own, plugins can also emit log messages with one of the following log levels:</p>
<ul>
<li><code>Trace</code> - for fine-grained logging of all actions</li>
<li><code>Debug</code> - for emitting debugging info</li>
<li><code>Info</code> - the default log level</li>
<li><code>Audit</code> - for auditable events - <strong>NOTE:</strong> <em>Audit events are always logged regardless of the current log level</em></li>
<li><code>Warn</code> - for potentially harmful events</li>
<li><code>Error</code> - for errors</li>
<li><code>Fatal</code> - emit fatal error and cause robot to exit(1)</li>
</ul>
<h2><a class="header" href="#bash-5" id="bash-5">Bash</a></h2>
<pre><code class="language-bash">Log &quot;Error&quot; &quot;The robot broke&quot;
</code></pre>
<h2><a class="header" href="#powershell-6" id="powershell-6">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2><a class="header" href="#python-6" id="python-6">Python</a></h2>
<pre><code class="language-python">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2><a class="header" href="#ruby-6" id="ruby-6">Ruby</a></h2>
<pre><code class="language-ruby">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h1><a class="header" href="#pause-method" id="pause-method">Pause Method</a></h1>
<p>Every language has some means of sleeping / pausing, and this method is provided as a convenience to plugin authors and implemented natively. It takes a single argument, time in seconds.</p>
<h2><a class="header" href="#bash-6" id="bash-6">Bash</a></h2>
<pre><code class="language-bash">Say &quot;Be back soon!&quot;
Pause 2
Say &quot;... aaaand I'm back!&quot;
</code></pre>
<h2><a class="header" href="#powershell-7" id="powershell-7">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Say(&quot;Be back soon!&quot;)
$bot.Pause(2)
$bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#python-7" id="python-7">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#ruby-7" id="ruby-7">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#gopherbot-loadable-module-support" id="gopherbot-loadable-module-support">Gopherbot Loadable Module Support</a></h2>
<p><strong>Gopherbot's</strong> loadable module support now allows new or updated <strong>Go</strong> plugins to be loaded in to a running robot (though it requires a full restart).</p>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>Reference material for <strong>Gopherbot</strong> administrators and developers.</p>
<h1><a class="header" href="#appendix-a-protocols" id="appendix-a-protocols">Appendix A: Protocols</a></h1>
<p><strong>Gopherbot</strong> communicates with users via different protocols, and extensions can modify their behavior and provide protocol-specific functionality based on values provided to the extension. For <strong>Go</strong> extensions, this is provided in the <code>robot.Message</code> struct provided by the <code>GetMessage()</code> method. For external scripts, this is provided in the <code>GOPHER_PROTOCOL</code> environment variable.</p>
<p>The design of <strong>Gopherbot</strong> is meant for mainly protocol-agnostic functionality. Running jobs and querying infrastructure should operate in much the same way whether the protocol is <strong>Slack</strong> or <strong>Terminal</strong>. However, some teams may wish to create protocol-specific extensions, and accept the risk of a more difficult transition should the team switch their primary chat platform.</p>
<h1><a class="header" href="#a1-slack" id="a1-slack">A.1 Slack</a></h1>
<p>The first and best-supported protocol is <a href="https://slack.com">Slack</a>. Developers wishing to support new protocols should consider Slack the &quot;gold standard&quot;. <strong>Gopherbot</strong> uses the <a href="https://github.com/slack-go/slack">slack-go/slack</a> library.</p>
<p>The <code>Message</code> struct for Slack will have an <code>.Protocol</code> value of <code>robot.Slack</code>, and <code>.Incoming</code> pointer to a <code>robot.ConnectorMessage</code> struct:</p>
<ul>
<li><code>Protocol</code>: &quot;slack&quot;</li>
<li><code>MessageObject</code>: <code>*slack.MessageEvent</code></li>
<li><code>Client</code>: <code>*slack.Client</code></li>
</ul>
<h1><a class="header" href="#a2-rocketchat" id="a2-rocketchat">A.2 Rocket.Chat</a></h1>
<p><a href="https://rocket.chat/">Rocket.Chat</a> is currently the only other network-based team chat protocol for <strong>Gopherbot</strong>, coded as a fallback in the event that <strong>Slack</strong> changes the API in a ChatOps un-friendly way. When it was written, the <strong>Go</strong> library for <strong>Rocket.Chat</strong> lacked some basic functionality, so it was forked to an internal version. This protocol is not currently well supported, and could use some TLC from a developer using the protocol.</p>
<h1><a class="header" href="#terminal" id="terminal">Terminal</a></h1>
<p>The <strong>terminal</strong> connector is the second-best supported connector, and will remain supported for the life of <strong>Gopherbot</strong>. It is built-in to the main binary, and heavily used for developing robot extensions prior to deployment in a network-connected chat protocol.</p>
<h1><a class="header" href="#test" id="test">Test</a></h1>
<p>The <strong>test</strong> protocol is only used for the <strong>Gopherbot</strong> integration test suite. See the <code>test/</code> subdirectory for details on it's operation. The <strong>test</strong> protocol will also remain supported for the life of <strong>Gopherbot</strong>.</p>
<h1><a class="header" href="#nullconn" id="nullconn">Nullconn</a></h1>
<p>The <strong>null</strong> connector is not actually able to communicate with users, and was written to support installation and bootstrapping code. In theory, the <strong>null</strong> connector could be used in production as an alternative to e.g. cron, running jobs developed with the <strong>terminal</strong> connector; however, no known users are doing this and it's currently unsupported for this use.</p>
<h1><a class="header" href="#working-on-gopherbot" id="working-on-gopherbot">Working on Gopherbot</a></h1>
<p>This chapter outlines the tools and methods for working on <strong>Gopherbot</strong> itself.</p>
<h1><a class="header" href="#development-robot" id="development-robot">Development Robot</a></h1>
<h1><a class="header" href="#developing-integration-tests" id="developing-integration-tests">Developing Integration Tests</a></h1>
<p>The current testing methodology for <strong>Gopherbot</strong> uses a special <code>test</code> protocol connector for sending test commands to the engine from various users in various channels, and then examining the responses and events generated. The tests themselves and test configurations are located in <code>/test</code>.</p>
<h2><a class="header" href="#building-the-special-testbot" id="building-the-special-testbot">Building the special &quot;testbot&quot;</a></h2>
<p>The <strong>Gopherbot</strong> <code>Makefile</code> includes a special &quot;testbot&quot; target that builds the robot with a modified version of the terminal connector:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
</code></pre>
<h2><a class="header" href="#developing-tests" id="developing-tests">Developing Tests</a></h2>
<p>See the contents of <code>test/*_test.go</code> for the format of the tests. After any given exchange with the robot, pressing <code>&lt;enter&gt;</code> by itself gives the events generated. Here's an example session for developing the tests in <code>test/bot_integration_test.go:TestPrompting</code>:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
[gopherbot]$ cd test/membrain
[membrain]$ ../../gopherbot 
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
...
</code></pre>
<h2><a class="header" href="#debugging-deadlocks" id="debugging-deadlocks">Debugging Deadlocks</a></h2>
<p>Occasionally locking changes in the core may result in deadlocks, which should hopefully be detected by the test suite. To assist in debugging these, the <code>SIGTERM</code> handler changes for the <code>test</code> build tag, causing the robot to perform a full stack dump and panic. Note that if an actual robot deadlocks, it should still accept an <code>abort</code> command from an administrator, which will trigger the same behavior.</p>
<p>If <code>make test</code> hangs, you can trigger a stack dump with <code>&lt;ctrl-c&gt;</code>; here's an example where updated locking of the <code>botContext</code> struct introduced a deadlock in the <code>reload</code> command:</p>
<pre><code class="language-shell">$ make test
...
=== RUN   TestReload
# Test hung here, &lt;ctrl-c&gt;
goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:24 +0x243
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
...
goroutine 590 [semacquire]:
sync.runtime_SemacquireMutex(0xc000358504, 0x900000000, 0x1)
        /usr/local/go/src/runtime/sema.go:71 +0x47
sync.(*Mutex).lockSlow(0xc000358500)
        /usr/local/go/src/sync/mutex.go:138 +0x1c1
sync.(*Mutex).Lock(0xc000358500)
        /usr/local/go/src/sync/mutex.go:81 +0x7d
github.com/lnxjedi/gopherbot/bot.Robot.getLockedContext(0xc00016e540, 0x81, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot.go:25 +0x4e
github.com/lnxjedi/gopherbot/bot.Robot.Reply(0xc00016e540, 0x81, 0xbf0ee6, 0x23, 0x0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot_connector_methods.go:212 +0x121
github.com/lnxjedi/gopherbot/bot.admin(0xce2020, 0xc0001ff930, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/builtins.go:345 +0x16b2
github.com/lnxjedi/gopherbot/bot.(*botContext).callTaskThread(0xc000358500, 0xc0003df6e0, 0xb0ef20, 0xc00012a180, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/calltask.go:138 +0xb64
created by github.com/lnxjedi/gopherbot/bot.(*botContext).callTask
        /home/davidparsley/git/gopherbot/bot/calltask.go:75 +0xe8
...
panic: Tests terminated by signal terminated

goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:27 +0x37a
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
FAIL    github.com/lnxjedi/gopherbot/test       58.197s
FAIL
Makefile:52: recipe for target 'test' failed
make: *** [test] Error 1
</code></pre>
<p>In this case the lock on the <code>botContext</code> was first aquired at the top of the admin <code>reload</code> built-in command, and then hung later when trying to acquire the lock in the robot <code>Reply</code> method.</p>
<h1><a class="header" href="#coding-with-gitpod" id="coding-with-gitpod">Coding with Gitpod</a></h1>
<h1><a class="header" href="#important-structs-and-interfaces" id="important-structs-and-interfaces">Important Structs and Interfaces</a></h1>
<h2><a class="header" href="#the-robot-package" id="the-robot-package">The <code>robot</code> package</a></h2>
<p>The <code>robot</code> package defines structs and interfaces for <strong>Go</strong> tasks, plugins and jobs.</p>
<h3><a class="header" href="#the-robot-interface" id="the-robot-interface">The <code>Robot</code> interface</a></h3>
<p><code>Robot</code> defines the methods available to a <strong>Go</strong> task, plugin or job. Whenever the engine calls a handler for one of these, the first argument to the handler is always an object that implements the <code>Robot</code> interface. Internally (in the <code>bot</code> package), this is a <code>bot.Robot</code> struct, with methods that implement the <code>robot.Robot</code> interface.</p>
<h3><a class="header" href="#the-message-struct" id="the-message-struct">The <code>Message</code> struct</a></h3>
<p>The <code>GetMessage()</code> method on the <code>Robot</code> will return a <code>robot.Message</code>, which contains information about the user and channel, as well as a pointer to a copy of the original incoming data structure from the external connector. The complete definition is available from <a href="https://godoc.org/github.com/lnxjedi/robot#Message">godoc.org</a>.</p>
<h2><a class="header" href="#the-bot-package" id="the-bot-package">The <code>bot</code> package</a></h2>
<p>The <code>bot</code> package contains all the logic for a running robot.</p>
<h3><a class="header" href="#pipelines" id="pipelines">Pipelines</a></h3>
<p>Any time <strong>Gopherbot</strong> runs a task, plugin or job, it is part of a pipeline (which may consist only of a single job or plugin executing). The data structures for representing a pipeline are the <code>worker</code> and the <code>pipeContext</code>.</p>
<h3><a class="header" href="#workers" id="workers">Workers</a></h3>
<p>The <code>worker</code> struct represents a thread of execution. The worker contains all the invariant information about how it was created, whether from an incoming message, a scheduled job, or a job spawn from another worker. Workers are created for every incoming message, regardless of whether a pipeline is ever started. The worker includes a <code>context</code> pointer that is populated when <code>startPipeline(...)</code> is called.</p>
<h3><a class="header" href="#pipe-context" id="pipe-context">Pipe Context</a></h3>
<p>Whenever a pipeline is started, the <code>context</code> member of the <code>worker</code> struct is populated with a <code>pipeContext</code> (by <code>bot.registerActive</code>), to keep state for the pipeline. At this time four bytes of entropy are consumed for the <code>GOPHER_CALLER_ID</code> environment variable, to be passed to external scripts that run in the pipeline. This allows <code>bot/http.go</code> to look up the correct robot on each external script method call. The <code>pipeContext</code> contains a <code>sync.Mutex</code> member for locking, as it can be changed in different threads of execution. Note, however, that a well written task, plugin or job is not multi-threaded, and under normal circumstances all access to the <code>pipeContext</code> <em>should</em> be serialized.</p>
<h3><a class="header" href="#robots" id="robots">Robots</a></h3>
<p>The <code>bot.Robot</code> struct is created any time a task, plugin or job is run, and contains a pointer to the <code>robot.Message</code>, a pointer to the <code>bot.worker</code>, and a snapshot of the current <code>pipeContext</code> when <code>w.makeRobot</code> was called.</p>
<h1><a class="header" href="#protocols" id="protocols">Protocols</a></h1>
<p>At different points during the development of <strong>Gopherbot</strong>, consideration was given to the possibility of being <em>multi-protocol</em>, allowing messages to come in from different protocols to a single running instance. This has not come to fruition, and is left as being 'under consideration'.</p>
<p>The primary use for the <strong>Protocol</strong> struct fields (and <code>GOPHER_PROTOCOL</code> environment variable) is being informative for extensions; this functionality should remain, and stay much the same. Otherwise, the multi-protocol question is left open.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
